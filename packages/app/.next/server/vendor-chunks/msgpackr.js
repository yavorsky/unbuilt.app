"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/msgpackr";
exports.ids = ["vendor-chunks/msgpackr"];
exports.modules = {

/***/ "(action-browser)/../../node_modules/msgpackr/dist/node.cjs":
/*!*************************************************!*\
  !*** ../../node_modules/msgpackr/dist/node.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar module$1 = __webpack_require__(/*! module */ \"module\");\n\nvar decoder;\ntry {\n\tdecoder = new TextDecoder();\n} catch(error) {}\nvar src;\nvar srcEnd;\nvar position$1 = 0;\nconst EMPTY_ARRAY = [];\nvar strings = EMPTY_ARRAY;\nvar stringPosition = 0;\nvar currentUnpackr = {};\nvar currentStructures;\nvar srcString;\nvar srcStringStart = 0;\nvar srcStringEnd = 0;\nvar bundledStrings$1;\nvar referenceMap;\nvar currentExtensions = [];\nvar dataView;\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n};\nclass C1Type {}\nconst C1 = new C1Type();\nC1.name = 'MessagePack 0xC1';\nvar sequentialMode = false;\nvar inlineObjectReadThreshold = 2;\nvar readStruct$1, onLoadedStructures$1, onSaveState;\n// no-eval build\ntry {\n\tnew Function('');\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity;\n}\n\nclass Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true;\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = [];\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length;\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true; // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0;\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number';\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options);\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState$1(() => {\n\t\t\t\tclearSource();\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length;\n\t\t\tposition$1 = options.start || 0;\n\t\t} else {\n\t\t\tposition$1 = 0;\n\t\t\tsrcEnd = options > -1 ? options : source.length;\n\t\t}\n\t\tstringPosition = 0;\n\t\tsrcStringEnd = 0;\n\t\tsrcString = null;\n\t\tstrings = EMPTY_ARRAY;\n\t\tbundledStrings$1 = null;\n\t\tsrc = source;\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null;\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this;\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures;\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = [];\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions;\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = [];\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0;\n\t\ttry {\n\t\t\tsequentialMode = true;\n\t\t\tlet size = source.length;\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size);\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position$1) === false) return;\n\t\t\t\twhile(position$1 < size) {\n\t\t\t\t\tlastPosition = position$1;\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position$1) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ];\n\t\t\t\twhile(position$1 < size) {\n\t\t\t\t\tlastPosition = position$1;\n\t\t\t\t\tvalues.push(checkedRead());\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition;\n\t\t\terror.values = values;\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false;\n\t\t\tclearSource();\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures$1)\n\t\t\tloadedStructures = onLoadedStructures$1.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || [];\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0));\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i];\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true;\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5;\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length;\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id];\n\t\t\t\tlet existing = existingStructures[id];\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure;\n\t\t\t\t\tloadedStructures[id] = existing;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nfunction checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0;\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength;\n\t\t}\n\t\tlet result;\n\t\tif (currentUnpackr.randomAccessStructure && src[position$1] < 0x40 && src[position$1] >= 0x20 && readStruct$1) {\n\t\t\tresult = readStruct$1(src, position$1, srcEnd, currentUnpackr);\n\t\t\tsrc = null; // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON();\n\t\t\tposition$1 = srcEnd;\n\t\t} else\n\t\t\tresult = read();\n\t\tif (bundledStrings$1) { // bundled strings to skip past\n\t\t\tposition$1 = bundledStrings$1.postBundlePosition;\n\t\t\tbundledStrings$1 = null;\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null;\n\n\t\tif (position$1 == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures();\n\t\t\tcurrentStructures = null;\n\t\t\tsrc = null;\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null;\n\t\t} else if (position$1 > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100);\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')';\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures();\n\t\tclearSource();\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position$1 > srcEnd) {\n\t\t\terror.incomplete = true;\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id];\n\t}\n\tcurrentStructures.restoreStructures = null;\n}\n\nfunction read() {\n\tlet token = src[position$1++];\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f];\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f);\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80;\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {};\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey();\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_';\n\t\t\t\t\tobject[key] = read();\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map();\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read());\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90;\n\t\t\tlet array = new Array(token);\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read();\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0;\n\t\tif (srcStringEnd >= position$1) {\n\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value;\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings$1) {\n\t\t\t\t\tvalue = read(); // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position$1++];\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position$1++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position$1);\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position$1] & 0x7f) << 1) | (src[position$1 + 1] >> 7)];\n\t\t\t\t\tposition$1 += 4;\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position$1);\n\t\t\t\tposition$1 += 8;\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position$1++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position$1) * 0x100000000;\n\t\t\t\t\tvalue += dataView.getUint32(position$1 + 4);\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position$1).toString();\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position$1);\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value);\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position$1);\n\t\t\t\tposition$1 += 8;\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position$1++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position$1) * 0x100000000;\n\t\t\t\t\tvalue += dataView.getUint32(position$1 + 4);\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position$1).toString();\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position$1);\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value);\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position$1);\n\t\t\t\tposition$1 += 8;\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position$1++];\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position$1++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value];\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition$1++; // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition$1++; // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position$1, ++position$1))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position$1];\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition$1++;\n\t\t\t\t\treturn recordDefinition(src[position$1++] & 0x3f, src[position$1++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position$1++];\n\t\t\t\tif (srcStringEnd >= position$1) {\n\t\t\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\tif (srcStringEnd >= position$1) {\n\t\t\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\tif (srcStringEnd >= position$1) {\n\t\t\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data');\n\t\t\t\t\terror.incomplete = true;\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/;\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read);\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read);\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {};\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i];\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read();\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0;\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position$1++];\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);\n\t\tlet structure = currentStructures[id] || loadStructures()[id];\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId);\n\t\treturn structure.read()\n\t}\n};\n\nfunction loadStructures() {\n\tlet loadedStructures = saveState$1(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null;\n\t\treturn currentUnpackr.getStructures()\n\t});\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS;\nvar readString8 = readStringJS;\nvar readString16 = readStringJS;\nvar readString32 = readStringJS;\nexports.isNativeAccelerationEnabled = false;\n\nfunction setExtractor(extractStrings) {\n\texports.isNativeAccelerationEnabled = true;\n\treadFixedString = readString(1);\n\treadString8 = readString(2);\n\treadString16 = readString(3);\n\treadString32 = readString(5);\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++];\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings$1)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset;\n\t\t\t\tlet extraction = extractStrings(position$1 - headerLength + byteOffset, srcEnd + byteOffset, src.buffer);\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction;\n\t\t\t\t\tstrings = EMPTY_ARRAY;\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction;\n\t\t\t\t\tstringPosition = 1;\n\t\t\t\t\tsrcStringEnd = 1; // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0];\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length;\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition$1 += length;\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string;\n\t\t\tsrcStringStart = position$1;\n\t\t\tsrcStringEnd = position$1 + srcStringLength;\n\t\t\tposition$1 += length;\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result;\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position$1, position$1 += length))\n\tconst end = position$1 + length;\n\tconst units = [];\n\tresult = '';\n\twhile (position$1 < end) {\n\t\tconst byte1 = src[position$1++];\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1);\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position$1++] & 0x3f;\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2);\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position$1++] & 0x3f;\n\t\t\tconst byte3 = src[position$1++] & 0x3f;\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position$1++] & 0x3f;\n\t\t\tconst byte3 = src[position$1++] & 0x3f;\n\t\t\tconst byte4 = src[position$1++] & 0x3f;\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000;\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800);\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff);\n\t\t\t}\n\t\t\tunits.push(unit);\n\t\t} else {\n\t\t\tunits.push(byte1);\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units);\n\t\t\tunits.length = 0;\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units);\n\t}\n\n\treturn result\n}\nfunction readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition$1 = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length);\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read();\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {};\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey();\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read();\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map();\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read());\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n\tlet start = position$1;\n\tlet bytes = new Array(length);\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position$1++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition$1 = start;\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte;\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position$1++];\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition$1 -= 1;\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position$1++];\n\t\t\tlet b = src[position$1++];\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition$1 -= 2;\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position$1++];\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition$1 -= 3;\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position$1++];\n\t\tlet b = src[position$1++];\n\t\tlet c = src[position$1++];\n\t\tlet d = src[position$1++];\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition$1 -= 4;\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position$1++];\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition$1 -= 5;\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position$1++];\n\t\t\tlet f = src[position$1++];\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition$1 -= 6;\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position$1++];\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition$1 -= 7;\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position$1++];\n\t\t\tlet f = src[position$1++];\n\t\t\tlet g = src[position$1++];\n\t\t\tlet h = src[position$1++];\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition$1 -= 8;\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position$1++];\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition$1 -= 9;\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position$1++];\n\t\t\t\tlet j = src[position$1++];\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition$1 -= 10;\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position$1++];\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition$1 -= 11;\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position$1++];\n\t\t\t\tlet j = src[position$1++];\n\t\t\t\tlet k = src[position$1++];\n\t\t\t\tlet l = src[position$1++];\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition$1 -= 12;\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position$1++];\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition$1 -= 13;\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position$1++];\n\t\t\t\t\tlet n = src[position$1++];\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition$1 -= 14;\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position$1++];\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition$1 -= 15;\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position$1++];\n\tlet length;\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0;\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position$1++];\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position$1, position$1 += length) :\n\t\tsrc.subarray(position$1, position$1 += length)\n}\nfunction readExt(length) {\n\tlet type = src[position$1++];\n\tif (currentExtensions[type]) {\n\t\tlet end;\n\t\treturn currentExtensions[type](src.subarray(position$1, end = (position$1 += length)), (readPosition) => {\n\t\t\tposition$1 = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition$1 = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096);\nfunction readKey() {\n\tlet length = src[position$1++];\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0;\n\t\tif (srcStringEnd >= position$1) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition$1--;\n\t\treturn asSafeString(read())\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position$1) : length > 0 ? src[position$1] : 0)) & 0xfff;\n\tlet entry = keyCache[key];\n\tlet checkPosition = position$1;\n\tlet end = position$1 + length - 3;\n\tlet chunk;\n\tlet i = 0;\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition);\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000;\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4;\n\t\t}\n\t\tend += 3;\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++];\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000;\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition$1 = checkPosition;\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3;\n\t\tcheckPosition = position$1;\n\t}\n\tentry = [];\n\tkeyCache[key] = entry;\n\tentry.bytes = length;\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition);\n\t\tentry.push(chunk);\n\t\tcheckPosition += 4;\n\t}\n\tend += 3;\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++];\n\t\tentry.push(chunk);\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nfunction asSafeString(property) {\n\t// protect against expensive (DoS) string conversions\n\tif (typeof property === 'string') return property;\n\tif (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();\n\tif (property == null) return property + '';\n\tthrow new Error('Invalid property type for record', typeof property);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(asSafeString); // ensure that all keys are strings and\n\t// that the array is mutable\n\tlet firstByte = id;\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id);\n\t\tstructure.highByte = highByte;\n\t}\n\tlet existingStructure = currentStructures[id];\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;\n\t}\n\tcurrentStructures[id] = structure;\n\tstructure.read = createStructureReader(structure, firstByte);\n\treturn structure.read()\n};\ncurrentExtensions[0] = () => {}; // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true;\n\ncurrentExtensions[0x42] = (data) => {\n\t// decode bigint\n\tlet length = data.length;\n\tlet value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);\n\tfor (let i = 1; i < length; i++) {\n\t\tvalue <<= 8n;\n\t\tvalue += BigInt(data[i]);\n\t}\n\treturn value;\n};\n\nlet errors = { Error, TypeError, ReferenceError };\ncurrentExtensions[0x65] = () => {\n\tlet data = read();\n\treturn (errors[data[0]] || Error)(data[1], { cause: data[2] })\n};\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position$1 - 4);\n\tif (!referenceMap)\n\t\treferenceMap = new Map();\n\tlet token = src[position$1];\n\tlet target;\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = [];\n\telse\n\t\ttarget = {};\n\n\tlet refEntry = { target }; // a placeholder object\n\treferenceMap.set(id, refEntry);\n\tlet targetProperties = read(); // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n};\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position$1 - 4);\n\tlet refEntry = referenceMap.get(id);\n\trefEntry.used = true;\n\treturn refEntry.target\n};\n\ncurrentExtensions[0x73] = () => new Set(read());\n\nconst typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array');\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0];\n\tlet typedArrayName = typedArrays[typeCode];\n\tif (!typedArrayName) {\n\t\tif (typeCode === 16) {\n\t\t\tlet ab = new ArrayBuffer(data.length - 1);\n\t\t\tlet u8 = new Uint8Array(ab);\n\t\t\tu8.set(data.subarray(1));\n\t\t\treturn ab;\n\t\t}\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t}\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\treturn new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\n};\ncurrentExtensions[0x78] = () => {\n\tlet data = read();\n\treturn new RegExp(data[0], data[1])\n};\nconst TEMP_BUNDLE = [];\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];\n\tlet dataPosition = position$1;\n\tposition$1 += dataSize - data.length;\n\tbundledStrings$1 = TEMP_BUNDLE;\n\tbundledStrings$1 = [readOnlyJSString(), readOnlyJSString()];\n\tbundledStrings$1.position0 = 0;\n\tbundledStrings$1.position1 = 0;\n\tbundledStrings$1.postBundlePosition = position$1;\n\tposition$1 = dataPosition;\n\treturn read()\n};\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)// TODO: Implement support for negative\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n}; // notepack defines extension 0 to mean undefined, so use that as the default here\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState$1(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd;\n\tlet savedPosition = position$1;\n\tlet savedStringPosition = stringPosition;\n\tlet savedSrcStringStart = srcStringStart;\n\tlet savedSrcStringEnd = srcStringEnd;\n\tlet savedSrcString = srcString;\n\tlet savedStrings = strings;\n\tlet savedReferenceMap = referenceMap;\n\tlet savedBundledStrings = bundledStrings$1;\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures;\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length);\n\tlet savedPackr = currentUnpackr;\n\tlet savedSequentialMode = sequentialMode;\n\tlet value = callback();\n\tsrcEnd = savedSrcEnd;\n\tposition$1 = savedPosition;\n\tstringPosition = savedStringPosition;\n\tsrcStringStart = savedSrcStringStart;\n\tsrcStringEnd = savedSrcStringEnd;\n\tsrcString = savedSrcString;\n\tstrings = savedStrings;\n\treferenceMap = savedReferenceMap;\n\tbundledStrings$1 = savedBundledStrings;\n\tsrc = savedSrc;\n\tsequentialMode = savedSequentialMode;\n\tcurrentStructures = savedStructures;\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents);\n\tcurrentUnpackr = savedPackr;\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength);\n\treturn value\n}\nfunction clearSource() {\n\tsrc = null;\n\treferenceMap = null;\n\tcurrentStructures = null;\n}\n\nfunction addExtension$1(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack;\n\telse\n\t\tcurrentExtensions[extension.type] = extension;\n}\n\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103));\n}\nconst Decoder = Unpackr;\nvar defaultUnpackr = new Unpackr({ useRecords: false });\nconst unpack = defaultUnpackr.unpack;\nconst unpackMultiple = defaultUnpackr.unpackMultiple;\nconst decode = defaultUnpackr.unpack;\nconst FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n};\nlet f32Array = new Float32Array(1);\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4);\nfunction roundFloat32(float32Number) {\n\tf32Array[0] = float32Number;\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)];\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nfunction setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct$1 = updatedReadStruct;\n\tonLoadedStructures$1 = loadedStructs;\n\tonSaveState = saveState;\n}\n\nlet textEncoder$1;\ntry {\n\ttextEncoder$1 = new TextEncoder();\n} catch (error) {}\nlet extensions, extensionClasses;\nconst hasNodeBuffer$1 = typeof Buffer !== 'undefined';\nconst ByteArrayAllocate = hasNodeBuffer$1 ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array;\nconst ByteArray = hasNodeBuffer$1 ? Buffer : Uint8Array;\nconst MAX_BUFFER_SIZE = hasNodeBuffer$1 ? 0x100000000 : 0x7fd00000;\nlet target, keysTarget;\nlet targetView;\nlet position = 0;\nlet safeEnd;\nlet bundledStrings = null;\nlet writeStructSlots;\nconst MAX_BUNDLE_SIZE = 0x5500; // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/;\nconst RECORD_SYMBOL = Symbol('record-id');\nclass Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options);\n\t\tthis.offset = 0;\n\t\tlet start;\n\t\tlet hasSharedUpdate;\n\t\tlet structures;\n\t\tlet referenceMap;\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, 0xffffffff)\n\t\t} : (textEncoder$1 && textEncoder$1.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder$1.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false;\n\n\t\tlet packr = this;\n\t\tif (!options)\n\t\t\toptions = {};\n\t\tlet isSequential = options && options.sequential;\n\t\tlet hasSharedStructures = options.structures || options.saveStructures;\n\t\tlet maxSharedStructures = options.maxSharedStructures;\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0;\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true;\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures;\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64;\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = [];\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64);\n\t\tlet sharedLimitId = maxSharedStructures + 0x40;\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40;\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = [];\n\t\tlet transitionsCount = 0;\n\t\tlet serializationsSinceTransitionRebuild = 0;\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192);\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192));\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10;\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end,\n\t\t\t\ttarget = new ByteArrayAllocate(target.length);\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length));\n\t\t\t\tsafeEnd = target.length - 10;\n\t\t\t\tposition = 0;\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8; // Word align to make any future copying of this buffer faster\n\t\t\tstart = position;\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff);\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null;\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = [];\n\t\t\t\tbundledStrings.size = Infinity; // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null;\n\t\t\tstructures = packr.structures;\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures());\n\t\t\t\tlet sharedLength = structures.sharedLength || 0;\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null);\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i];\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions;\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j];\n\t\t\t\t\t\t\tnextTransition = transition[key];\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40;\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength;\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false;\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value);\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0);\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition);\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition);\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position);\n\t\t\t\t\tpackr.offset = position;\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert);\n\t\t\t\t\treferenceMap = null;\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position; // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start;\n\t\t\t\t\ttarget.end = position;\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0;\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position);\n\t\t\t\t\t\tlet newSharedData = prepareStructures$1(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength;\n\t\t\t\t\t\t\t// don't keep large buffers around\n\t\t\t\t\t\t\tif (target.length > 0x40000000) target = null;\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n\t\t\t\tif (target.length > 0x40000000) target = null;\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start;\n\t\t\t}\n\t\t};\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++;\n\t\t\tlet sharedLength = structures.sharedLength || 0;\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength;\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null;\n\t\t\t\tserializationsSinceTransitionRebuild = 0;\n\t\t\t\ttransitionsCount = 0;\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = [];\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0;\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = [];\n\t\t\t}\n\t\t};\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length;\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length;\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc;\n\t\t\t\ttarget[position++] = length >> 8;\n\t\t\t\ttarget[position++] = length & 0xff;\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd;\n\t\t\t\ttargetView.setUint32(position, length);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i]);\n\t\t\t}\n\t\t};\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position);\n\n\t\t\tvar type = typeof value;\n\t\t\tvar length;\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length;\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart;\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes);\n\t\t\t\t\t\tlet lastBundle;\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings;\n\t\t\t\t\t\t\ttarget[position] = 0xc8; // ext 16\n\t\t\t\t\t\t\tposition += 3; // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62; // 'b'\n\t\t\t\t\t\t\textStart = position - start;\n\t\t\t\t\t\t\tposition += 4; // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0); // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart);\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6; // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62; // 'b'\n\t\t\t\t\t\t\textStart = position - start;\n\t\t\t\t\t\t\tposition += 4; // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', '']; // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0;\n\t\t\t\t\t\tbundledStrings.position = extStart;\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value);\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value;\n\t\t\t\t\ttarget[position++] = 0xc1;\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize;\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1;\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2;\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3;\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5;\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3;\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes);\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize;\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i);\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1;\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize;\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize);\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length;\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length);\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9;\n\t\t\t\t\ttarget[position++] = length;\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length);\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda;\n\t\t\t\t\ttarget[position++] = length >> 8;\n\t\t\t\t\ttarget[position++] = length & 0xff;\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length);\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb;\n\t\t\t\t\ttargetView.setUint32(position, length);\n\t\t\t\t\tposition += 4;\n\t\t\t\t}\n\t\t\t\tposition += length;\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value;\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc;\n\t\t\t\t\t\ttarget[position++] = value;\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd;\n\t\t\t\t\t\ttarget[position++] = value >> 8;\n\t\t\t\t\t\ttarget[position++] = value & 0xff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce;\n\t\t\t\t\t\ttargetView.setUint32(position, value);\n\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value;\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0;\n\t\t\t\t\t\ttarget[position++] = value + 0x100;\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1;\n\t\t\t\t\t\ttargetView.setInt16(position, value);\n\t\t\t\t\t\tposition += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2;\n\t\t\t\t\t\ttargetView.setInt32(position, value);\n\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32;\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca;\n\t\t\t\t\t\ttargetView.setFloat32(position, value);\n\t\t\t\t\t\tlet xShifted;\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition--; // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb;\n\t\t\t\t\ttargetView.setFloat64(position, value);\n\t\t\t\t\tposition += 8;\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0;\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value);\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = []);\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6; // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70; // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id);\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start });\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor;\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value);\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value);\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size;\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length;\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde;\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8;\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf;\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length);\n\t\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key);\n\t\t\t\t\t\t\t\tpack(entryValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i];\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i];\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4; // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type;\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value);\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target;\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView;\n\t\t\t\t\t\t\t\tlet currentPosition = position;\n\t\t\t\t\t\t\t\ttarget = null;\n\t\t\t\t\t\t\t\tlet result;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget;\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null;\n\t\t\t\t\t\t\t\t\t\tposition += size;\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position);\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack);\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget;\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView;\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition;\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position);\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON();\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\n\t\t\t\t\t\t\t// no extension found, write as plain object\n\t\t\t\t\t\t\twriteObject(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2;\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3;\n\t\t\t\t\ttargetView.setBigInt64(position, value);\n\t\t\t\t} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf;\n\t\t\t\t\ttargetView.setBigUint64(position, value);\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb;\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value));\n\t\t\t\t\t} else if (this.useBigIntExtension && value < 2n**(1023n) && value > -(2n**(1023n))) {\n\t\t\t\t\t\ttarget[position++] = 0xc7;\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t\ttarget[position++] = 0x42; // \"B\" for BigInt\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\tlet alignedSign;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tlet byte = value & 0xffn;\n\t\t\t\t\t\t\talignedSign = (byte & 0x80n) === (value < 0n ? 0x80n : 0n);\n\t\t\t\t\t\t\tbytes.push(byte);\n\t\t\t\t\t\t\tvalue >>= 8n;\n\t\t\t\t\t\t} while (!((value === 0n || value === -1n) && alignedSign));\n\t\t\t\t\t\ttarget[position-2] = bytes.length;\n\t\t\t\t\t\tfor (let i = bytes.length; i > 0;) {\n\t\t\t\t\t\t\ttarget[position++] = Number(bytes[--i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension or set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8;\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0;\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4; // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0;\n\t\t\t\t\ttarget[position++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t};\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys;\n\t\t\tif (this.skipValues) {\n\t\t\t\tkeys = [];\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tif ((typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) &&\n\t\t\t\t\t\t!this.skipValues.includes(object[key]))\n\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeys = Object.keys(object);\n\t\t\t}\n\t\t\tlet length = keys.length;\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length;\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde;\n\t\t\t\ttarget[position++] = length >> 8;\n\t\t\t\ttarget[position++] = length & 0xff;\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf;\n\t\t\t\ttargetView.setUint32(position, length);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t\tlet key;\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i];\n\t\t\t\t\tlet num = Number(key);\n\t\t\t\t\tpack(isNaN(num) ? key : num);\n\t\t\t\t\tpack(object[key]);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i]);\n\t\t\t\t\tpack(object[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xde; // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start;\n\t\t\tposition += 2;\n\t\t\tlet size = 0;\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key);\n\t\t\t\t\tpack(object[key]);\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8;\n\t\t\ttarget[objectOffset + start] = size & 0xff;\n\t\t};\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n\t\t\tlet objectOffset = position++ - start;\n\t\t\tlet wroteKeys;\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key];\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object);\n\t\t\t\t\t\tlet lastTransition = transition;\n\t\t\t\t\t\ttransition = structures.transitions;\n\t\t\t\t\t\tlet newTransitions = 0;\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i];\n\t\t\t\t\t\t\tnextTransition = transition[key];\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null);\n\t\t\t\t\t\t\t\tnewTransitions++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--;\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions);\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions);\n\t\t\t\t\t\twroteKeys = true;\n\t\t\t\t\t\ttransition = lastTransition[key];\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL];\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId;\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0);\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n\t\t\tlet newTransitions = 0;\n\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key];\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null);\n\t\t\t\t\tnewTransitions++;\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition;\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL];\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60;\n\t\t\t\t\ttarget[position++] = recordId >> 5;\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId;\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions);\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key]);\n\t\t\t\t}\n\t\t};\n\n\t\t// create reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\n\t\tconst writeObject = checkUseRecords ? (object) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object) : writePlainObject(object);\n\t\t} : writeRecord;\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize;\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000);\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12;\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize);\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));\n\t\t\tend = Math.min(end, target.length);\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end);\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end));\n\t\t\tposition -= start;\n\t\t\tstart = 0;\n\t\t\tsafeEnd = newBuffer.length - 10;\n\t\t\treturn target = newBuffer\n\t\t};\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId;\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40;\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId;\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId;\n\t\t\t\tstructures.nextOwnId = recordId + 1;\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId;\n\t\t\t\tstructures.nextId = recordId + 1;\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1;\n\t\t\ttransition[RECORD_SYMBOL] = recordId;\n\t\t\ttransition.__keys__ = keys;\n\t\t\tstructures[recordId - 0x40] = keys;\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true;\n\t\t\t\tstructures.sharedLength = recordId - 0x3f;\n\t\t\t\thasSharedUpdate = true;\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60;\n\t\t\t\t\ttarget[position++] = highByte;\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5; // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72; // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60;\n\t\t\t\t\ttarget[position++] = highByte;\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4; // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72; // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId;\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions;\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0; // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition);\n\t\t\t\tpack(keys);\n\t\t\t}\n\t\t};\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target;\n\t\t\tlet mainPosition = position;\n\t\t\tlet mainSafeEnd = safeEnd;\n\t\t\tlet mainStart = start;\n\t\t\ttarget = keysTarget;\n\t\t\tposition = 0;\n\t\t\tstart = 0;\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192);\n\t\t\tsafeEnd = target.length - 10;\n\t\t\tnewRecord(transition, keys, newTransitions);\n\t\t\tkeysTarget = target;\n\t\t\tlet keysPosition = position;\n\t\t\ttarget = mainTarget;\n\t\t\tposition = mainPosition;\n\t\t\tsafeEnd = mainSafeEnd;\n\t\t\tstart = mainStart;\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1;\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd);\n\t\t\t\tlet insertionPosition = insertionOffset + start;\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position);\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition);\n\t\t\t\tposition = newEnd;\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0];\n\t\t\t}\n\t\t};\n\t\tconst writeStruct = (object) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object);\n\t\t\tposition = newPosition;\n\t\t};\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer;\n\t\ttarget.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength));\n\t\tposition = 0;\n\t}\n\tset position (value) {\n\t\tposition = value;\n\t}\n\tget position() {\n\t\treturn position;\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = [];\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = [];\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ];\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000;\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6);\n\t\t\ttarget[position++] = 0xd6;\n\t\t\ttarget[position++] = 0xff;\n\t\t\ttargetView.setUint32(position, seconds);\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10);\n\t\t\ttarget[position++] = 0xd7;\n\t\t\ttarget[position++] = 0xff;\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0));\n\t\t\ttargetView.setUint32(position + 4, seconds);\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0);\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3);\n\t\t\ttarget[position++] = 0xd4;\n\t\t\ttarget[position++] = 0xff;\n\t\t\ttarget[position++] = 0xff;\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15);\n\t\t\ttarget[position++] = 0xc7;\n\t\t\ttarget[position++] = 12;\n\t\t\ttarget[position++] = 0xff;\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000);\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)));\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set);\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0);\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4;\n\t\t\ttarget[position++] = 0x73; // 's' for Set\n\t\t\ttarget[position++] = 0;\n\t\t}\n\t\tpack(array);\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0);\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4;\n\t\t\ttarget[position++] = 0x65; // 'e' for error\n\t\t\ttarget[position++] = 0;\n\t\t}\n\t\tpack([ error.name, error.message, error.cause ]);\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0);\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4;\n\t\t\ttarget[position++] = 0x78; // 'x' for regeXp\n\t\t\ttarget[position++] = 0;\n\t\t}\n\t\tpack([ regex.source, regex.flags ]);\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite);\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer$1 ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor;\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite);\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite);\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1);\n\t\ttarget[position] = 0xc1;\n\t}\n}];\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength;\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length);\n\t\ttarget[position++] = 0xc7;\n\t\ttarget[position++] = length + 1;\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length);\n\t\ttarget[position++] = 0xc8;\n\t\ttarget[position++] = (length + 1) >> 8;\n\t\ttarget[position++] = (length + 1) & 0xff;\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length);\n\t\ttarget[position++] = 0xc9;\n\t\ttargetView.setUint32(position, length + 1); // plus one for the type byte\n\t\tposition += 4;\n\t}\n\ttarget[position++] = 0x74; // \"t\" for typed array\n\ttarget[position++] = type;\n\tif (!typedArray.buffer) typedArray = new Uint8Array(typedArray);\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position);\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength;\n\tvar target, position;\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2);\n\t\ttarget[position++] = 0xc4;\n\t\ttarget[position++] = length;\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3);\n\t\ttarget[position++] = 0xc5;\n\t\ttarget[position++] = length >> 8;\n\t\ttarget[position++] = length & 0xff;\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5);\n\t\ttarget[position++] = 0xc6;\n\t\ttargetView.setUint32(position, length);\n\t\tposition += 4;\n\t}\n\ttarget.set(buffer, position);\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length;\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4;\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5;\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6;\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7;\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8;\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7;\n\t\t\t\ttarget[position++] = length;\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8;\n\t\t\t\ttarget[position++] = length >> 8;\n\t\t\t\ttarget[position++] = length & 0xff;\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9;\n\t\t\t\ttarget[position++] = length >> 24;\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff;\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff;\n\t\t\t\ttarget[position++] = length & 0xff;\n\t\t\t}\n\t}\n\ttarget[position++] = type;\n\ttarget.set(result, position);\n\tposition += length;\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId;\n\tlet distanceToMove = idsToInsert.length * 6;\n\tlet lastEnd = serialized.length - distanceToMove;\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset;\n\t\tlet id = nextId.id;\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd);\n\t\tdistanceToMove -= 6;\n\t\tlet position = offset + distanceToMove;\n\t\tserialized[position++] = 0xd6;\n\t\tserialized[position++] = 0x69; // 'i'\n\t\tserialized[position++] = id >> 24;\n\t\tserialized[position++] = (id >> 16) & 0xff;\n\t\tserialized[position++] = (id >> 8) & 0xff;\n\t\tserialized[position++] = id & 0xff;\n\t\tlastEnd = offset;\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start);\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings;\n\t\tbundledStrings = null;\n\t\tpack(writeStrings[0]);\n\t\tpack(writeStrings[1]);\n\t}\n}\n\nfunction addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class);\n\t\textensions.unshift(extension);\n\t}\n\taddExtension$1(extension);\n}\nfunction prepareStructures$1(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length);\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t};\n\treturn structures\n}\nfunction setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures$1 = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false });\nconst pack = defaultPackr.pack;\nconst encode = defaultPackr.pack;\nconst Encoder = Packr;\nconst { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;\nconst REUSE_BUFFER_MODE = 512;\nconst RESET_BUFFER_MODE = 1024;\nconst RESERVE_START_SPACE = 2048;\n\nconst ASCII = 3; // the MIBenum from https://www.iana.org/assignments/character-sets/character-sets.xhtml (and other character encodings could be referenced by MIBenum)\nconst NUMBER = 0;\nconst UTF8 = 2;\nconst OBJECT_DATA = 1;\nconst DATE = 16;\nconst TYPE_NAMES = ['num', 'object', 'string', 'ascii'];\nTYPE_NAMES[DATE] = 'date';\nconst float32Headers = [false, true, true, false, false, true, true, false];\nlet evalSupported;\ntry {\n\tnew Function('');\n\tevalSupported = true;\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n}\n\nlet updatedPosition;\nconst hasNodeBuffer = typeof Buffer !== 'undefined';\nlet textEncoder, currentSource;\ntry {\n\ttextEncoder = new TextEncoder();\n} catch (error) {}\nconst encodeUtf8 = hasNodeBuffer ? function(target, string, position) {\n\treturn target.utf8Write(string, position, 0xffffffff)\n} : (textEncoder && textEncoder.encodeInto) ?\n\tfunction(target, string, position) {\n\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t} : false;\nsetWriteStructSlots(writeStruct, prepareStructures);\nfunction writeStruct(object, target, encodingStart, position, structures, makeRoom, pack, packr) {\n\tlet typedStructs = packr.typedStructs || (packr.typedStructs = []);\n\t// note that we rely on pack.js to load stored structures before we get to this point\n\tlet targetView = target.dataView;\n\tlet refsStartPosition = (typedStructs.lastStringStart || 100) + position;\n\tlet safeEnd = target.length - 10;\n\tlet start = position;\n\tif (position > safeEnd) {\n\t\ttarget = makeRoom(position);\n\t\ttargetView = target.dataView;\n\t\tposition -= encodingStart;\n\t\tstart -= encodingStart;\n\t\trefsStartPosition -= encodingStart;\n\t\tencodingStart = 0;\n\t\tsafeEnd = target.length - 10;\n\t}\n\n\tlet refOffset, refPosition = refsStartPosition;\n\n\tlet transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));\n\tlet nextId = typedStructs.nextId || typedStructs.length;\n\tlet headerSize =\n\t\tnextId < 0xf ? 1 :\n\t\t\tnextId < 0xf0 ? 2 :\n\t\t\t\tnextId < 0xf000 ? 3 :\n\t\t\t\t\tnextId < 0xf00000 ? 4 : 0;\n\tif (headerSize === 0)\n\t\treturn 0;\n\tposition += headerSize;\n\tlet queuedReferences = [];\n\tlet usedAscii0;\n\tlet keyIndex = 0;\n\tfor (let key in object) {\n\t\tlet value = object[key];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: 0,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null,\n\t\t\t\tdate64: null\n\t\t\t};\n\t\t}\n\t\tif (position > safeEnd) {\n\t\t\ttarget = makeRoom(position);\n\t\t\ttargetView = target.dataView;\n\t\t\tposition -= encodingStart;\n\t\t\tstart -= encodingStart;\n\t\t\trefsStartPosition -= encodingStart;\n\t\t\trefPosition -= encodingStart;\n\t\t\tencodingStart = 0;\n\t\t\tsafeEnd = target.length - 10;\n\t\t}\n\t\tswitch (typeof value) {\n\t\t\tcase 'number':\n\t\t\t\tlet number = value;\n\t\t\t\t// first check to see if we are using a lot of ids and should default to wide/common format\n\t\t\t\tif (nextId < 200 || !nextTransition.num64) {\n\t\t\t\t\tif (number >> 0 === number && number < 0x20000000 && number > -0x1f000000) {\n\t\t\t\t\t\tif (number < 0xf6 && number >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number < 0x20 && !nextTransition.num32)) {\n\t\t\t\t\t\t\ttransition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\t\t\t\ttarget[position++] = number;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\ttargetView.setUint32(position, number, true);\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (number < 0x100000000 && number >= -0x80000000) {\n\t\t\t\t\t\ttargetView.setFloat32(position, number, true);\n\t\t\t\t\t\tif (float32Headers[target[position + 3] >>> 5]) {\n\t\t\t\t\t\t\tlet xShifted;\n\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\tif (((xShifted = number * mult10[((target[position + 3] & 0x7f) << 1) | (target[position + 2] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);\n\t\t\t\ttargetView.setFloat64(position, number, true);\n\t\t\t\tposition += 8;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tlet strLength = value.length;\n\t\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\t\tif ((strLength << 2) + refPosition > safeEnd) {\n\t\t\t\t\ttarget = makeRoom((strLength << 2) + refPosition);\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tposition -= encodingStart;\n\t\t\t\t\tstart -= encodingStart;\n\t\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\t\trefPosition -= encodingStart;\n\t\t\t\t\tencodingStart = 0;\n\t\t\t\t\tsafeEnd = target.length - 10;\n\t\t\t\t}\n\t\t\t\tif (strLength > ((0xff00 + refOffset) >> 2)) {\n\t\t\t\t\tqueuedReferences.push(key, value, position - start);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet isNotAscii;\n\t\t\t\tlet strStart = refPosition;\n\t\t\t\tif (strLength < 0x40) {\n\t\t\t\t\tlet i, c1, c2;\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i);\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[refPosition++] = c1;\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 | 0xc0;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 18 | 0xf0;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 & 0x3f | 0x80;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 | 0xe0;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trefPosition += encodeUtf8(target, value, refPosition);\n\t\t\t\t\tisNotAscii = refPosition - strStart > strLength;\n\t\t\t\t}\n\t\t\t\tif (refOffset < 0xa0 || (refOffset < 0xf6 && (nextTransition.ascii8 || nextTransition.string8))) {\n\t\t\t\t\t// short strings\n\t\t\t\t\tif (isNotAscii) {\n\t\t\t\t\t\tif (!(transition = nextTransition.string8)) {\n\t\t\t\t\t\t\tif (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {\n\t\t\t\t\t\t\t\t// we can safely change ascii to utf8 in place since they are compatible\n\t\t\t\t\t\t\t\ttransition.__type = UTF8;\n\t\t\t\t\t\t\t\tnextTransition.ascii8 = null;\n\t\t\t\t\t\t\t\tnextTransition.string8 = transition;\n\t\t\t\t\t\t\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, UTF8, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (refOffset === 0 && !usedAscii0) {\n\t\t\t\t\t\tusedAscii0 = true;\n\t\t\t\t\t\ttransition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);\n\t\t\t\t\t\tbreak; // don't increment position\n\t\t\t\t\t}// else ascii:\n\t\t\t\t\telse if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8)))\n\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, ASCII, 1);\n\t\t\t\t\ttarget[position++] = refOffset;\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Enable ascii16 at some point, but get the logic right\n\t\t\t\t\t//if (isNotAscii)\n\t\t\t\t\t\ttransition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);\n\t\t\t\t\t//else\n\t\t\t\t\t\t//transition = nextTransition.ascii16 || createTypeTransition(nextTransition, ASCII, 2);\n\t\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\t\tposition += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (value) {\n\t\t\t\t\tif (value.constructor === Date) {\n\t\t\t\t\t\ttransition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);\n\t\t\t\t\t\ttargetView.setFloat64(position, value.getTime(), true);\n\t\t\t\t\t\tposition += 8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else { // null\n\t\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -10); // match CBOR with this\n\t\t\t\t\tif (nextTransition) {\n\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\t\ttransition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\ttarget[position++] = value ? 0xf9 : 0xf8; // match CBOR with these\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -9); // match CBOR with this\n\t\t\t\tif (nextTransition) {\n\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\tfor (let i = 0, l = queuedReferences.length; i < l;) {\n\t\tlet key = queuedReferences[i++];\n\t\tlet value = queuedReferences[i++];\n\t\tlet propertyIndex = queuedReferences[i++];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: propertyIndex - keyIndex,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null\n\t\t\t};\n\t\t}\n\t\tlet newPosition;\n\t\tif (value) {\n\t\t\t/*if (typeof value === 'string') { // TODO: we could re-enable long strings\n\t\t\t\tif (position + value.length * 3 > safeEnd) {\n\t\t\t\t\ttarget = makeRoom(position + value.length * 3);\n\t\t\t\t\tposition -= start;\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\tnewPosition = position + target.utf8Write(value, position, 0xffffffff);\n\t\t\t} else { */\n\t\t\tlet size;\n\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\tif (refOffset < 0xff00) {\n\t\t\t\ttransition = nextTransition.object16;\n\t\t\t\tif (transition)\n\t\t\t\t\tsize = 2;\n\t\t\t\telse if ((transition = nextTransition.object32))\n\t\t\t\t\tsize = 4;\n\t\t\t\telse {\n\t\t\t\t\ttransition = createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\t\t\tsize = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttransition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);\n\t\t\t\tsize = 4;\n\t\t\t}\n\t\t\tnewPosition = pack(value, refPosition);\n\t\t\t//}\n\t\t\tif (typeof newPosition === 'object') {\n\t\t\t\t// re-allocated\n\t\t\t\trefPosition = newPosition.position;\n\t\t\t\ttargetView = newPosition.targetView;\n\t\t\t\ttarget = newPosition.target;\n\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\tposition -= encodingStart;\n\t\t\t\tstart -= encodingStart;\n\t\t\t\tencodingStart = 0;\n\t\t\t} else\n\t\t\t\trefPosition = newPosition;\n\t\t\tif (size === 2) {\n\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\tposition += 2;\n\t\t\t} else {\n\t\t\t\ttargetView.setUint32(position, refOffset, true);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t} else { // null or undefined\n\t\t\ttransition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\ttargetView.setInt16(position, value === null ? -10 : -9, true);\n\t\t\tposition += 2;\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\n\tlet recordId = transition[RECORD_SYMBOL];\n\tif (recordId == null) {\n\t\trecordId = packr.typedStructs.length;\n\t\tlet structure = [];\n\t\tlet nextTransition = transition;\n\t\tlet key, type;\n\t\twhile ((type = nextTransition.__type) !== undefined) {\n\t\t\tlet size = nextTransition.__size;\n\t\t\tnextTransition = nextTransition.__parent;\n\t\t\tkey = nextTransition.key;\n\t\t\tlet property = [type, size, key];\n\t\t\tif (nextTransition.enumerationOffset)\n\t\t\t\tproperty.push(nextTransition.enumerationOffset);\n\t\t\tstructure.push(property);\n\t\t\tnextTransition = nextTransition.parent;\n\t\t}\n\t\tstructure.reverse();\n\t\ttransition[RECORD_SYMBOL] = recordId;\n\t\tpackr.typedStructs[recordId] = structure;\n\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t}\n\n\n\tswitch (headerSize) {\n\t\tcase 1:\n\t\t\tif (recordId >= 0x10) return 0;\n\t\t\ttarget[start] = recordId + 0x20;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (recordId >= 0x100) return 0;\n\t\t\ttarget[start] = 0x38;\n\t\t\ttarget[start + 1] = recordId;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (recordId >= 0x10000) return 0;\n\t\t\ttarget[start] = 0x39;\n\t\t\ttargetView.setUint16(start + 1, recordId, true);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (recordId >= 0x1000000) return 0;\n\t\t\ttargetView.setUint32(start, (recordId << 8) + 0x3a, true);\n\t\t\tbreak;\n\t}\n\n\tif (position < refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\t// adjust positioning\n\t\ttarget.copyWithin(position, refsStartPosition, refPosition);\n\t\trefPosition += position - refsStartPosition;\n\t\ttypedStructs.lastStringStart = position - start;\n\t} else if (position > refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\ttypedStructs.lastStringStart = position - start;\n\t\treturn writeStruct(object, target, encodingStart, start, structures, makeRoom, pack, packr);\n\t}\n\treturn refPosition;\n}\nfunction anyType(transition, position, targetView, value) {\n\tlet nextTransition;\n\tif ((nextTransition = transition.ascii8 || transition.num8)) {\n\t\ttargetView.setInt8(position, value, true);\n\t\tupdatedPosition = position + 1;\n\t\treturn nextTransition;\n\t}\n\tif ((nextTransition = transition.string16 || transition.object16)) {\n\t\ttargetView.setInt16(position, value, true);\n\t\tupdatedPosition = position + 2;\n\t\treturn nextTransition;\n\t}\n\tif (nextTransition = transition.num32) {\n\t\ttargetView.setUint32(position, 0xe0000100 + value, true);\n\t\tupdatedPosition = position + 4;\n\t\treturn nextTransition;\n\t}\n\t// transition.float64\n\tif (nextTransition = transition.num64) {\n\t\ttargetView.setFloat64(position, NaN, true);\n\t\ttargetView.setInt8(position, value);\n\t\tupdatedPosition = position + 8;\n\t\treturn nextTransition;\n\t}\n\tupdatedPosition = position;\n\t// TODO: can we do an \"any\" type where we defer the decision?\n\treturn;\n}\nfunction createTypeTransition(transition, type, size) {\n\tlet typeName = TYPE_NAMES[type] + (size << 3);\n\tlet newTransition = transition[typeName] || (transition[typeName] = Object.create(null));\n\tnewTransition.__type = type;\n\tnewTransition.__size = size;\n\tnewTransition.__parent = transition;\n\treturn newTransition;\n}\nfunction onLoadedStructures(sharedData) {\n\tif (!(sharedData instanceof Map))\n\t\treturn sharedData;\n\tlet typed = sharedData.get('typed') || [];\n\tif (Object.isFrozen(typed))\n\t\ttyped = typed.map(structure => structure.slice(0));\n\tlet named = sharedData.get('named');\n\tlet transitions = Object.create(null);\n\tfor (let i = 0, l = typed.length; i < l; i++) {\n\t\tlet structure = typed[i];\n\t\tlet transition = transitions;\n\t\tfor (let [type, size, key] of structure) {\n\t\t\tlet nextTransition = transition[key];\n\t\t\tif (!nextTransition) {\n\t\t\t\ttransition[key] = nextTransition = {\n\t\t\t\t\tkey,\n\t\t\t\t\tparent: transition,\n\t\t\t\t\tenumerationOffset: 0,\n\t\t\t\t\tascii0: null,\n\t\t\t\t\tascii8: null,\n\t\t\t\t\tnum8: null,\n\t\t\t\t\tstring16: null,\n\t\t\t\t\tobject16: null,\n\t\t\t\t\tnum32: null,\n\t\t\t\t\tfloat64: null,\n\t\t\t\t\tdate64: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\ttransition = createTypeTransition(nextTransition, type, size);\n\t\t}\n\t\ttransition[RECORD_SYMBOL] = i;\n\t}\n\ttyped.transitions = transitions;\n\tthis.typedStructs = typed;\n\tthis.lastTypedStructuresLength = typed.length;\n\treturn named;\n}\nvar sourceSymbol = Symbol.for('source');\nfunction readStruct(src, position, srcEnd, unpackr) {\n\tlet recordId = src[position++] - 0x20;\n\tif (recordId >= 24) {\n\t\tswitch(recordId) {\n\t\t\tcase 24: recordId = src[position++]; break;\n\t\t\t// little endian:\n\t\t\tcase 25: recordId = src[position++] + (src[position++] << 8); break;\n\t\t\tcase 26: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16); break;\n\t\t\tcase 27: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16) + (src[position++] << 24); break;\n\t\t}\n\t}\n\tlet structure = unpackr.typedStructs && unpackr.typedStructs[recordId];\n\tif (!structure) {\n\t\t// copy src buffer because getStructures will override it\n\t\tsrc = Uint8Array.prototype.slice.call(src, position, srcEnd);\n\t\tsrcEnd -= position;\n\t\tposition = 0;\n\t\tif (!unpackr.getStructures)\n\t\t\tthrow new Error(`Reference to shared structure ${recordId} without getStructures method`);\n\t\tunpackr._mergeStructures(unpackr.getStructures());\n\t\tif (!unpackr.typedStructs)\n\t\t\tthrow new Error('Could not find any shared typed structures');\n\t\tunpackr.lastTypedStructuresLength = unpackr.typedStructs.length;\n\t\tstructure = unpackr.typedStructs[recordId];\n\t\tif (!structure)\n\t\t\tthrow new Error('Could not find typed structure ' + recordId);\n\t}\n\tvar construct = structure.construct;\n\tif (!construct) {\n\t\tconstruct = structure.construct = function LazyObject() {\n\t\t};\n\t\tvar prototype = construct.prototype;\n\t\tlet properties = [];\n\t\tlet currentOffset = 0;\n\t\tlet lastRefProperty;\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet definition = structure[i];\n\t\t\tlet [ type, size, key, enumerationOffset ] = definition;\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tlet property = {\n\t\t\t\tkey,\n\t\t\t\toffset: currentOffset,\n\t\t\t};\n\t\t\tif (enumerationOffset)\n\t\t\t\tproperties.splice(i + enumerationOffset, 0, property);\n\t\t\telse\n\t\t\t\tproperties.push(property);\n\t\t\tlet getRef;\n\t\t\tswitch(size) { // TODO: Move into a separate function\n\t\t\t\tcase 0: getRef = () => 0; break;\n\t\t\t\tcase 1:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet ref = source.bytes[position + property.offset];\n\t\t\t\t\t\treturn ref >= 0xf6 ? toConstant(ref) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint16(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint32(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xffffff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tproperty.getRef = getRef;\n\t\t\tcurrentOffset += size;\n\t\t\tlet get;\n\t\t\tswitch(type) {\n\t\t\t\tcase ASCII:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tproperty.multiGetCount = 0;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (source.srcString) {\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*if (property.multiGetCount > 0) {\n\t\t\t\t\t\t\tlet asciiEnd;\n\t\t\t\t\t\t\tnext = firstRefProperty;\n\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tasciiEnd = dataView.getUint16(source.position + next.offset, true);\n\t\t\t\t\t\t\t\tif (asciiEnd < 0xff00)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tasciiEnd = null;\n\t\t\t\t\t\t\t} while((next = next.next));\n\t\t\t\t\t\t\tif (asciiEnd == null)\n\t\t\t\t\t\t\t\tasciiEnd = source.bytesEnd - refStart\n\t\t\t\t\t\t\tsource.srcString = src.toString('latin1', refStart, refStart + asciiEnd);\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (source.prevStringGet) {\n\t\t\t\t\t\t\tsource.prevStringGet.multiGetCount += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.prevStringGet = property;\n\t\t\t\t\t\t\tproperty.multiGetCount--;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\treturn readString(src, ref + refStart, end - ref);\n\t\t\t\t\t\t//return src.toString('latin1', ref + refStart, end + refStart);\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase UTF8: case OBJECT_DATA:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (type === UTF8) {\n\t\t\t\t\t\t\treturn src.toString('utf8', ref + refStart, end + refStart);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentSource = source;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn unpackr.unpack(src, { start: ref + refStart, end: end + refStart });\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tcurrentSource = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase NUMBER:\n\t\t\t\t\tswitch(size) {\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet position = source.position + property.offset;\n\t\t\t\t\t\t\t\tlet value = dataView.getInt32(position, true);\n\t\t\t\t\t\t\t\tif (value < 0x20000000) {\n\t\t\t\t\t\t\t\t\tif (value > -0x1f000000)\n\t\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t\tif (value > -0x20000000)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(value & 0xff);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet fValue = dataView.getFloat32(position, true);\n\t\t\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\tlet multiplier = mult10[((src[position + 3] & 0x7f) << 1) | (src[position + 2] >> 7)];\n\t\t\t\t\t\t\t\treturn ((multiplier * fValue + (fValue > 0 ? 0.5 : -0.5)) >> 0) / multiplier;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet value = dataView.getFloat64(source.position + property.offset, true);\n\t\t\t\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\t\t\t\tlet byte = src[source.position + property.offset];\n\t\t\t\t\t\t\t\t\tif (byte >= 0xf6)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(byte);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet value = src[source.position + property.offset];\n\t\t\t\t\t\t\t\treturn value < 0xf6 ? value : toConstant(value);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DATE:\n\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\treturn new Date(dataView.getFloat64(source.position + property.offset, true));\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tproperty.get = get;\n\t\t}\n\t\t// TODO: load the srcString for faster string decoding on toJSON\n\t\tif (evalSupported) {\n\t\t\tlet objectLiteralProperties = [];\n\t\t\tlet args = [];\n\t\t\tlet i = 0;\n\t\t\tlet hasInheritedProperties;\n\t\t\tfor (let property of properties) { // assign in enumeration order\n\t\t\t\tif (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {\n\t\t\t\t\t// these properties are not eagerly evaluated and this can be used for creating properties\n\t\t\t\t\t// that are not serialized as JSON\n\t\t\t\t\thasInheritedProperties = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tObject.defineProperty(prototype, property.key, { get: withSource(property.get), enumerable: true });\n\t\t\t\tlet valueFunction = 'v' + i++;\n\t\t\t\targs.push(valueFunction);\n\t\t\t\tobjectLiteralProperties.push('[' + JSON.stringify(property.key) + ']:' + valueFunction + '(s)');\n\t\t\t}\n\t\t\tif (hasInheritedProperties) {\n\t\t\t\tobjectLiteralProperties.push('__proto__:this');\n\t\t\t}\n\t\t\tlet toObject = (new Function(...args, 'return function(s){return{' + objectLiteralProperties.join(',') + '}}')).apply(null, properties.map(prop => prop.get));\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\treturn toObject.call(this, this[sourceSymbol]);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\t// return an enumerable object with own properties to JSON stringify\n\t\t\t\t\tlet resolved = {};\n\t\t\t\t\tfor (let i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t// TODO: check alwaysLazyProperty\n\t\t\t\t\t\tlet key = properties[i].key;\n\n\t\t\t\t\t\tresolved[key] = this[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t},\n\t\t\t\t// not enumerable or anything\n\t\t\t});\n\t\t}\n\t}\n\tvar instance = new construct();\n\tinstance[sourceSymbol] = {\n\t\tbytes: src,\n\t\tposition,\n\t\tsrcString: '',\n\t\tbytesEnd: srcEnd\n\t};\n\treturn instance;\n}\nfunction toConstant(code) {\n\tswitch(code) {\n\t\tcase 0xf6: return null;\n\t\tcase 0xf7: return undefined;\n\t\tcase 0xf8: return false;\n\t\tcase 0xf9: return true;\n\t}\n\tthrow new Error('Unknown constant');\n}\nfunction withSource(get) {\n\treturn function() {\n\t\treturn get(this[sourceSymbol]);\n\t}\n}\n\nfunction saveState() {\n\tif (currentSource) {\n\t\tcurrentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);\n\t\tcurrentSource.position = 0;\n\t\tcurrentSource.bytesEnd = currentSource.bytes.length;\n\t}\n}\nfunction prepareStructures(structures, packr) {\n\tif (packr.typedStructs) {\n\t\tlet structMap = new Map();\n\t\tstructMap.set('named', structures);\n\t\tstructMap.set('typed', packr.typedStructs);\n\t\tstructures = structMap;\n\t}\n\tlet lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;\n\tstructures.isCompatible = existing => {\n\t\tlet compatible = true;\n\t\tif (existing instanceof Map) {\n\t\t\tlet named = existing.get('named') || [];\n\t\t\tif (named.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t\tlet typed = existing.get('typed') || [];\n\t\t\tif (typed.length !== lastTypedStructuresLength)\n\t\t\t\tcompatible = false;\n\t\t} else if (existing instanceof Array || Array.isArray(existing)) {\n\t\t\tif (existing.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t}\n\t\tif (!compatible)\n\t\t\tpackr._mergeStructures(existing);\n\t\treturn compatible;\n\t};\n\tpackr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;\n\treturn structures;\n}\n\nsetReadStruct(readStruct, onLoadedStructures, saveState);\n\nclass PackrStream extends stream.Transform {\n\tconstructor(options) {\n\t\tif (!options)\n\t\t\toptions = {};\n\t\toptions.writableObjectMode = true;\n\t\tsuper(options);\n\t\toptions.sequential = true;\n\t\tthis.packr = options.packr || new Packr(options);\n\t}\n\t_transform(value, encoding, callback) {\n\t\tthis.push(this.packr.pack(value));\n\t\tcallback();\n\t}\n}\n\nclass UnpackrStream extends stream.Transform {\n\tconstructor(options) {\n\t\tif (!options)\n\t\t\toptions = {};\n\t\toptions.objectMode = true;\n\t\tsuper(options);\n\t\toptions.structures = [];\n\t\tthis.unpackr = options.unpackr || new Unpackr(options);\n\t}\n\t_transform(chunk, encoding, callback) {\n\t\tif (this.incompleteBuffer) {\n\t\t\tchunk = Buffer.concat([this.incompleteBuffer, chunk]);\n\t\t\tthis.incompleteBuffer = null;\n\t\t}\n\t\tlet values;\n\t\ttry {\n\t\t\tvalues = this.unpackr.unpackMultiple(chunk);\n\t\t} catch(error) {\n\t\t\tif (error.incomplete) {\n\t\t\t\tthis.incompleteBuffer = chunk.slice(error.lastPosition);\n\t\t\t\tvalues = error.values;\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow error\n\t\t} finally {\n\t\t\tfor (let value of values || []) {\n\t\t\t\tif (value === null)\n\t\t\t\t\tvalue = this.getNullValue();\n\t\t\t\tthis.push(value);\n\t\t\t}\n\t\t}\n\t\tif (callback) callback();\n\t}\n\tgetNullValue() {\n\t\treturn Symbol.for(null)\n\t}\n}\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - msgpackr pack options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nfunction packIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return packIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return packIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * packIterSync (objectIterator, options) {\n  const packr = new Packr(options);\n  for (const value of objectIterator) {\n    yield packr.pack(value);\n  }\n}\n\nasync function * packIterAsync (objectIterator, options) {\n  const packr = new Packr(options);\n  for await (const value of objectIterator) {\n    yield packr.pack(value);\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - unpackr options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nfunction unpackIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const unpackr = new Unpackr(options);\n  let incomplete;\n  const parser = (chunk) => {\n    let yields;\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk]);\n      incomplete = undefined;\n    }\n\n    try {\n      yields = unpackr.unpackMultiple(chunk);\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition);\n        yields = err.values;\n      } else {\n        throw err\n      }\n    }\n    return yields\n  };\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value);\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value);\n      }\n    })()\n  }\n}\nconst decodeIter = unpackIter;\nconst encodeIter = packIter;\n\nconst useRecords = false;\nconst mapsAsObjects = true;\n\nconst nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === 'true';\n\nif (!nativeAccelerationDisabled) {\n\tlet extractor;\n\ttry {\n\t\tif (true)\n\t\t\textractor = __webpack_require__(/*! msgpackr-extract */ \"(action-browser)/../../node_modules/msgpackr-extract/index.js\");\n\t\telse\n\t\t\t{}\n\t\tif (extractor)\n\t\t\tsetExtractor(extractor.extractStrings);\n\t} catch (error) {\n\t\t// native module is optional\n\t}\n}\n\nexports.ALWAYS = ALWAYS;\nexports.C1 = C1;\nexports.DECIMAL_FIT = DECIMAL_FIT;\nexports.DECIMAL_ROUND = DECIMAL_ROUND;\nexports.Decoder = Decoder;\nexports.DecoderStream = UnpackrStream;\nexports.Encoder = Encoder;\nexports.EncoderStream = PackrStream;\nexports.FLOAT32_OPTIONS = FLOAT32_OPTIONS;\nexports.NEVER = NEVER;\nexports.Packr = Packr;\nexports.PackrStream = PackrStream;\nexports.Unpackr = Unpackr;\nexports.UnpackrStream = UnpackrStream;\nexports.addExtension = addExtension;\nexports.clearSource = clearSource;\nexports.decode = decode;\nexports.decodeIter = decodeIter;\nexports.encode = encode;\nexports.encodeIter = encodeIter;\nexports.mapsAsObjects = mapsAsObjects;\nexports.pack = pack;\nexports.roundFloat32 = roundFloat32;\nexports.unpack = unpack;\nexports.unpackMultiple = unpackMultiple;\nexports.useRecords = useRecords;\n//# sourceMappingURL=node.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvbXNncGFja3IvZGlzdC9ub2RlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLHNCQUFROztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtRkFBbUYsTUFBTTtBQUN6RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxRQUFRO0FBQ1IscUJBQXFCO0FBQ3JCO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLE9BQU87QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxnQ0FBZ0M7QUFDaEMsc0JBQXNCO0FBQ3RCLGtDQUFrQztBQUNsQztBQUNBLHNCQUFzQjtBQUN0QixxQ0FBcUM7QUFDckM7QUFDQSxRQUFRLE9BQU87QUFDZixrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQ0FBaUM7QUFDdkM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0wsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLE1BQU07QUFDTixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDO0FBQzlDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOEJBQThCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFNBQVMsOEJBQThCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhCQUE4QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxTQUFTLDhCQUE4QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCO0FBQzlCLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsK0JBQStCO0FBQ3ZDO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQTRDO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGFBQWE7QUFDYixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYiwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUE0QjtBQUNsQyxlQUFlLG1CQUFPLENBQUMsdUZBQWtCO0FBQ3pDO0FBQ0EsR0FBRyxFQUE0UDtBQUMvUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsVUFBVTtBQUNWLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsZUFBZTtBQUNmLHFCQUFxQjtBQUNyQixlQUFlO0FBQ2YscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2QixhQUFhO0FBQ2IsYUFBYTtBQUNiLG1CQUFtQjtBQUNuQixlQUFlO0FBQ2YscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsY0FBYztBQUNkLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQixZQUFZO0FBQ1osb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZCxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9tc2dwYWNrci9kaXN0L25vZGUuY2pzP2Y2ODYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgbW9kdWxlJDEgPSByZXF1aXJlKCdtb2R1bGUnKTtcblxudmFyIGRlY29kZXI7XG50cnkge1xuXHRkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG59IGNhdGNoKGVycm9yKSB7fVxudmFyIHNyYztcbnZhciBzcmNFbmQ7XG52YXIgcG9zaXRpb24kMSA9IDA7XG5jb25zdCBFTVBUWV9BUlJBWSA9IFtdO1xudmFyIHN0cmluZ3MgPSBFTVBUWV9BUlJBWTtcbnZhciBzdHJpbmdQb3NpdGlvbiA9IDA7XG52YXIgY3VycmVudFVucGFja3IgPSB7fTtcbnZhciBjdXJyZW50U3RydWN0dXJlcztcbnZhciBzcmNTdHJpbmc7XG52YXIgc3JjU3RyaW5nU3RhcnQgPSAwO1xudmFyIHNyY1N0cmluZ0VuZCA9IDA7XG52YXIgYnVuZGxlZFN0cmluZ3MkMTtcbnZhciByZWZlcmVuY2VNYXA7XG52YXIgY3VycmVudEV4dGVuc2lvbnMgPSBbXTtcbnZhciBkYXRhVmlldztcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblx0dXNlUmVjb3JkczogZmFsc2UsXG5cdG1hcHNBc09iamVjdHM6IHRydWVcbn07XG5jbGFzcyBDMVR5cGUge31cbmNvbnN0IEMxID0gbmV3IEMxVHlwZSgpO1xuQzEubmFtZSA9ICdNZXNzYWdlUGFjayAweEMxJztcbnZhciBzZXF1ZW50aWFsTW9kZSA9IGZhbHNlO1xudmFyIGlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQgPSAyO1xudmFyIHJlYWRTdHJ1Y3QkMSwgb25Mb2FkZWRTdHJ1Y3R1cmVzJDEsIG9uU2F2ZVN0YXRlO1xuLy8gbm8tZXZhbCBidWlsZFxudHJ5IHtcblx0bmV3IEZ1bmN0aW9uKCcnKTtcbn0gY2F0Y2goZXJyb3IpIHtcblx0Ly8gaWYgZXZhbCB2YXJpYW50cyBhcmUgbm90IHN1cHBvcnRlZCwgZG8gbm90IGNyZWF0ZSBpbmxpbmUgb2JqZWN0IHJlYWRlcnMgZXZlclxuXHRpbmxpbmVPYmplY3RSZWFkVGhyZXNob2xkID0gSW5maW5pdHk7XG59XG5cbmNsYXNzIFVucGFja3Ige1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdGlmIChvcHRpb25zLnVzZVJlY29yZHMgPT09IGZhbHNlICYmIG9wdGlvbnMubWFwc0FzT2JqZWN0cyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRvcHRpb25zLm1hcHNBc09iamVjdHMgPSB0cnVlO1xuXHRcdFx0aWYgKG9wdGlvbnMuc2VxdWVudGlhbCAmJiBvcHRpb25zLnRydXN0ZWQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdG9wdGlvbnMudHJ1c3RlZCA9IHRydWU7XG5cdFx0XHRcdGlmICghb3B0aW9ucy5zdHJ1Y3R1cmVzICYmIG9wdGlvbnMudXNlUmVjb3JkcyAhPSBmYWxzZSkge1xuXHRcdFx0XHRcdG9wdGlvbnMuc3RydWN0dXJlcyA9IFtdO1xuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5tYXhTaGFyZWRTdHJ1Y3R1cmVzKVxuXHRcdFx0XHRcdFx0b3B0aW9ucy5tYXhTaGFyZWRTdHJ1Y3R1cmVzID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9wdGlvbnMuc3RydWN0dXJlcylcblx0XHRcdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IG9wdGlvbnMuc3RydWN0dXJlcy5sZW5ndGg7XG5cdFx0XHRlbHNlIGlmIChvcHRpb25zLmdldFN0cnVjdHVyZXMpIHtcblx0XHRcdFx0KG9wdGlvbnMuc3RydWN0dXJlcyA9IFtdKS51bmluaXRpYWxpemVkID0gdHJ1ZTsgLy8gdGhpcyBpcyB3aGF0IHdlIHVzZSB0byBkZW5vdGUgYW4gdW5pbml0aWFsaXplZCBzdHJ1Y3R1cmVzXG5cdFx0XHRcdG9wdGlvbnMuc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9wdGlvbnMuaW50NjRBc051bWJlcikge1xuXHRcdFx0XHRvcHRpb25zLmludDY0QXNUeXBlID0gJ251bWJlcic7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cdH1cblx0dW5wYWNrKHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdGlmIChzcmMpIHtcblx0XHRcdC8vIHJlLWVudHJhbnQgZXhlY3V0aW9uLCBzYXZlIHRoZSBzdGF0ZSBhbmQgcmVzdG9yZSBpdCBhZnRlciB3ZSBkbyB0aGlzIHVucGFja1xuXHRcdFx0cmV0dXJuIHNhdmVTdGF0ZSQxKCgpID0+IHtcblx0XHRcdFx0Y2xlYXJTb3VyY2UoKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMgPyB0aGlzLnVucGFjayhzb3VyY2UsIG9wdGlvbnMpIDogVW5wYWNrci5wcm90b3R5cGUudW5wYWNrLmNhbGwoZGVmYXVsdE9wdGlvbnMsIHNvdXJjZSwgb3B0aW9ucylcblx0XHRcdH0pXG5cdFx0fVxuXHRcdGlmICghc291cmNlLmJ1ZmZlciAmJiBzb3VyY2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKVxuXHRcdFx0c291cmNlID0gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXIuZnJvbShzb3VyY2UpIDogbmV3IFVpbnQ4QXJyYXkoc291cmNlKTtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRzcmNFbmQgPSBvcHRpb25zLmVuZCB8fCBzb3VyY2UubGVuZ3RoO1xuXHRcdFx0cG9zaXRpb24kMSA9IG9wdGlvbnMuc3RhcnQgfHwgMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cG9zaXRpb24kMSA9IDA7XG5cdFx0XHRzcmNFbmQgPSBvcHRpb25zID4gLTEgPyBvcHRpb25zIDogc291cmNlLmxlbmd0aDtcblx0XHR9XG5cdFx0c3RyaW5nUG9zaXRpb24gPSAwO1xuXHRcdHNyY1N0cmluZ0VuZCA9IDA7XG5cdFx0c3JjU3RyaW5nID0gbnVsbDtcblx0XHRzdHJpbmdzID0gRU1QVFlfQVJSQVk7XG5cdFx0YnVuZGxlZFN0cmluZ3MkMSA9IG51bGw7XG5cdFx0c3JjID0gc291cmNlO1xuXHRcdC8vIHRoaXMgcHJvdmlkZXMgY2FjaGVkIGFjY2VzcyB0byB0aGUgZGF0YSB2aWV3IGZvciBhIGJ1ZmZlciBpZiBpdCBpcyBnZXR0aW5nIHJldXNlZCwgd2hpY2ggaXMgYSByZWNvbW1lbmRcblx0XHQvLyB0ZWNobmlxdWUgZm9yIGdldHRpbmcgZGF0YSBmcm9tIGEgZGF0YWJhc2Ugd2hlcmUgaXQgY2FuIGJlIGNvcGllZCBpbnRvIGFuIGV4aXN0aW5nIGJ1ZmZlciBpbnN0ZWFkIG9mIGNyZWF0aW5nXG5cdFx0Ly8gbmV3IG9uZXNcblx0XHR0cnkge1xuXHRcdFx0ZGF0YVZpZXcgPSBzb3VyY2UuZGF0YVZpZXcgfHwgKHNvdXJjZS5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgc291cmNlLmJ5dGVMZW5ndGgpKTtcblx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHQvLyBpZiBpdCBkb2Vzbid0IGhhdmUgYSBidWZmZXIsIG1heWJlIGl0IGlzIHRoZSB3cm9uZyB0eXBlIG9mIG9iamVjdFxuXHRcdFx0c3JjID0gbnVsbDtcblx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuXHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgbXVzdCBiZSBhIFVpbnQ4QXJyYXkgb3IgQnVmZmVyIGJ1dCB3YXMgYSAnICsgKChzb3VyY2UgJiYgdHlwZW9mIHNvdXJjZSA9PSAnb2JqZWN0JykgPyBzb3VyY2UuY29uc3RydWN0b3IubmFtZSA6IHR5cGVvZiBzb3VyY2UpKVxuXHRcdH1cblx0XHRpZiAodGhpcyBpbnN0YW5jZW9mIFVucGFja3IpIHtcblx0XHRcdGN1cnJlbnRVbnBhY2tyID0gdGhpcztcblx0XHRcdGlmICh0aGlzLnN0cnVjdHVyZXMpIHtcblx0XHRcdFx0Y3VycmVudFN0cnVjdHVyZXMgPSB0aGlzLnN0cnVjdHVyZXM7XG5cdFx0XHRcdHJldHVybiBjaGVja2VkUmVhZChvcHRpb25zKVxuXHRcdFx0fSBlbHNlIGlmICghY3VycmVudFN0cnVjdHVyZXMgfHwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IFtdO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJyZW50VW5wYWNrciA9IGRlZmF1bHRPcHRpb25zO1xuXHRcdFx0aWYgKCFjdXJyZW50U3RydWN0dXJlcyB8fCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGggPiAwKVxuXHRcdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gY2hlY2tlZFJlYWQob3B0aW9ucylcblx0fVxuXHR1bnBhY2tNdWx0aXBsZShzb3VyY2UsIGZvckVhY2gpIHtcblx0XHRsZXQgdmFsdWVzLCBsYXN0UG9zaXRpb24gPSAwO1xuXHRcdHRyeSB7XG5cdFx0XHRzZXF1ZW50aWFsTW9kZSA9IHRydWU7XG5cdFx0XHRsZXQgc2l6ZSA9IHNvdXJjZS5sZW5ndGg7XG5cdFx0XHRsZXQgdmFsdWUgPSB0aGlzID8gdGhpcy51bnBhY2soc291cmNlLCBzaXplKSA6IGRlZmF1bHRVbnBhY2tyLnVucGFjayhzb3VyY2UsIHNpemUpO1xuXHRcdFx0aWYgKGZvckVhY2gpIHtcblx0XHRcdFx0aWYgKGZvckVhY2godmFsdWUsIGxhc3RQb3NpdGlvbiwgcG9zaXRpb24kMSkgPT09IGZhbHNlKSByZXR1cm47XG5cdFx0XHRcdHdoaWxlKHBvc2l0aW9uJDEgPCBzaXplKSB7XG5cdFx0XHRcdFx0bGFzdFBvc2l0aW9uID0gcG9zaXRpb24kMTtcblx0XHRcdFx0XHRpZiAoZm9yRWFjaChjaGVja2VkUmVhZCgpLCBsYXN0UG9zaXRpb24sIHBvc2l0aW9uJDEpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFsdWVzID0gWyB2YWx1ZSBdO1xuXHRcdFx0XHR3aGlsZShwb3NpdGlvbiQxIDwgc2l6ZSkge1xuXHRcdFx0XHRcdGxhc3RQb3NpdGlvbiA9IHBvc2l0aW9uJDE7XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goY2hlY2tlZFJlYWQoKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlc1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdGVycm9yLmxhc3RQb3NpdGlvbiA9IGxhc3RQb3NpdGlvbjtcblx0XHRcdGVycm9yLnZhbHVlcyA9IHZhbHVlcztcblx0XHRcdHRocm93IGVycm9yXG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNlcXVlbnRpYWxNb2RlID0gZmFsc2U7XG5cdFx0XHRjbGVhclNvdXJjZSgpO1xuXHRcdH1cblx0fVxuXHRfbWVyZ2VTdHJ1Y3R1cmVzKGxvYWRlZFN0cnVjdHVyZXMsIGV4aXN0aW5nU3RydWN0dXJlcykge1xuXHRcdGlmIChvbkxvYWRlZFN0cnVjdHVyZXMkMSlcblx0XHRcdGxvYWRlZFN0cnVjdHVyZXMgPSBvbkxvYWRlZFN0cnVjdHVyZXMkMS5jYWxsKHRoaXMsIGxvYWRlZFN0cnVjdHVyZXMpO1xuXHRcdGxvYWRlZFN0cnVjdHVyZXMgPSBsb2FkZWRTdHJ1Y3R1cmVzIHx8IFtdO1xuXHRcdGlmIChPYmplY3QuaXNGcm96ZW4obG9hZGVkU3RydWN0dXJlcykpXG5cdFx0XHRsb2FkZWRTdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0dXJlcy5tYXAoc3RydWN0dXJlID0+IHN0cnVjdHVyZS5zbGljZSgwKSk7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBsb2FkZWRTdHJ1Y3R1cmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bGV0IHN0cnVjdHVyZSA9IGxvYWRlZFN0cnVjdHVyZXNbaV07XG5cdFx0XHRpZiAoc3RydWN0dXJlKSB7XG5cdFx0XHRcdHN0cnVjdHVyZS5pc1NoYXJlZCA9IHRydWU7XG5cdFx0XHRcdGlmIChpID49IDMyKVxuXHRcdFx0XHRcdHN0cnVjdHVyZS5oaWdoQnl0ZSA9IChpIC0gMzIpID4+IDU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxvYWRlZFN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gbG9hZGVkU3RydWN0dXJlcy5sZW5ndGg7XG5cdFx0Zm9yIChsZXQgaWQgaW4gZXhpc3RpbmdTdHJ1Y3R1cmVzIHx8IFtdKSB7XG5cdFx0XHRpZiAoaWQgPj0gMCkge1xuXHRcdFx0XHRsZXQgc3RydWN0dXJlID0gbG9hZGVkU3RydWN0dXJlc1tpZF07XG5cdFx0XHRcdGxldCBleGlzdGluZyA9IGV4aXN0aW5nU3RydWN0dXJlc1tpZF07XG5cdFx0XHRcdGlmIChleGlzdGluZykge1xuXHRcdFx0XHRcdGlmIChzdHJ1Y3R1cmUpXG5cdFx0XHRcdFx0XHQobG9hZGVkU3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyB8fCAobG9hZGVkU3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyA9IFtdKSlbaWRdID0gc3RydWN0dXJlO1xuXHRcdFx0XHRcdGxvYWRlZFN0cnVjdHVyZXNbaWRdID0gZXhpc3Rpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuc3RydWN0dXJlcyA9IGxvYWRlZFN0cnVjdHVyZXNcblx0fVxuXHRkZWNvZGUoc291cmNlLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIHRoaXMudW5wYWNrKHNvdXJjZSwgb3B0aW9ucylcblx0fVxufVxuZnVuY3Rpb24gY2hlY2tlZFJlYWQob3B0aW9ucykge1xuXHR0cnkge1xuXHRcdGlmICghY3VycmVudFVucGFja3IudHJ1c3RlZCAmJiAhc2VxdWVudGlhbE1vZGUpIHtcblx0XHRcdGxldCBzaGFyZWRMZW5ndGggPSBjdXJyZW50U3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMDtcblx0XHRcdGlmIChzaGFyZWRMZW5ndGggPCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGgpXG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA9IHNoYXJlZExlbmd0aDtcblx0XHR9XG5cdFx0bGV0IHJlc3VsdDtcblx0XHRpZiAoY3VycmVudFVucGFja3IucmFuZG9tQWNjZXNzU3RydWN0dXJlICYmIHNyY1twb3NpdGlvbiQxXSA8IDB4NDAgJiYgc3JjW3Bvc2l0aW9uJDFdID49IDB4MjAgJiYgcmVhZFN0cnVjdCQxKSB7XG5cdFx0XHRyZXN1bHQgPSByZWFkU3RydWN0JDEoc3JjLCBwb3NpdGlvbiQxLCBzcmNFbmQsIGN1cnJlbnRVbnBhY2tyKTtcblx0XHRcdHNyYyA9IG51bGw7IC8vIGRpc3Bvc2Ugb2YgdGhpcyBzbyB0aGF0IHJlY3Vyc2l2ZSB1bnBhY2sgY2FsbHMgZG9uJ3Qgc2F2ZSBzdGF0ZVxuXHRcdFx0aWYgKCEob3B0aW9ucyAmJiBvcHRpb25zLmxhenkpICYmIHJlc3VsdClcblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LnRvSlNPTigpO1xuXHRcdFx0cG9zaXRpb24kMSA9IHNyY0VuZDtcblx0XHR9IGVsc2Vcblx0XHRcdHJlc3VsdCA9IHJlYWQoKTtcblx0XHRpZiAoYnVuZGxlZFN0cmluZ3MkMSkgeyAvLyBidW5kbGVkIHN0cmluZ3MgdG8gc2tpcCBwYXN0XG5cdFx0XHRwb3NpdGlvbiQxID0gYnVuZGxlZFN0cmluZ3MkMS5wb3N0QnVuZGxlUG9zaXRpb247XG5cdFx0XHRidW5kbGVkU3RyaW5ncyQxID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHNlcXVlbnRpYWxNb2RlKVxuXHRcdFx0Ly8gd2Ugb25seSBuZWVkIHRvIHJlc3RvcmUgdGhlIHN0cnVjdHVyZXMgaWYgdGhlcmUgd2FzIGFuIGVycm9yLCBidXQgaWYgd2UgY29tcGxldGVkIGEgcmVhZCxcblx0XHRcdC8vIHdlIGNhbiBjbGVhciB0aGlzIG91dCBhbmQga2VlcCB0aGUgc3RydWN0dXJlcyB3ZSByZWFkXG5cdFx0XHRjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyA9IG51bGw7XG5cblx0XHRpZiAocG9zaXRpb24kMSA9PSBzcmNFbmQpIHtcblx0XHRcdC8vIGZpbmlzaGVkIHJlYWRpbmcgdGhpcyBzb3VyY2UsIGNsZWFudXAgcmVmZXJlbmNlc1xuXHRcdFx0aWYgKGN1cnJlbnRTdHJ1Y3R1cmVzICYmIGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzKVxuXHRcdFx0XHRyZXN0b3JlU3RydWN0dXJlcygpO1xuXHRcdFx0Y3VycmVudFN0cnVjdHVyZXMgPSBudWxsO1xuXHRcdFx0c3JjID0gbnVsbDtcblx0XHRcdGlmIChyZWZlcmVuY2VNYXApXG5cdFx0XHRcdHJlZmVyZW5jZU1hcCA9IG51bGw7XG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiQxID4gc3JjRW5kKSB7XG5cdFx0XHQvLyBvdmVyIHJlYWRcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgTWVzc2FnZVBhY2sgZGF0YScpXG5cdFx0fSBlbHNlIGlmICghc2VxdWVudGlhbE1vZGUpIHtcblx0XHRcdGxldCBqc29uVmlldztcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGpzb25WaWV3ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LCAoXywgdmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IGAke3ZhbHVlfW5gIDogdmFsdWUpLnNsaWNlKDAsIDEwMCk7XG5cdFx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRcdGpzb25WaWV3ID0gJyhKU09OIHZpZXcgbm90IGF2YWlsYWJsZSAnICsgZXJyb3IgKyAnKSc7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgcmVhZCwgYnV0IGVuZCBvZiBidWZmZXIgbm90IHJlYWNoZWQgJyArIGpzb25WaWV3KVxuXHRcdH1cblx0XHQvLyBlbHNlIG1vcmUgdG8gcmVhZCwgYnV0IHdlIGFyZSByZWFkaW5nIHNlcXVlbnRpYWxseSwgc28gZG9uJ3QgY2xlYXIgc291cmNlIHlldFxuXHRcdHJldHVybiByZXN1bHRcblx0fSBjYXRjaChlcnJvcikge1xuXHRcdGlmIChjdXJyZW50U3RydWN0dXJlcyAmJiBjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcylcblx0XHRcdHJlc3RvcmVTdHJ1Y3R1cmVzKCk7XG5cdFx0Y2xlYXJTb3VyY2UoKTtcblx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yIHx8IGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aCgnVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJykgfHwgcG9zaXRpb24kMSA+IHNyY0VuZCkge1xuXHRcdFx0ZXJyb3IuaW5jb21wbGV0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHRocm93IGVycm9yXG5cdH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVN0cnVjdHVyZXMoKSB7XG5cdGZvciAobGV0IGlkIGluIGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzKSB7XG5cdFx0Y3VycmVudFN0cnVjdHVyZXNbaWRdID0gY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXNbaWRdO1xuXHR9XG5cdGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVhZCgpIHtcblx0bGV0IHRva2VuID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdGlmICh0b2tlbiA8IDB4YTApIHtcblx0XHRpZiAodG9rZW4gPCAweDgwKSB7XG5cdFx0XHRpZiAodG9rZW4gPCAweDQwKVxuXHRcdFx0XHRyZXR1cm4gdG9rZW5cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsZXQgc3RydWN0dXJlID0gY3VycmVudFN0cnVjdHVyZXNbdG9rZW4gJiAweDNmXSB8fFxuXHRcdFx0XHRcdGN1cnJlbnRVbnBhY2tyLmdldFN0cnVjdHVyZXMgJiYgbG9hZFN0cnVjdHVyZXMoKVt0b2tlbiAmIDB4M2ZdO1xuXHRcdFx0XHRpZiAoc3RydWN0dXJlKSB7XG5cdFx0XHRcdFx0aWYgKCFzdHJ1Y3R1cmUucmVhZCkge1xuXHRcdFx0XHRcdFx0c3RydWN0dXJlLnJlYWQgPSBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlLCB0b2tlbiAmIDB4M2YpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc3RydWN0dXJlLnJlYWQoKVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRva2VuIDwgMHg5MCkge1xuXHRcdFx0Ly8gbWFwXG5cdFx0XHR0b2tlbiAtPSAweDgwO1xuXHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLm1hcHNBc09iamVjdHMpIHtcblx0XHRcdFx0bGV0IG9iamVjdCA9IHt9O1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcblx0XHRcdFx0XHRsZXQga2V5ID0gcmVhZEtleSgpO1xuXHRcdFx0XHRcdGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuXHRcdFx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJztcblx0XHRcdFx0XHRvYmplY3Rba2V5XSA9IHJlYWQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb2JqZWN0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgbWFwID0gbmV3IE1hcCgpO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcblx0XHRcdFx0XHRtYXAuc2V0KHJlYWQoKSwgcmVhZCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWFwXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRva2VuIC09IDB4OTA7XG5cdFx0XHRsZXQgYXJyYXkgPSBuZXcgQXJyYXkodG9rZW4pO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbjsgaSsrKSB7XG5cdFx0XHRcdGFycmF5W2ldID0gcmVhZCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLmZyZWV6ZURhdGEpXG5cdFx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKGFycmF5KVxuXHRcdFx0cmV0dXJuIGFycmF5XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHRva2VuIDwgMHhjMCkge1xuXHRcdC8vIGZpeHN0clxuXHRcdGxldCBsZW5ndGggPSB0b2tlbiAtIDB4YTA7XG5cdFx0aWYgKHNyY1N0cmluZ0VuZCA+PSBwb3NpdGlvbiQxKSB7XG5cdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uJDEgLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uJDEgKz0gbGVuZ3RoKSAtIHNyY1N0cmluZ1N0YXJ0KVxuXHRcdH1cblx0XHRpZiAoc3JjU3RyaW5nRW5kID09IDAgJiYgc3JjRW5kIDwgMTQwKSB7XG5cdFx0XHQvLyBmb3Igc21hbGwgYmxvY2tzLCBhdm9pZGluZyB0aGUgb3ZlcmhlYWQgb2YgdGhlIGV4dHJhY3QgY2FsbCBpcyBoZWxwZnVsXG5cdFx0XHRsZXQgc3RyaW5nID0gbGVuZ3RoIDwgMTYgPyBzaG9ydFN0cmluZ0luSlMobGVuZ3RoKSA6IGxvbmdTdHJpbmdJbkpTKGxlbmd0aCk7XG5cdFx0XHRpZiAoc3RyaW5nICE9IG51bGwpXG5cdFx0XHRcdHJldHVybiBzdHJpbmdcblx0XHR9XG5cdFx0cmV0dXJuIHJlYWRGaXhlZFN0cmluZyhsZW5ndGgpXG5cdH0gZWxzZSB7XG5cdFx0bGV0IHZhbHVlO1xuXHRcdHN3aXRjaCAodG9rZW4pIHtcblx0XHRcdGNhc2UgMHhjMDogcmV0dXJuIG51bGxcblx0XHRcdGNhc2UgMHhjMTpcblx0XHRcdFx0aWYgKGJ1bmRsZWRTdHJpbmdzJDEpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHJlYWQoKTsgLy8gZm9sbG93ZWQgYnkgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGluIGNoYXJhY3RlcnMgKG5vdCBieXRlcyEpXG5cdFx0XHRcdFx0aWYgKHZhbHVlID4gMClcblx0XHRcdFx0XHRcdHJldHVybiBidW5kbGVkU3RyaW5ncyQxWzFdLnNsaWNlKGJ1bmRsZWRTdHJpbmdzJDEucG9zaXRpb24xLCBidW5kbGVkU3RyaW5ncyQxLnBvc2l0aW9uMSArPSB2YWx1ZSlcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyZXR1cm4gYnVuZGxlZFN0cmluZ3MkMVswXS5zbGljZShidW5kbGVkU3RyaW5ncyQxLnBvc2l0aW9uMCwgYnVuZGxlZFN0cmluZ3MkMS5wb3NpdGlvbjAgLT0gdmFsdWUpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIEMxOyAvLyBcIm5ldmVyLXVzZWRcIiwgcmV0dXJuIHNwZWNpYWwgb2JqZWN0IHRvIGRlbm90ZSB0aGF0XG5cdFx0XHRjYXNlIDB4YzI6IHJldHVybiBmYWxzZVxuXHRcdFx0Y2FzZSAweGMzOiByZXR1cm4gdHJ1ZVxuXHRcdFx0Y2FzZSAweGM0OlxuXHRcdFx0XHQvLyBiaW4gOFxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGJ1ZmZlcicpXG5cdFx0XHRcdHJldHVybiByZWFkQmluKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM1OlxuXHRcdFx0XHQvLyBiaW4gMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHJlYWRCaW4odmFsdWUpXG5cdFx0XHRjYXNlIDB4YzY6XG5cdFx0XHRcdC8vIGJpbiAzMlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRyZXR1cm4gcmVhZEJpbih2YWx1ZSlcblx0XHRcdGNhc2UgMHhjNzpcblx0XHRcdFx0Ly8gZXh0IDhcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoc3JjW3Bvc2l0aW9uJDErK10pXG5cdFx0XHRjYXNlIDB4Yzg6XG5cdFx0XHRcdC8vIGV4dCAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSAyO1xuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCh2YWx1ZSlcblx0XHRcdGNhc2UgMHhjOTpcblx0XHRcdFx0Ly8gZXh0IDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdHJldHVybiByZWFkRXh0KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGNhOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0MzIocG9zaXRpb24kMSk7XG5cdFx0XHRcdGlmIChjdXJyZW50VW5wYWNrci51c2VGbG9hdDMyID4gMikge1xuXHRcdFx0XHRcdC8vIHRoaXMgZG9lcyByb3VuZGluZyBvZiBudW1iZXJzIHRoYXQgd2VyZSBlbmNvZGVkIGluIDMyLWJpdCBmbG9hdCB0byBuZWFyZXN0IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXQgdGhhdCBjb3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdFx0XHRsZXQgbXVsdGlwbGllciA9IG11bHQxMFsoKHNyY1twb3NpdGlvbiQxXSAmIDB4N2YpIDw8IDEpIHwgKHNyY1twb3NpdGlvbiQxICsgMV0gPj4gNyldO1xuXHRcdFx0XHRcdHBvc2l0aW9uJDEgKz0gNDtcblx0XHRcdFx0XHRyZXR1cm4gKChtdWx0aXBsaWVyICogdmFsdWUgKyAodmFsdWUgPiAwID8gMC41IDogLTAuNSkpID4+IDApIC8gbXVsdGlwbGllclxuXHRcdFx0XHR9XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4Y2I6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQ2NChwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSA4O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdC8vIHVpbnQgaGFuZGxlcnNcblx0XHRcdGNhc2UgMHhjYzpcblx0XHRcdFx0cmV0dXJuIHNyY1twb3NpdGlvbiQxKytdXG5cdFx0XHRjYXNlIDB4Y2Q6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDI7XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGNlOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhjZjpcblx0XHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpICogMHgxMDAwMDAwMDA7XG5cdFx0XHRcdFx0dmFsdWUgKz0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEgKyA0KTtcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ1VpbnQ2NChwb3NpdGlvbiQxKS50b1N0cmluZygpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnYXV0bycpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ1VpbnQ2NChwb3NpdGlvbiQxKTtcblx0XHRcdFx0XHRpZiAodmFsdWU8PUJpZ0ludCgyKTw8QmlnSW50KDUyKSkgdmFsdWU9TnVtYmVyKHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdVaW50NjQocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gODtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cblx0XHRcdC8vIGludCBoYW5kbGVyc1xuXHRcdFx0Y2FzZSAweGQwOlxuXHRcdFx0XHRyZXR1cm4gZGF0YVZpZXcuZ2V0SW50OChwb3NpdGlvbiQxKyspXG5cdFx0XHRjYXNlIDB4ZDE6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MTYocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4ZDI6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MzIocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4ZDM6XG5cdFx0XHRcdGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEludDMyKHBvc2l0aW9uJDEpICogMHgxMDAwMDAwMDA7XG5cdFx0XHRcdFx0dmFsdWUgKz0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEgKyA0KTtcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ0ludDY0KHBvc2l0aW9uJDEpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdhdXRvJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnSW50NjQocG9zaXRpb24kMSk7XG5cdFx0XHRcdFx0aWYgKHZhbHVlPj1CaWdJbnQoLTIpPDxCaWdJbnQoNTIpJiZ2YWx1ZTw9QmlnSW50KDIpPDxCaWdJbnQoNTIpKSB2YWx1ZT1OdW1iZXIodmFsdWUpO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ0ludDY0KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDg7XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXG5cdFx0XHRjYXNlIDB4ZDQ6XG5cdFx0XHRcdC8vIGZpeGV4dCAxXG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGlmICh2YWx1ZSA9PSAweDcyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlY29yZERlZmluaXRpb24oc3JjW3Bvc2l0aW9uJDErK10gJiAweDNmKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCBleHRlbnNpb24gPSBjdXJyZW50RXh0ZW5zaW9uc1t2YWx1ZV07XG5cdFx0XHRcdFx0aWYgKGV4dGVuc2lvbikge1xuXHRcdFx0XHRcdFx0aWYgKGV4dGVuc2lvbi5yZWFkKSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uJDErKzsgLy8gc2tpcCBmaWxsZXIgYnl0ZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uLnJlYWQocmVhZCgpKVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChleHRlbnNpb24ubm9CdWZmZXIpIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24kMSsrOyAvLyBza2lwIGZpbGxlciBieXRlXG5cdFx0XHRcdFx0XHRcdHJldHVybiBleHRlbnNpb24oKVxuXHRcdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRcdHJldHVybiBleHRlbnNpb24oc3JjLnN1YmFycmF5KHBvc2l0aW9uJDEsICsrcG9zaXRpb24kMSkpXG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXh0ZW5zaW9uICcgKyB2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSAweGQ1OlxuXHRcdFx0XHQvLyBmaXhleHQgMlxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbiQxXTtcblx0XHRcdFx0aWYgKHZhbHVlID09IDB4NzIpIHtcblx0XHRcdFx0XHRwb3NpdGlvbiQxKys7XG5cdFx0XHRcdFx0cmV0dXJuIHJlY29yZERlZmluaXRpb24oc3JjW3Bvc2l0aW9uJDErK10gJiAweDNmLCBzcmNbcG9zaXRpb24kMSsrXSlcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoMilcblx0XHRcdGNhc2UgMHhkNjpcblx0XHRcdFx0Ly8gZml4ZXh0IDRcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoNClcblx0XHRcdGNhc2UgMHhkNzpcblx0XHRcdFx0Ly8gZml4ZXh0IDhcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoOClcblx0XHRcdGNhc2UgMHhkODpcblx0XHRcdFx0Ly8gZml4ZXh0IDE2XG5cdFx0XHRcdHJldHVybiByZWFkRXh0KDE2KVxuXHRcdFx0Y2FzZSAweGQ5OlxuXHRcdFx0Ly8gc3RyIDhcblx0XHRcdFx0dmFsdWUgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0aWYgKHNyY1N0cmluZ0VuZCA+PSBwb3NpdGlvbiQxKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNyY1N0cmluZy5zbGljZShwb3NpdGlvbiQxIC0gc3JjU3RyaW5nU3RhcnQsIChwb3NpdGlvbiQxICs9IHZhbHVlKSAtIHNyY1N0cmluZ1N0YXJ0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZWFkU3RyaW5nOCh2YWx1ZSlcblx0XHRcdGNhc2UgMHhkYTpcblx0XHRcdC8vIHN0ciAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSAyO1xuXHRcdFx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uJDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uJDEgLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uJDEgKz0gdmFsdWUpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmcxNih2YWx1ZSlcblx0XHRcdGNhc2UgMHhkYjpcblx0XHRcdC8vIHN0ciAzMlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uJDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uJDEgLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uJDEgKz0gdmFsdWUpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmczMih2YWx1ZSlcblx0XHRcdGNhc2UgMHhkYzpcblx0XHRcdC8vIGFycmF5IDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDI7XG5cdFx0XHRcdHJldHVybiByZWFkQXJyYXkodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGQ6XG5cdFx0XHQvLyBhcnJheSAzMlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRyZXR1cm4gcmVhZEFycmF5KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRlOlxuXHRcdFx0Ly8gbWFwIDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDI7XG5cdFx0XHRcdHJldHVybiByZWFkTWFwKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRmOlxuXHRcdFx0Ly8gbWFwIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdHJldHVybiByZWFkTWFwKHZhbHVlKVxuXHRcdFx0ZGVmYXVsdDogLy8gbmVnYXRpdmUgaW50XG5cdFx0XHRcdGlmICh0b2tlbiA+PSAweGUwKVxuXHRcdFx0XHRcdHJldHVybiB0b2tlbiAtIDB4MTAwXG5cdFx0XHRcdGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bGV0IGVycm9yID0gbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBNZXNzYWdlUGFjayBkYXRhJyk7XG5cdFx0XHRcdFx0ZXJyb3IuaW5jb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3Jcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gTWVzc2FnZVBhY2sgdG9rZW4gJyArIHRva2VuKVxuXG5cdFx0fVxuXHR9XG59XG5jb25zdCB2YWxpZE5hbWUgPSAvXlthLXpBLVpfJF1bYS16QS1aXFxkXyRdKiQvO1xuZnVuY3Rpb24gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgZmlyc3RJZCkge1xuXHRmdW5jdGlvbiByZWFkT2JqZWN0KCkge1xuXHRcdC8vIFRoaXMgaW5pdGlhbCBmdW5jdGlvbiBpcyBxdWljayB0byBpbnN0YW50aWF0ZSwgYnV0IHJ1bnMgc2xvd2VyLiBBZnRlciBzZXZlcmFsIGl0ZXJhdGlvbnMgcGF5IHRoZSBjb3N0IHRvIGJ1aWxkIHRoZSBmYXN0ZXIgZnVuY3Rpb25cblx0XHRpZiAocmVhZE9iamVjdC5jb3VudCsrID4gaW5saW5lT2JqZWN0UmVhZFRocmVzaG9sZCkge1xuXHRcdFx0bGV0IHJlYWRPYmplY3QgPSBzdHJ1Y3R1cmUucmVhZCA9IChuZXcgRnVuY3Rpb24oJ3InLCAncmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuICcgKyAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSA/ICdPYmplY3QuZnJlZXplJyA6ICcnKSArXG5cdFx0XHRcdCcoeycgKyBzdHJ1Y3R1cmUubWFwKGtleSA9PiBrZXkgPT09ICdfX3Byb3RvX18nID8gJ19fcHJvdG9fOnIoKScgOiB2YWxpZE5hbWUudGVzdChrZXkpID8ga2V5ICsgJzpyKCknIDogKCdbJyArIEpTT04uc3RyaW5naWZ5KGtleSkgKyAnXTpyKCknKSkuam9pbignLCcpICsgJ30pfScpKShyZWFkKTtcblx0XHRcdGlmIChzdHJ1Y3R1cmUuaGlnaEJ5dGUgPT09IDApXG5cdFx0XHRcdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU2Vjb25kQnl0ZVJlYWRlcihmaXJzdElkLCBzdHJ1Y3R1cmUucmVhZCk7XG5cdFx0XHRyZXR1cm4gcmVhZE9iamVjdCgpIC8vIHNlY29uZCBieXRlIGlzIGFscmVhZHkgcmVhZCwgaWYgdGhlcmUgaXMgb25lIHNvIGltbWVkaWF0ZWx5IHJlYWQgb2JqZWN0XG5cdFx0fVxuXHRcdGxldCBvYmplY3QgPSB7fTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHN0cnVjdHVyZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGxldCBrZXkgPSBzdHJ1Y3R1cmVbaV07XG5cdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJylcblx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJztcblx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpO1xuXHRcdH1cblx0XHRpZiAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSlcblx0XHRcdHJldHVybiBPYmplY3QuZnJlZXplKG9iamVjdCk7XG5cdFx0cmV0dXJuIG9iamVjdFxuXHR9XG5cdHJlYWRPYmplY3QuY291bnQgPSAwO1xuXHRpZiAoc3RydWN0dXJlLmhpZ2hCeXRlID09PSAwKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZVNlY29uZEJ5dGVSZWFkZXIoZmlyc3RJZCwgcmVhZE9iamVjdClcblx0fVxuXHRyZXR1cm4gcmVhZE9iamVjdFxufVxuXG5jb25zdCBjcmVhdGVTZWNvbmRCeXRlUmVhZGVyID0gKGZpcnN0SWQsIHJlYWQwKSA9PiB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRsZXQgaGlnaEJ5dGUgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRpZiAoaGlnaEJ5dGUgPT09IDApXG5cdFx0XHRyZXR1cm4gcmVhZDAoKVxuXHRcdGxldCBpZCA9IGZpcnN0SWQgPCAzMiA/IC0oZmlyc3RJZCArIChoaWdoQnl0ZSA8PCA1KSkgOiBmaXJzdElkICsgKGhpZ2hCeXRlIDw8IDUpO1xuXHRcdGxldCBzdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1tpZF0gfHwgbG9hZFN0cnVjdHVyZXMoKVtpZF07XG5cdFx0aWYgKCFzdHJ1Y3R1cmUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUmVjb3JkIGlkIGlzIG5vdCBkZWZpbmVkIGZvciAnICsgaWQpXG5cdFx0fVxuXHRcdGlmICghc3RydWN0dXJlLnJlYWQpXG5cdFx0XHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUsIGZpcnN0SWQpO1xuXHRcdHJldHVybiBzdHJ1Y3R1cmUucmVhZCgpXG5cdH1cbn07XG5cbmZ1bmN0aW9uIGxvYWRTdHJ1Y3R1cmVzKCkge1xuXHRsZXQgbG9hZGVkU3RydWN0dXJlcyA9IHNhdmVTdGF0ZSQxKCgpID0+IHtcblx0XHQvLyBzYXZlIHRoZSBzdGF0ZSBpbiBjYXNlIGdldFN0cnVjdHVyZXMgbW9kaWZpZXMgb3VyIGJ1ZmZlclxuXHRcdHNyYyA9IG51bGw7XG5cdFx0cmV0dXJuIGN1cnJlbnRVbnBhY2tyLmdldFN0cnVjdHVyZXMoKVxuXHR9KTtcblx0cmV0dXJuIGN1cnJlbnRTdHJ1Y3R1cmVzID0gY3VycmVudFVucGFja3IuX21lcmdlU3RydWN0dXJlcyhsb2FkZWRTdHJ1Y3R1cmVzLCBjdXJyZW50U3RydWN0dXJlcylcbn1cblxudmFyIHJlYWRGaXhlZFN0cmluZyA9IHJlYWRTdHJpbmdKUztcbnZhciByZWFkU3RyaW5nOCA9IHJlYWRTdHJpbmdKUztcbnZhciByZWFkU3RyaW5nMTYgPSByZWFkU3RyaW5nSlM7XG52YXIgcmVhZFN0cmluZzMyID0gcmVhZFN0cmluZ0pTO1xuZXhwb3J0cy5pc05hdGl2ZUFjY2VsZXJhdGlvbkVuYWJsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2V0RXh0cmFjdG9yKGV4dHJhY3RTdHJpbmdzKSB7XG5cdGV4cG9ydHMuaXNOYXRpdmVBY2NlbGVyYXRpb25FbmFibGVkID0gdHJ1ZTtcblx0cmVhZEZpeGVkU3RyaW5nID0gcmVhZFN0cmluZygxKTtcblx0cmVhZFN0cmluZzggPSByZWFkU3RyaW5nKDIpO1xuXHRyZWFkU3RyaW5nMTYgPSByZWFkU3RyaW5nKDMpO1xuXHRyZWFkU3RyaW5nMzIgPSByZWFkU3RyaW5nKDUpO1xuXHRmdW5jdGlvbiByZWFkU3RyaW5nKGhlYWRlckxlbmd0aCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiByZWFkU3RyaW5nKGxlbmd0aCkge1xuXHRcdFx0bGV0IHN0cmluZyA9IHN0cmluZ3Nbc3RyaW5nUG9zaXRpb24rK107XG5cdFx0XHRpZiAoc3RyaW5nID09IG51bGwpIHtcblx0XHRcdFx0aWYgKGJ1bmRsZWRTdHJpbmdzJDEpXG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmdKUyhsZW5ndGgpXG5cdFx0XHRcdGxldCBieXRlT2Zmc2V0ID0gc3JjLmJ5dGVPZmZzZXQ7XG5cdFx0XHRcdGxldCBleHRyYWN0aW9uID0gZXh0cmFjdFN0cmluZ3MocG9zaXRpb24kMSAtIGhlYWRlckxlbmd0aCArIGJ5dGVPZmZzZXQsIHNyY0VuZCArIGJ5dGVPZmZzZXQsIHNyYy5idWZmZXIpO1xuXHRcdFx0XHRpZiAodHlwZW9mIGV4dHJhY3Rpb24gPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRzdHJpbmcgPSBleHRyYWN0aW9uO1xuXHRcdFx0XHRcdHN0cmluZ3MgPSBFTVBUWV9BUlJBWTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHJpbmdzID0gZXh0cmFjdGlvbjtcblx0XHRcdFx0XHRzdHJpbmdQb3NpdGlvbiA9IDE7XG5cdFx0XHRcdFx0c3JjU3RyaW5nRW5kID0gMTsgLy8gZXZlbiBpZiBhIHV0Zi04IHN0cmluZyB3YXMgZGVjb2RlZCwgbXVzdCBpbmRpY2F0ZSB3ZSBhcmUgaW4gdGhlIG1pZHN0IG9mIGV4dHJhY3RlZCBzdHJpbmdzIGFuZCBjYW4ndCBza2lwIHN0cmluZ3Ncblx0XHRcdFx0XHRzdHJpbmcgPSBzdHJpbmdzWzBdO1xuXHRcdFx0XHRcdGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGV0IHNyY1N0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0XHRpZiAoc3JjU3RyaW5nTGVuZ3RoIDw9IGxlbmd0aCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IGxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIHN0cmluZ1xuXHRcdFx0fVxuXHRcdFx0c3JjU3RyaW5nID0gc3RyaW5nO1xuXHRcdFx0c3JjU3RyaW5nU3RhcnQgPSBwb3NpdGlvbiQxO1xuXHRcdFx0c3JjU3RyaW5nRW5kID0gcG9zaXRpb24kMSArIHNyY1N0cmluZ0xlbmd0aDtcblx0XHRcdHBvc2l0aW9uJDEgKz0gbGVuZ3RoO1xuXHRcdFx0cmV0dXJuIHN0cmluZy5zbGljZSgwLCBsZW5ndGgpIC8vIHdlIGtub3cgd2UganVzdCB3YW50IHRoZSBiZWdpbm5pbmdcblx0XHR9XG5cdH1cbn1cbmZ1bmN0aW9uIHJlYWRTdHJpbmdKUyhsZW5ndGgpIHtcblx0bGV0IHJlc3VsdDtcblx0aWYgKGxlbmd0aCA8IDE2KSB7XG5cdFx0aWYgKHJlc3VsdCA9IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHR9XG5cdGlmIChsZW5ndGggPiA2NCAmJiBkZWNvZGVyKVxuXHRcdHJldHVybiBkZWNvZGVyLmRlY29kZShzcmMuc3ViYXJyYXkocG9zaXRpb24kMSwgcG9zaXRpb24kMSArPSBsZW5ndGgpKVxuXHRjb25zdCBlbmQgPSBwb3NpdGlvbiQxICsgbGVuZ3RoO1xuXHRjb25zdCB1bml0cyA9IFtdO1xuXHRyZXN1bHQgPSAnJztcblx0d2hpbGUgKHBvc2l0aW9uJDEgPCBlbmQpIHtcblx0XHRjb25zdCBieXRlMSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PT0gMCkge1xuXHRcdFx0Ly8gMSBieXRlXG5cdFx0XHR1bml0cy5wdXNoKGJ5dGUxKTtcblx0XHR9IGVsc2UgaWYgKChieXRlMSAmIDB4ZTApID09PSAweGMwKSB7XG5cdFx0XHQvLyAyIGJ5dGVzXG5cdFx0XHRjb25zdCBieXRlMiA9IHNyY1twb3NpdGlvbiQxKytdICYgMHgzZjtcblx0XHRcdHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDYpIHwgYnl0ZTIpO1xuXHRcdH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhmMCkgPT09IDB4ZTApIHtcblx0XHRcdC8vIDMgYnl0ZXNcblx0XHRcdGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uJDErK10gJiAweDNmO1xuXHRcdFx0Y29uc3QgYnl0ZTMgPSBzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2Y7XG5cdFx0XHR1bml0cy5wdXNoKCgoYnl0ZTEgJiAweDFmKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMyk7XG5cdFx0fSBlbHNlIGlmICgoYnl0ZTEgJiAweGY4KSA9PT0gMHhmMCkge1xuXHRcdFx0Ly8gNCBieXRlc1xuXHRcdFx0Y29uc3QgYnl0ZTIgPSBzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2Y7XG5cdFx0XHRjb25zdCBieXRlMyA9IHNyY1twb3NpdGlvbiQxKytdICYgMHgzZjtcblx0XHRcdGNvbnN0IGJ5dGU0ID0gc3JjW3Bvc2l0aW9uJDErK10gJiAweDNmO1xuXHRcdFx0bGV0IHVuaXQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwYykgfCAoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmICh1bml0ID4gMHhmZmZmKSB7XG5cdFx0XHRcdHVuaXQgLT0gMHgxMDAwMDtcblx0XHRcdFx0dW5pdHMucHVzaCgoKHVuaXQgPj4+IDEwKSAmIDB4M2ZmKSB8IDB4ZDgwMCk7XG5cdFx0XHRcdHVuaXQgPSAweGRjMDAgfCAodW5pdCAmIDB4M2ZmKTtcblx0XHRcdH1cblx0XHRcdHVuaXRzLnB1c2godW5pdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHVuaXRzLnB1c2goYnl0ZTEpO1xuXHRcdH1cblxuXHRcdGlmICh1bml0cy5sZW5ndGggPj0gMHgxMDAwKSB7XG5cdFx0XHRyZXN1bHQgKz0gZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgdW5pdHMpO1xuXHRcdFx0dW5pdHMubGVuZ3RoID0gMDtcblx0XHR9XG5cdH1cblxuXHRpZiAodW5pdHMubGVuZ3RoID4gMCkge1xuXHRcdHJlc3VsdCArPSBmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB1bml0cyk7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0XG59XG5mdW5jdGlvbiByZWFkU3RyaW5nKHNvdXJjZSwgc3RhcnQsIGxlbmd0aCkge1xuXHRsZXQgZXhpc3RpbmdTcmMgPSBzcmM7XG5cdHNyYyA9IHNvdXJjZTtcblx0cG9zaXRpb24kMSA9IHN0YXJ0O1xuXHR0cnkge1xuXHRcdHJldHVybiByZWFkU3RyaW5nSlMobGVuZ3RoKTtcblx0fSBmaW5hbGx5IHtcblx0XHRzcmMgPSBleGlzdGluZ1NyYztcblx0fVxufVxuXG5mdW5jdGlvbiByZWFkQXJyYXkobGVuZ3RoKSB7XG5cdGxldCBhcnJheSA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0YXJyYXlbaV0gPSByZWFkKCk7XG5cdH1cblx0aWYgKGN1cnJlbnRVbnBhY2tyLmZyZWV6ZURhdGEpXG5cdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoYXJyYXkpXG5cdHJldHVybiBhcnJheVxufVxuXG5mdW5jdGlvbiByZWFkTWFwKGxlbmd0aCkge1xuXHRpZiAoY3VycmVudFVucGFja3IubWFwc0FzT2JqZWN0cykge1xuXHRcdGxldCBvYmplY3QgPSB7fTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQga2V5ID0gcmVhZEtleSgpO1xuXHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycpXG5cdFx0XHRcdGtleSA9ICdfX3Byb3RvXyc7XG5cdFx0XHRvYmplY3Rba2V5XSA9IHJlYWQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG9iamVjdFxuXHR9IGVsc2Uge1xuXHRcdGxldCBtYXAgPSBuZXcgTWFwKCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0bWFwLnNldChyZWFkKCksIHJlYWQoKSk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxufVxuXG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbmZ1bmN0aW9uIGxvbmdTdHJpbmdJbkpTKGxlbmd0aCkge1xuXHRsZXQgc3RhcnQgPSBwb3NpdGlvbiQxO1xuXHRsZXQgYnl0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGJ5dGUgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRpZiAoKGJ5dGUgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24kMSA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGJ5dGVzW2ldID0gYnl0ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGJ5dGVzKVxufVxuZnVuY3Rpb24gc2hvcnRTdHJpbmdJbkpTKGxlbmd0aCkge1xuXHRpZiAobGVuZ3RoIDwgNCkge1xuXHRcdGlmIChsZW5ndGggPCAyKSB7XG5cdFx0XHRpZiAobGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gJydcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsZXQgYSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRpZiAoKGEgJiAweDgwKSA+IDEpIHtcblx0XHRcdFx0XHRwb3NpdGlvbiQxIC09IDE7XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhKVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgYSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0bGV0IGIgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGlmICgoYSAmIDB4ODApID4gMCB8fCAoYiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxIC09IDI7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDMpXG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYilcblx0XHRcdGxldCBjID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRpZiAoKGMgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24kMSAtPSAzO1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYylcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0bGV0IGEgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRsZXQgYiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGxldCBjID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0bGV0IGQgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRpZiAoKGEgJiAweDgwKSA+IDAgfHwgKGIgJiAweDgwKSA+IDAgfHwgKGMgJiAweDgwKSA+IDAgfHwgKGQgJiAweDgwKSA+IDApIHtcblx0XHRcdHBvc2l0aW9uJDEgLT0gNDtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRpZiAobGVuZ3RoIDwgNikge1xuXHRcdFx0aWYgKGxlbmd0aCA9PT0gNClcblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkKVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBlID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGlmICgoZSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uJDEgLT0gNTtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUpXG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChsZW5ndGggPCA4KSB7XG5cdFx0XHRsZXQgZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0bGV0IGYgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGlmICgoZSAmIDB4ODApID4gMCB8fCAoZiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxIC09IDY7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDcpXG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZilcblx0XHRcdGxldCBnID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRpZiAoKGcgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24kMSAtPSA3O1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZylcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGUgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGxldCBmID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRsZXQgZyA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0bGV0IGggPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGlmICgoZSAmIDB4ODApID4gMCB8fCAoZiAmIDB4ODApID4gMCB8fCAoZyAmIDB4ODApID4gMCB8fCAoaCAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxIC09IDg7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDEwKSB7XG5cdFx0XHRcdGlmIChsZW5ndGggPT09IDgpXG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRsZXQgaSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRcdGlmICgoaSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24kMSAtPSA5O1xuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSlcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAxMikge1xuXHRcdFx0XHRsZXQgaSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRsZXQgaiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRpZiAoKGkgJiAweDgwKSA+IDAgfHwgKGogJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRwb3NpdGlvbiQxIC09IDEwO1xuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsZW5ndGggPCAxMSlcblx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGopXG5cdFx0XHRcdGxldCBrID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGlmICgoayAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uJDEgLT0gMTE7XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IGkgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0bGV0IGogPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0bGV0IGsgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0bGV0IGwgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0aWYgKChpICYgMHg4MCkgPiAwIHx8IChqICYgMHg4MCkgPiAwIHx8IChrICYgMHg4MCkgPiAwIHx8IChsICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24kMSAtPSAxMjtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGVuZ3RoIDwgMTQpIHtcblx0XHRcdFx0XHRpZiAobGVuZ3RoID09PSAxMilcblx0XHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbClcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGxldCBtID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdFx0XHRpZiAoKG0gJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24kMSAtPSAxMztcblx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCBtID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdFx0bGV0IG4gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0XHRpZiAoKG0gJiAweDgwKSA+IDAgfHwgKG4gJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uJDEgLT0gMTQ7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGxlbmd0aCA8IDE1KVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuKVxuXHRcdFx0XHRcdGxldCBvID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdFx0aWYgKChvICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiQxIC09IDE1O1xuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSwgbiwgbylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZWFkT25seUpTU3RyaW5nKCkge1xuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0bGV0IGxlbmd0aDtcblx0aWYgKHRva2VuIDwgMHhjMCkge1xuXHRcdC8vIGZpeHN0clxuXHRcdGxlbmd0aCA9IHRva2VuIC0gMHhhMDtcblx0fSBlbHNlIHtcblx0XHRzd2l0Y2godG9rZW4pIHtcblx0XHRcdGNhc2UgMHhkOTpcblx0XHRcdC8vIHN0ciA4XG5cdFx0XHRcdGxlbmd0aCA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAweGRhOlxuXHRcdFx0Ly8gc3RyIDE2XG5cdFx0XHRcdGxlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSAyO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAweGRiOlxuXHRcdFx0Ly8gc3RyIDMyXG5cdFx0XHRcdGxlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRicmVha1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzdHJpbmcnKVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZFN0cmluZ0pTKGxlbmd0aClcbn1cblxuXG5mdW5jdGlvbiByZWFkQmluKGxlbmd0aCkge1xuXHRyZXR1cm4gY3VycmVudFVucGFja3IuY29weUJ1ZmZlcnMgP1xuXHRcdC8vIHNwZWNpZmljYWxseSB1c2UgdGhlIGNvcHlpbmcgc2xpY2UgKG5vdCB0aGUgbm9kZSBvbmUpXG5cdFx0VWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzcmMsIHBvc2l0aW9uJDEsIHBvc2l0aW9uJDEgKz0gbGVuZ3RoKSA6XG5cdFx0c3JjLnN1YmFycmF5KHBvc2l0aW9uJDEsIHBvc2l0aW9uJDEgKz0gbGVuZ3RoKVxufVxuZnVuY3Rpb24gcmVhZEV4dChsZW5ndGgpIHtcblx0bGV0IHR5cGUgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0aWYgKGN1cnJlbnRFeHRlbnNpb25zW3R5cGVdKSB7XG5cdFx0bGV0IGVuZDtcblx0XHRyZXR1cm4gY3VycmVudEV4dGVuc2lvbnNbdHlwZV0oc3JjLnN1YmFycmF5KHBvc2l0aW9uJDEsIGVuZCA9IChwb3NpdGlvbiQxICs9IGxlbmd0aCkpLCAocmVhZFBvc2l0aW9uKSA9PiB7XG5cdFx0XHRwb3NpdGlvbiQxID0gcmVhZFBvc2l0aW9uO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIHJlYWQoKTtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgPSBlbmQ7XG5cdFx0XHR9XG5cdFx0fSlcblx0fVxuXHRlbHNlXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGV4dGVuc2lvbiB0eXBlICcgKyB0eXBlKVxufVxuXG52YXIga2V5Q2FjaGUgPSBuZXcgQXJyYXkoNDA5Nik7XG5mdW5jdGlvbiByZWFkS2V5KCkge1xuXHRsZXQgbGVuZ3RoID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdGlmIChsZW5ndGggPj0gMHhhMCAmJiBsZW5ndGggPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyLCBwb3RlbnRpYWxseSB1c2Uga2V5IGNhY2hlXG5cdFx0bGVuZ3RoID0gbGVuZ3RoIC0gMHhhMDtcblx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uJDEpIC8vIGlmIGl0IGhhcyBiZWVuIGV4dHJhY3RlZCwgbXVzdCB1c2UgaXQgKGFuZCBmYXN0ZXIgYW55d2F5KVxuXHRcdFx0cmV0dXJuIHNyY1N0cmluZy5zbGljZShwb3NpdGlvbiQxIC0gc3JjU3RyaW5nU3RhcnQsIChwb3NpdGlvbiQxICs9IGxlbmd0aCkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRlbHNlIGlmICghKHNyY1N0cmluZ0VuZCA9PSAwICYmIHNyY0VuZCA8IDE4MCkpXG5cdFx0XHRyZXR1cm4gcmVhZEZpeGVkU3RyaW5nKGxlbmd0aClcblx0fSBlbHNlIHsgLy8gbm90IGNhY2hlYWJsZSwgZ28gYmFjayBhbmQgZG8gYSBzdGFuZGFyZCByZWFkXG5cdFx0cG9zaXRpb24kMS0tO1xuXHRcdHJldHVybiBhc1NhZmVTdHJpbmcocmVhZCgpKVxuXHR9XG5cdGxldCBrZXkgPSAoKGxlbmd0aCA8PCA1KSBeIChsZW5ndGggPiAxID8gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpIDogbGVuZ3RoID4gMCA/IHNyY1twb3NpdGlvbiQxXSA6IDApKSAmIDB4ZmZmO1xuXHRsZXQgZW50cnkgPSBrZXlDYWNoZVtrZXldO1xuXHRsZXQgY2hlY2tQb3NpdGlvbiA9IHBvc2l0aW9uJDE7XG5cdGxldCBlbmQgPSBwb3NpdGlvbiQxICsgbGVuZ3RoIC0gMztcblx0bGV0IGNodW5rO1xuXHRsZXQgaSA9IDA7XG5cdGlmIChlbnRyeSAmJiBlbnRyeS5ieXRlcyA9PSBsZW5ndGgpIHtcblx0XHR3aGlsZSAoY2hlY2tQb3NpdGlvbiA8IGVuZCkge1xuXHRcdFx0Y2h1bmsgPSBkYXRhVmlldy5nZXRVaW50MzIoY2hlY2tQb3NpdGlvbik7XG5cdFx0XHRpZiAoY2h1bmsgIT0gZW50cnlbaSsrXSkge1xuXHRcdFx0XHRjaGVja1Bvc2l0aW9uID0gMHg3MDAwMDAwMDtcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHRcdGNoZWNrUG9zaXRpb24gKz0gNDtcblx0XHR9XG5cdFx0ZW5kICs9IDM7XG5cdFx0d2hpbGUgKGNoZWNrUG9zaXRpb24gPCBlbmQpIHtcblx0XHRcdGNodW5rID0gc3JjW2NoZWNrUG9zaXRpb24rK107XG5cdFx0XHRpZiAoY2h1bmsgIT0gZW50cnlbaSsrXSkge1xuXHRcdFx0XHRjaGVja1Bvc2l0aW9uID0gMHg3MDAwMDAwMDtcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNoZWNrUG9zaXRpb24gPT09IGVuZCkge1xuXHRcdFx0cG9zaXRpb24kMSA9IGNoZWNrUG9zaXRpb247XG5cdFx0XHRyZXR1cm4gZW50cnkuc3RyaW5nXG5cdFx0fVxuXHRcdGVuZCAtPSAzO1xuXHRcdGNoZWNrUG9zaXRpb24gPSBwb3NpdGlvbiQxO1xuXHR9XG5cdGVudHJ5ID0gW107XG5cdGtleUNhY2hlW2tleV0gPSBlbnRyeTtcblx0ZW50cnkuYnl0ZXMgPSBsZW5ndGg7XG5cdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y2h1bmsgPSBkYXRhVmlldy5nZXRVaW50MzIoY2hlY2tQb3NpdGlvbik7XG5cdFx0ZW50cnkucHVzaChjaHVuayk7XG5cdFx0Y2hlY2tQb3NpdGlvbiArPSA0O1xuXHR9XG5cdGVuZCArPSAzO1xuXHR3aGlsZSAoY2hlY2tQb3NpdGlvbiA8IGVuZCkge1xuXHRcdGNodW5rID0gc3JjW2NoZWNrUG9zaXRpb24rK107XG5cdFx0ZW50cnkucHVzaChjaHVuayk7XG5cdH1cblx0Ly8gZm9yIHNtYWxsIGJsb2NrcywgYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSBleHRyYWN0IGNhbGwgaXMgaGVscGZ1bFxuXHRsZXQgc3RyaW5nID0gbGVuZ3RoIDwgMTYgPyBzaG9ydFN0cmluZ0luSlMobGVuZ3RoKSA6IGxvbmdTdHJpbmdJbkpTKGxlbmd0aCk7XG5cdGlmIChzdHJpbmcgIT0gbnVsbClcblx0XHRyZXR1cm4gZW50cnkuc3RyaW5nID0gc3RyaW5nXG5cdHJldHVybiBlbnRyeS5zdHJpbmcgPSByZWFkRml4ZWRTdHJpbmcobGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc1NhZmVTdHJpbmcocHJvcGVydHkpIHtcblx0Ly8gcHJvdGVjdCBhZ2FpbnN0IGV4cGVuc2l2ZSAoRG9TKSBzdHJpbmcgY29udmVyc2lvbnNcblx0aWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycpIHJldHVybiBwcm9wZXJ0eTtcblx0aWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BlcnR5ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHByb3BlcnR5ID09PSAnYmlnaW50JykgcmV0dXJuIHByb3BlcnR5LnRvU3RyaW5nKCk7XG5cdGlmIChwcm9wZXJ0eSA9PSBudWxsKSByZXR1cm4gcHJvcGVydHkgKyAnJztcblx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByb3BlcnR5IHR5cGUgZm9yIHJlY29yZCcsIHR5cGVvZiBwcm9wZXJ0eSk7XG59XG4vLyB0aGUgcmVnaXN0cmF0aW9uIG9mIHRoZSByZWNvcmQgZGVmaW5pdGlvbiBleHRlbnNpb24gKGFzIFwiclwiKVxuY29uc3QgcmVjb3JkRGVmaW5pdGlvbiA9IChpZCwgaGlnaEJ5dGUpID0+IHtcblx0bGV0IHN0cnVjdHVyZSA9IHJlYWQoKS5tYXAoYXNTYWZlU3RyaW5nKTsgLy8gZW5zdXJlIHRoYXQgYWxsIGtleXMgYXJlIHN0cmluZ3MgYW5kXG5cdC8vIHRoYXQgdGhlIGFycmF5IGlzIG11dGFibGVcblx0bGV0IGZpcnN0Qnl0ZSA9IGlkO1xuXHRpZiAoaGlnaEJ5dGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlkID0gaWQgPCAzMiA/IC0oKGhpZ2hCeXRlIDw8IDUpICsgaWQpIDogKChoaWdoQnl0ZSA8PCA1KSArIGlkKTtcblx0XHRzdHJ1Y3R1cmUuaGlnaEJ5dGUgPSBoaWdoQnl0ZTtcblx0fVxuXHRsZXQgZXhpc3RpbmdTdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1tpZF07XG5cdC8vIElmIGl0IGlzIGEgc2hhcmVkIHN0cnVjdHVyZSwgd2UgbmVlZCB0byByZXN0b3JlIGFueSBjaGFuZ2VzIGFmdGVyIHJlYWRpbmcuXG5cdC8vIEFsc28gaW4gc2VxdWVudGlhbCBtb2RlLCB3ZSBtYXkgZ2V0IGluY29tcGxldGUgcmVhZHMgYW5kIHRodXMgZXJyb3JzLCBhbmQgd2UgbmVlZCB0byByZXN0b3JlXG5cdC8vIHRvIHRoZSBzdGF0ZSBwcmlvciB0byBhbiBpbmNvbXBsZXRlIHJlYWQgaW4gb3JkZXIgdG8gcHJvcGVybHkgcmVzdW1lLlxuXHRpZiAoZXhpc3RpbmdTdHJ1Y3R1cmUgJiYgKGV4aXN0aW5nU3RydWN0dXJlLmlzU2hhcmVkIHx8IHNlcXVlbnRpYWxNb2RlKSkge1xuXHRcdChjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyB8fCAoY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBbXSkpW2lkXSA9IGV4aXN0aW5nU3RydWN0dXJlO1xuXHR9XG5cdGN1cnJlbnRTdHJ1Y3R1cmVzW2lkXSA9IHN0cnVjdHVyZTtcblx0c3RydWN0dXJlLnJlYWQgPSBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlLCBmaXJzdEJ5dGUpO1xuXHRyZXR1cm4gc3RydWN0dXJlLnJlYWQoKVxufTtcbmN1cnJlbnRFeHRlbnNpb25zWzBdID0gKCkgPT4ge307IC8vIG5vdGVwYWNrIGRlZmluZXMgZXh0ZW5zaW9uIDAgdG8gbWVhbiB1bmRlZmluZWQsIHNvIHVzZSB0aGF0IGFzIHRoZSBkZWZhdWx0IGhlcmVcbmN1cnJlbnRFeHRlbnNpb25zWzBdLm5vQnVmZmVyID0gdHJ1ZTtcblxuY3VycmVudEV4dGVuc2lvbnNbMHg0Ml0gPSAoZGF0YSkgPT4ge1xuXHQvLyBkZWNvZGUgYmlnaW50XG5cdGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblx0bGV0IHZhbHVlID0gQmlnSW50KGRhdGFbMF0gJiAweDgwID8gZGF0YVswXSAtIDB4MTAwIDogZGF0YVswXSk7XG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHR2YWx1ZSA8PD0gOG47XG5cdFx0dmFsdWUgKz0gQmlnSW50KGRhdGFbaV0pO1xuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbmxldCBlcnJvcnMgPSB7IEVycm9yLCBUeXBlRXJyb3IsIFJlZmVyZW5jZUVycm9yIH07XG5jdXJyZW50RXh0ZW5zaW9uc1sweDY1XSA9ICgpID0+IHtcblx0bGV0IGRhdGEgPSByZWFkKCk7XG5cdHJldHVybiAoZXJyb3JzW2RhdGFbMF1dIHx8IEVycm9yKShkYXRhWzFdLCB7IGNhdXNlOiBkYXRhWzJdIH0pXG59O1xuXG5jdXJyZW50RXh0ZW5zaW9uc1sweDY5XSA9IChkYXRhKSA9PiB7XG5cdC8vIGlkIGV4dGVuc2lvbiAoZm9yIHN0cnVjdHVyZWQgY2xvbmVzKVxuXHRpZiAoY3VycmVudFVucGFja3Iuc3RydWN0dXJlZENsb25lID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKCdTdHJ1Y3R1cmVkIGNsb25lIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCcpXG5cdGxldCBpZCA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiQxIC0gNCk7XG5cdGlmICghcmVmZXJlbmNlTWFwKVxuXHRcdHJlZmVyZW5jZU1hcCA9IG5ldyBNYXAoKTtcblx0bGV0IHRva2VuID0gc3JjW3Bvc2l0aW9uJDFdO1xuXHRsZXQgdGFyZ2V0O1xuXHQvLyBUT0RPOiBoYW5kbGUgTWFwcywgU2V0cywgYW5kIG90aGVyIHR5cGVzIHRoYXQgY2FuIGN5Y2xlOyB0aGlzIGlzIGNvbXBsaWNhdGVkLCBiZWNhdXNlIHlvdSBwb3RlbnRpYWxseSBuZWVkIHRvIHJlYWRcblx0Ly8gYWhlYWQgcGFzdCByZWZlcmVuY2VzIHRvIHJlY29yZCBzdHJ1Y3R1cmUgZGVmaW5pdGlvbnNcblx0aWYgKHRva2VuID49IDB4OTAgJiYgdG9rZW4gPCAweGEwIHx8IHRva2VuID09IDB4ZGMgfHwgdG9rZW4gPT0gMHhkZClcblx0XHR0YXJnZXQgPSBbXTtcblx0ZWxzZVxuXHRcdHRhcmdldCA9IHt9O1xuXG5cdGxldCByZWZFbnRyeSA9IHsgdGFyZ2V0IH07IC8vIGEgcGxhY2Vob2xkZXIgb2JqZWN0XG5cdHJlZmVyZW5jZU1hcC5zZXQoaWQsIHJlZkVudHJ5KTtcblx0bGV0IHRhcmdldFByb3BlcnRpZXMgPSByZWFkKCk7IC8vIHJlYWQgdGhlIG5leHQgdmFsdWUgYXMgdGhlIHRhcmdldCBvYmplY3QgdG8gaWRcblx0aWYgKHJlZkVudHJ5LnVzZWQpIC8vIHRoZXJlIGlzIGEgY3ljbGUsIHNvIHdlIGhhdmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gb3JpZ2luYWwgdGFyZ2V0XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB0YXJnZXRQcm9wZXJ0aWVzKVxuXHRyZWZFbnRyeS50YXJnZXQgPSB0YXJnZXRQcm9wZXJ0aWVzOyAvLyB0aGUgcGxhY2Vob2xkZXIgd2Fzbid0IHVzZWQsIHJlcGxhY2Ugd2l0aCB0aGUgZGVzZXJpYWxpemVkIG9uZVxuXHRyZXR1cm4gdGFyZ2V0UHJvcGVydGllcyAvLyBubyBjeWNsZSwgY2FuIGp1c3QgdXNlIHRoZSByZXR1cm5lZCByZWFkIG9iamVjdFxufTtcblxuY3VycmVudEV4dGVuc2lvbnNbMHg3MF0gPSAoZGF0YSkgPT4ge1xuXHQvLyBwb2ludGVyIGV4dGVuc2lvbiAoZm9yIHN0cnVjdHVyZWQgY2xvbmVzKVxuXHRpZiAoY3VycmVudFVucGFja3Iuc3RydWN0dXJlZENsb25lID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKCdTdHJ1Y3R1cmVkIGNsb25lIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCcpXG5cdGxldCBpZCA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiQxIC0gNCk7XG5cdGxldCByZWZFbnRyeSA9IHJlZmVyZW5jZU1hcC5nZXQoaWQpO1xuXHRyZWZFbnRyeS51c2VkID0gdHJ1ZTtcblx0cmV0dXJuIHJlZkVudHJ5LnRhcmdldFxufTtcblxuY3VycmVudEV4dGVuc2lvbnNbMHg3M10gPSAoKSA9PiBuZXcgU2V0KHJlYWQoKSk7XG5cbmNvbnN0IHR5cGVkQXJyYXlzID0gWydJbnQ4JywnVWludDgnLCdVaW50OENsYW1wZWQnLCdJbnQxNicsJ1VpbnQxNicsJ0ludDMyJywnVWludDMyJywnRmxvYXQzMicsJ0Zsb2F0NjQnLCdCaWdJbnQ2NCcsJ0JpZ1VpbnQ2NCddLm1hcCh0eXBlID0+IHR5cGUgKyAnQXJyYXknKTtcblxubGV0IGdsYmwgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgPyBnbG9iYWxUaGlzIDogd2luZG93O1xuY3VycmVudEV4dGVuc2lvbnNbMHg3NF0gPSAoZGF0YSkgPT4ge1xuXHRsZXQgdHlwZUNvZGUgPSBkYXRhWzBdO1xuXHRsZXQgdHlwZWRBcnJheU5hbWUgPSB0eXBlZEFycmF5c1t0eXBlQ29kZV07XG5cdGlmICghdHlwZWRBcnJheU5hbWUpIHtcblx0XHRpZiAodHlwZUNvZGUgPT09IDE2KSB7XG5cdFx0XHRsZXQgYWIgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YS5sZW5ndGggLSAxKTtcblx0XHRcdGxldCB1OCA9IG5ldyBVaW50OEFycmF5KGFiKTtcblx0XHRcdHU4LnNldChkYXRhLnN1YmFycmF5KDEpKTtcblx0XHRcdHJldHVybiBhYjtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0eXBlZCBhcnJheSBmb3IgY29kZSAnICsgdHlwZUNvZGUpXG5cdH1cblx0Ly8gd2UgaGF2ZSB0byBhbHdheXMgc2xpY2UvY29weSBoZXJlIHRvIGdldCBhIG5ldyBBcnJheUJ1ZmZlciB0aGF0IGlzIHdvcmQvYnl0ZSBhbGlnbmVkXG5cdHJldHVybiBuZXcgZ2xibFt0eXBlZEFycmF5TmFtZV0oVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhLCAxKS5idWZmZXIpXG59O1xuY3VycmVudEV4dGVuc2lvbnNbMHg3OF0gPSAoKSA9PiB7XG5cdGxldCBkYXRhID0gcmVhZCgpO1xuXHRyZXR1cm4gbmV3IFJlZ0V4cChkYXRhWzBdLCBkYXRhWzFdKVxufTtcbmNvbnN0IFRFTVBfQlVORExFID0gW107XG5jdXJyZW50RXh0ZW5zaW9uc1sweDYyXSA9IChkYXRhKSA9PiB7XG5cdGxldCBkYXRhU2l6ZSA9IChkYXRhWzBdIDw8IDI0KSArIChkYXRhWzFdIDw8IDE2KSArIChkYXRhWzJdIDw8IDgpICsgZGF0YVszXTtcblx0bGV0IGRhdGFQb3NpdGlvbiA9IHBvc2l0aW9uJDE7XG5cdHBvc2l0aW9uJDEgKz0gZGF0YVNpemUgLSBkYXRhLmxlbmd0aDtcblx0YnVuZGxlZFN0cmluZ3MkMSA9IFRFTVBfQlVORExFO1xuXHRidW5kbGVkU3RyaW5ncyQxID0gW3JlYWRPbmx5SlNTdHJpbmcoKSwgcmVhZE9ubHlKU1N0cmluZygpXTtcblx0YnVuZGxlZFN0cmluZ3MkMS5wb3NpdGlvbjAgPSAwO1xuXHRidW5kbGVkU3RyaW5ncyQxLnBvc2l0aW9uMSA9IDA7XG5cdGJ1bmRsZWRTdHJpbmdzJDEucG9zdEJ1bmRsZVBvc2l0aW9uID0gcG9zaXRpb24kMTtcblx0cG9zaXRpb24kMSA9IGRhdGFQb3NpdGlvbjtcblx0cmV0dXJuIHJlYWQoKVxufTtcblxuY3VycmVudEV4dGVuc2lvbnNbMHhmZl0gPSAoZGF0YSkgPT4ge1xuXHQvLyAzMi1iaXQgZGF0ZSBleHRlbnNpb25cblx0aWYgKGRhdGEubGVuZ3RoID09IDQpXG5cdFx0cmV0dXJuIG5ldyBEYXRlKChkYXRhWzBdICogMHgxMDAwMDAwICsgKGRhdGFbMV0gPDwgMTYpICsgKGRhdGFbMl0gPDwgOCkgKyBkYXRhWzNdKSAqIDEwMDApXG5cdGVsc2UgaWYgKGRhdGEubGVuZ3RoID09IDgpXG5cdFx0cmV0dXJuIG5ldyBEYXRlKFxuXHRcdFx0KChkYXRhWzBdIDw8IDIyKSArIChkYXRhWzFdIDw8IDE0KSArIChkYXRhWzJdIDw8IDYpICsgKGRhdGFbM10gPj4gMikpIC8gMTAwMDAwMCArXG5cdFx0XHQoKGRhdGFbM10gJiAweDMpICogMHgxMDAwMDAwMDAgKyBkYXRhWzRdICogMHgxMDAwMDAwICsgKGRhdGFbNV0gPDwgMTYpICsgKGRhdGFbNl0gPDwgOCkgKyBkYXRhWzddKSAqIDEwMDApXG5cdGVsc2UgaWYgKGRhdGEubGVuZ3RoID09IDEyKS8vIFRPRE86IEltcGxlbWVudCBzdXBwb3J0IGZvciBuZWdhdGl2ZVxuXHRcdHJldHVybiBuZXcgRGF0ZShcblx0XHRcdCgoZGF0YVswXSA8PCAyNCkgKyAoZGF0YVsxXSA8PCAxNikgKyAoZGF0YVsyXSA8PCA4KSArIGRhdGFbM10pIC8gMTAwMDAwMCArXG5cdFx0XHQoKChkYXRhWzRdICYgMHg4MCkgPyAtMHgxMDAwMDAwMDAwMDAwIDogMCkgKyBkYXRhWzZdICogMHgxMDAwMDAwMDAwMCArIGRhdGFbN10gKiAweDEwMDAwMDAwMCArIGRhdGFbOF0gKiAweDEwMDAwMDAgKyAoZGF0YVs5XSA8PCAxNikgKyAoZGF0YVsxMF0gPDwgOCkgKyBkYXRhWzExXSkgKiAxMDAwKVxuXHRlbHNlXG5cdFx0cmV0dXJuIG5ldyBEYXRlKCdpbnZhbGlkJylcbn07IC8vIG5vdGVwYWNrIGRlZmluZXMgZXh0ZW5zaW9uIDAgdG8gbWVhbiB1bmRlZmluZWQsIHNvIHVzZSB0aGF0IGFzIHRoZSBkZWZhdWx0IGhlcmVcbi8vIHJlZ2lzdHJhdGlvbiBvZiBidWxrIHJlY29yZCBkZWZpbml0aW9uP1xuLy8gY3VycmVudEV4dGVuc2lvbnNbMHg1Ml0gPSAoKSA9PlxuXG5mdW5jdGlvbiBzYXZlU3RhdGUkMShjYWxsYmFjaykge1xuXHRpZiAob25TYXZlU3RhdGUpXG5cdFx0b25TYXZlU3RhdGUoKTtcblx0bGV0IHNhdmVkU3JjRW5kID0gc3JjRW5kO1xuXHRsZXQgc2F2ZWRQb3NpdGlvbiA9IHBvc2l0aW9uJDE7XG5cdGxldCBzYXZlZFN0cmluZ1Bvc2l0aW9uID0gc3RyaW5nUG9zaXRpb247XG5cdGxldCBzYXZlZFNyY1N0cmluZ1N0YXJ0ID0gc3JjU3RyaW5nU3RhcnQ7XG5cdGxldCBzYXZlZFNyY1N0cmluZ0VuZCA9IHNyY1N0cmluZ0VuZDtcblx0bGV0IHNhdmVkU3JjU3RyaW5nID0gc3JjU3RyaW5nO1xuXHRsZXQgc2F2ZWRTdHJpbmdzID0gc3RyaW5ncztcblx0bGV0IHNhdmVkUmVmZXJlbmNlTWFwID0gcmVmZXJlbmNlTWFwO1xuXHRsZXQgc2F2ZWRCdW5kbGVkU3RyaW5ncyA9IGJ1bmRsZWRTdHJpbmdzJDE7XG5cblx0Ly8gVE9ETzogV2UgbWF5IG5lZWQgdG8gcmV2aXNpdCB0aGlzIGlmIHdlIGRvIG1vcmUgZXh0ZXJuYWwgY2FsbHMgdG8gdXNlciBjb2RlIChzaW5jZSBpdCBjb3VsZCBiZSBzbG93KVxuXHRsZXQgc2F2ZWRTcmMgPSBuZXcgVWludDhBcnJheShzcmMuc2xpY2UoMCwgc3JjRW5kKSk7IC8vIHdlIGNvcHkgdGhlIGRhdGEgaW4gY2FzZSBpdCBjaGFuZ2VzIHdoaWxlIGV4dGVybmFsIGRhdGEgaXMgcHJvY2Vzc2VkXG5cdGxldCBzYXZlZFN0cnVjdHVyZXMgPSBjdXJyZW50U3RydWN0dXJlcztcblx0bGV0IHNhdmVkU3RydWN0dXJlc0NvbnRlbnRzID0gY3VycmVudFN0cnVjdHVyZXMuc2xpY2UoMCwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoKTtcblx0bGV0IHNhdmVkUGFja3IgPSBjdXJyZW50VW5wYWNrcjtcblx0bGV0IHNhdmVkU2VxdWVudGlhbE1vZGUgPSBzZXF1ZW50aWFsTW9kZTtcblx0bGV0IHZhbHVlID0gY2FsbGJhY2soKTtcblx0c3JjRW5kID0gc2F2ZWRTcmNFbmQ7XG5cdHBvc2l0aW9uJDEgPSBzYXZlZFBvc2l0aW9uO1xuXHRzdHJpbmdQb3NpdGlvbiA9IHNhdmVkU3RyaW5nUG9zaXRpb247XG5cdHNyY1N0cmluZ1N0YXJ0ID0gc2F2ZWRTcmNTdHJpbmdTdGFydDtcblx0c3JjU3RyaW5nRW5kID0gc2F2ZWRTcmNTdHJpbmdFbmQ7XG5cdHNyY1N0cmluZyA9IHNhdmVkU3JjU3RyaW5nO1xuXHRzdHJpbmdzID0gc2F2ZWRTdHJpbmdzO1xuXHRyZWZlcmVuY2VNYXAgPSBzYXZlZFJlZmVyZW5jZU1hcDtcblx0YnVuZGxlZFN0cmluZ3MkMSA9IHNhdmVkQnVuZGxlZFN0cmluZ3M7XG5cdHNyYyA9IHNhdmVkU3JjO1xuXHRzZXF1ZW50aWFsTW9kZSA9IHNhdmVkU2VxdWVudGlhbE1vZGU7XG5cdGN1cnJlbnRTdHJ1Y3R1cmVzID0gc2F2ZWRTdHJ1Y3R1cmVzO1xuXHRjdXJyZW50U3RydWN0dXJlcy5zcGxpY2UoMCwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoLCAuLi5zYXZlZFN0cnVjdHVyZXNDb250ZW50cyk7XG5cdGN1cnJlbnRVbnBhY2tyID0gc2F2ZWRQYWNrcjtcblx0ZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKTtcblx0cmV0dXJuIHZhbHVlXG59XG5mdW5jdGlvbiBjbGVhclNvdXJjZSgpIHtcblx0c3JjID0gbnVsbDtcblx0cmVmZXJlbmNlTWFwID0gbnVsbDtcblx0Y3VycmVudFN0cnVjdHVyZXMgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZGRFeHRlbnNpb24kMShleHRlbnNpb24pIHtcblx0aWYgKGV4dGVuc2lvbi51bnBhY2spXG5cdFx0Y3VycmVudEV4dGVuc2lvbnNbZXh0ZW5zaW9uLnR5cGVdID0gZXh0ZW5zaW9uLnVucGFjaztcblx0ZWxzZVxuXHRcdGN1cnJlbnRFeHRlbnNpb25zW2V4dGVuc2lvbi50eXBlXSA9IGV4dGVuc2lvbjtcbn1cblxuY29uc3QgbXVsdDEwID0gbmV3IEFycmF5KDE0Nyk7IC8vIHRoaXMgaXMgYSB0YWJsZSBtYXRjaGluZyBiaW5hcnkgZXhwb25lbnRzIHRvIHRoZSBtdWx0aXBsaWVyIHRvIGRldGVybWluZSBzaWduaWZpY2FudCBkaWdpdCByb3VuZGluZ1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHRtdWx0MTBbaV0gPSArKCcxZScgKyBNYXRoLmZsb29yKDQ1LjE1IC0gaSAqIDAuMzAxMDMpKTtcbn1cbmNvbnN0IERlY29kZXIgPSBVbnBhY2tyO1xudmFyIGRlZmF1bHRVbnBhY2tyID0gbmV3IFVucGFja3IoeyB1c2VSZWNvcmRzOiBmYWxzZSB9KTtcbmNvbnN0IHVucGFjayA9IGRlZmF1bHRVbnBhY2tyLnVucGFjaztcbmNvbnN0IHVucGFja011bHRpcGxlID0gZGVmYXVsdFVucGFja3IudW5wYWNrTXVsdGlwbGU7XG5jb25zdCBkZWNvZGUgPSBkZWZhdWx0VW5wYWNrci51bnBhY2s7XG5jb25zdCBGTE9BVDMyX09QVElPTlMgPSB7XG5cdE5FVkVSOiAwLFxuXHRBTFdBWVM6IDEsXG5cdERFQ0lNQUxfUk9VTkQ6IDMsXG5cdERFQ0lNQUxfRklUOiA0XG59O1xubGV0IGYzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbmxldCB1OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZjMyQXJyYXkuYnVmZmVyLCAwLCA0KTtcbmZ1bmN0aW9uIHJvdW5kRmxvYXQzMihmbG9hdDMyTnVtYmVyKSB7XG5cdGYzMkFycmF5WzBdID0gZmxvYXQzMk51bWJlcjtcblx0bGV0IG11bHRpcGxpZXIgPSBtdWx0MTBbKCh1OEFycmF5WzNdICYgMHg3ZikgPDwgMSkgfCAodThBcnJheVsyXSA+PiA3KV07XG5cdHJldHVybiAoKG11bHRpcGxpZXIgKiBmbG9hdDMyTnVtYmVyICsgKGZsb2F0MzJOdW1iZXIgPiAwID8gMC41IDogLTAuNSkpID4+IDApIC8gbXVsdGlwbGllclxufVxuZnVuY3Rpb24gc2V0UmVhZFN0cnVjdCh1cGRhdGVkUmVhZFN0cnVjdCwgbG9hZGVkU3RydWN0cywgc2F2ZVN0YXRlKSB7XG5cdHJlYWRTdHJ1Y3QkMSA9IHVwZGF0ZWRSZWFkU3RydWN0O1xuXHRvbkxvYWRlZFN0cnVjdHVyZXMkMSA9IGxvYWRlZFN0cnVjdHM7XG5cdG9uU2F2ZVN0YXRlID0gc2F2ZVN0YXRlO1xufVxuXG5sZXQgdGV4dEVuY29kZXIkMTtcbnRyeSB7XG5cdHRleHRFbmNvZGVyJDEgPSBuZXcgVGV4dEVuY29kZXIoKTtcbn0gY2F0Y2ggKGVycm9yKSB7fVxubGV0IGV4dGVuc2lvbnMsIGV4dGVuc2lvbkNsYXNzZXM7XG5jb25zdCBoYXNOb2RlQnVmZmVyJDEgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IEJ5dGVBcnJheUFsbG9jYXRlID0gaGFzTm9kZUJ1ZmZlciQxID9cblx0ZnVuY3Rpb24obGVuZ3RoKSB7IHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KGxlbmd0aCkgfSA6IFVpbnQ4QXJyYXk7XG5jb25zdCBCeXRlQXJyYXkgPSBoYXNOb2RlQnVmZmVyJDEgPyBCdWZmZXIgOiBVaW50OEFycmF5O1xuY29uc3QgTUFYX0JVRkZFUl9TSVpFID0gaGFzTm9kZUJ1ZmZlciQxID8gMHgxMDAwMDAwMDAgOiAweDdmZDAwMDAwO1xubGV0IHRhcmdldCwga2V5c1RhcmdldDtcbmxldCB0YXJnZXRWaWV3O1xubGV0IHBvc2l0aW9uID0gMDtcbmxldCBzYWZlRW5kO1xubGV0IGJ1bmRsZWRTdHJpbmdzID0gbnVsbDtcbmxldCB3cml0ZVN0cnVjdFNsb3RzO1xuY29uc3QgTUFYX0JVTkRMRV9TSVpFID0gMHg1NTAwOyAvLyBtYXhpbXVtIGNoYXJhY3RlcnMgc3VjaCB0aGF0IHRoZSBlbmNvZGVkIGJ5dGVzIGZpdHMgaW4gMTYgYml0cy5cbmNvbnN0IGhhc05vbkxhdGluID0gL1tcXHUwMDgwLVxcdUZGRkZdLztcbmNvbnN0IFJFQ09SRF9TWU1CT0wgPSBTeW1ib2woJ3JlY29yZC1pZCcpO1xuY2xhc3MgUGFja3IgZXh0ZW5kcyBVbnBhY2tyIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHRcdHRoaXMub2Zmc2V0ID0gMDtcblx0XHRsZXQgc3RhcnQ7XG5cdFx0bGV0IGhhc1NoYXJlZFVwZGF0ZTtcblx0XHRsZXQgc3RydWN0dXJlcztcblx0XHRsZXQgcmVmZXJlbmNlTWFwO1xuXHRcdGxldCBlbmNvZGVVdGY4ID0gQnl0ZUFycmF5LnByb3RvdHlwZS51dGY4V3JpdGUgPyBmdW5jdGlvbihzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnV0ZjhXcml0ZShzdHJpbmcsIHBvc2l0aW9uLCAweGZmZmZmZmZmKVxuXHRcdH0gOiAodGV4dEVuY29kZXIkMSAmJiB0ZXh0RW5jb2RlciQxLmVuY29kZUludG8pID9cblx0XHRcdGZ1bmN0aW9uKHN0cmluZywgcG9zaXRpb24pIHtcblx0XHRcdFx0cmV0dXJuIHRleHRFbmNvZGVyJDEuZW5jb2RlSW50byhzdHJpbmcsIHRhcmdldC5zdWJhcnJheShwb3NpdGlvbikpLndyaXR0ZW5cblx0XHRcdH0gOiBmYWxzZTtcblxuXHRcdGxldCBwYWNrciA9IHRoaXM7XG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdGxldCBpc1NlcXVlbnRpYWwgPSBvcHRpb25zICYmIG9wdGlvbnMuc2VxdWVudGlhbDtcblx0XHRsZXQgaGFzU2hhcmVkU3RydWN0dXJlcyA9IG9wdGlvbnMuc3RydWN0dXJlcyB8fCBvcHRpb25zLnNhdmVTdHJ1Y3R1cmVzO1xuXHRcdGxldCBtYXhTaGFyZWRTdHJ1Y3R1cmVzID0gb3B0aW9ucy5tYXhTaGFyZWRTdHJ1Y3R1cmVzO1xuXHRcdGlmIChtYXhTaGFyZWRTdHJ1Y3R1cmVzID09IG51bGwpXG5cdFx0XHRtYXhTaGFyZWRTdHJ1Y3R1cmVzID0gaGFzU2hhcmVkU3RydWN0dXJlcyA/IDMyIDogMDtcblx0XHRpZiAobWF4U2hhcmVkU3RydWN0dXJlcyA+IDgxNjApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gbWF4U2hhcmVkU3RydWN0dXJlIGlzIDgxNjAnKVxuXHRcdGlmIChvcHRpb25zLnN0cnVjdHVyZWRDbG9uZSAmJiBvcHRpb25zLm1vcmVUeXBlcyA9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMubW9yZVR5cGVzID0gdHJ1ZTtcblx0XHR9XG5cdFx0bGV0IG1heE93blN0cnVjdHVyZXMgPSBvcHRpb25zLm1heE93blN0cnVjdHVyZXM7XG5cdFx0aWYgKG1heE93blN0cnVjdHVyZXMgPT0gbnVsbClcblx0XHRcdG1heE93blN0cnVjdHVyZXMgPSBoYXNTaGFyZWRTdHJ1Y3R1cmVzID8gMzIgOiA2NDtcblx0XHRpZiAoIXRoaXMuc3RydWN0dXJlcyAmJiBvcHRpb25zLnVzZVJlY29yZHMgIT0gZmFsc2UpXG5cdFx0XHR0aGlzLnN0cnVjdHVyZXMgPSBbXTtcblx0XHQvLyB0d28gYnl0ZSByZWNvcmQgaWRzIGZvciBzaGFyZWQgc3RydWN0dXJlc1xuXHRcdGxldCB1c2VUd29CeXRlUmVjb3JkcyA9IG1heFNoYXJlZFN0cnVjdHVyZXMgPiAzMiB8fCAobWF4T3duU3RydWN0dXJlcyArIG1heFNoYXJlZFN0cnVjdHVyZXMgPiA2NCk7XG5cdFx0bGV0IHNoYXJlZExpbWl0SWQgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzICsgMHg0MDtcblx0XHRsZXQgbWF4U3RydWN0dXJlSWQgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzICsgbWF4T3duU3RydWN0dXJlcyArIDB4NDA7XG5cdFx0aWYgKG1heFN0cnVjdHVyZUlkID4gODI1Nikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIG1heFNoYXJlZFN0cnVjdHVyZSArIG1heE93blN0cnVjdHVyZSBpcyA4MTkyJylcblx0XHR9XG5cdFx0bGV0IHJlY29yZElkc1RvUmVtb3ZlID0gW107XG5cdFx0bGV0IHRyYW5zaXRpb25zQ291bnQgPSAwO1xuXHRcdGxldCBzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgPSAwO1xuXG5cdFx0dGhpcy5wYWNrID0gdGhpcy5lbmNvZGUgPSBmdW5jdGlvbih2YWx1ZSwgZW5jb2RlT3B0aW9ucykge1xuXHRcdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdFx0dGFyZ2V0ID0gbmV3IEJ5dGVBcnJheUFsbG9jYXRlKDgxOTIpO1xuXHRcdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3IHx8ICh0YXJnZXQuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGFyZ2V0LmJ1ZmZlciwgMCwgODE5MikpO1xuXHRcdFx0XHRwb3NpdGlvbiA9IDA7XG5cdFx0XHR9XG5cdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHRcdFx0aWYgKHNhZmVFbmQgLSBwb3NpdGlvbiA8IDB4ODAwKSB7XG5cdFx0XHRcdC8vIGRvbid0IHN0YXJ0IHRvbyBjbG9zZSB0byB0aGUgZW5kLFxuXHRcdFx0XHR0YXJnZXQgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUodGFyZ2V0Lmxlbmd0aCk7XG5cdFx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXcgfHwgKHRhcmdldC5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyh0YXJnZXQuYnVmZmVyLCAwLCB0YXJnZXQubGVuZ3RoKSk7XG5cdFx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTA7XG5cdFx0XHRcdHBvc2l0aW9uID0gMDtcblx0XHRcdH0gZWxzZVxuXHRcdFx0XHRwb3NpdGlvbiA9IChwb3NpdGlvbiArIDcpICYgMHg3ZmZmZmZmODsgLy8gV29yZCBhbGlnbiB0byBtYWtlIGFueSBmdXR1cmUgY29weWluZyBvZiB0aGlzIGJ1ZmZlciBmYXN0ZXJcblx0XHRcdHN0YXJ0ID0gcG9zaXRpb247XG5cdFx0XHRpZiAoZW5jb2RlT3B0aW9ucyAmIFJFU0VSVkVfU1RBUlRfU1BBQ0UpIHBvc2l0aW9uICs9IChlbmNvZGVPcHRpb25zICYgMHhmZik7XG5cdFx0XHRyZWZlcmVuY2VNYXAgPSBwYWNrci5zdHJ1Y3R1cmVkQ2xvbmUgPyBuZXcgTWFwKCkgOiBudWxsO1xuXHRcdFx0aWYgKHBhY2tyLmJ1bmRsZVN0cmluZ3MgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRidW5kbGVkU3RyaW5ncyA9IFtdO1xuXHRcdFx0XHRidW5kbGVkU3RyaW5ncy5zaXplID0gSW5maW5pdHk7IC8vIGZvcmNlIGEgbmV3IGJ1bmRsZSBzdGFydCBvbiBmaXJzdCBzdHJpbmdcblx0XHRcdH0gZWxzZVxuXHRcdFx0XHRidW5kbGVkU3RyaW5ncyA9IG51bGw7XG5cdFx0XHRzdHJ1Y3R1cmVzID0gcGFja3Iuc3RydWN0dXJlcztcblx0XHRcdGlmIChzdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdGlmIChzdHJ1Y3R1cmVzLnVuaW5pdGlhbGl6ZWQpXG5cdFx0XHRcdFx0c3RydWN0dXJlcyA9IHBhY2tyLl9tZXJnZVN0cnVjdHVyZXMocGFja3IuZ2V0U3RydWN0dXJlcygpKTtcblx0XHRcdFx0bGV0IHNoYXJlZExlbmd0aCA9IHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoIHx8IDA7XG5cdFx0XHRcdGlmIChzaGFyZWRMZW5ndGggPiBtYXhTaGFyZWRTdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdFx0Ly9pZiAobWF4U2hhcmVkU3RydWN0dXJlcyA8PSAzMiAmJiBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA+IDMyKSAvLyBUT0RPOiBjb3VsZCBzdXBwb3J0IHRoaXMsIGJ1dCB3b3VsZCBuZWVkIHRvIHVwZGF0ZSB0aGUgbGltaXQgaWRzXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTaGFyZWQgc3RydWN0dXJlcyBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHNoYXJlZCBzdHJ1Y3R1cmVzLCB0cnkgaW5jcmVhc2luZyBtYXhTaGFyZWRTdHJ1Y3R1cmVzIHRvICcgKyBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aClcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN0cnVjdHVyZXMudHJhbnNpdGlvbnMpIHtcblx0XHRcdFx0XHQvLyByZWJ1aWxkIG91ciBzdHJ1Y3R1cmUgdHJhbnNpdGlvbnNcblx0XHRcdFx0XHRzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNoYXJlZExlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRsZXQga2V5cyA9IHN0cnVjdHVyZXNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIWtleXMpXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuXHRcdFx0XHRcdFx0XHRsZXQga2V5ID0ga2V5c1tqXTtcblx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV07XG5cdFx0XHRcdFx0XHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IGkgKyAweDQwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGggPSBzaGFyZWRMZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFpc1NlcXVlbnRpYWwpIHtcblx0XHRcdFx0XHRzdHJ1Y3R1cmVzLm5leHRJZCA9IHNoYXJlZExlbmd0aCArIDB4NDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNTaGFyZWRVcGRhdGUpXG5cdFx0XHRcdGhhc1NoYXJlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0bGV0IGVuY29kaW5nRXJyb3I7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAocGFja3IucmFuZG9tQWNjZXNzU3RydWN0dXJlICYmIHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpXG5cdFx0XHRcdFx0d3JpdGVTdHJ1Y3QodmFsdWUpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0cGFjayh2YWx1ZSk7XG5cdFx0XHRcdGxldCBsYXN0QnVuZGxlID0gYnVuZGxlZFN0cmluZ3M7XG5cdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncylcblx0XHRcdFx0XHR3cml0ZUJ1bmRsZXMoc3RhcnQsIHBhY2ssIDApO1xuXHRcdFx0XHRpZiAocmVmZXJlbmNlTWFwICYmIHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydCkge1xuXHRcdFx0XHRcdGxldCBpZHNUb0luc2VydCA9IHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydC5zb3J0KChhLCBiKSA9PiBhLm9mZnNldCA+IGIub2Zmc2V0ID8gMSA6IC0xKTtcblx0XHRcdFx0XHRsZXQgaSA9IGlkc1RvSW5zZXJ0Lmxlbmd0aDtcblx0XHRcdFx0XHRsZXQgaW5jcmVtZW50UG9zaXRpb24gPSAtMTtcblx0XHRcdFx0XHR3aGlsZSAobGFzdEJ1bmRsZSAmJiBpID4gMCkge1xuXHRcdFx0XHRcdFx0bGV0IGluc2VydGlvblBvaW50ID0gaWRzVG9JbnNlcnRbLS1pXS5vZmZzZXQgKyBzdGFydDtcblx0XHRcdFx0XHRcdGlmIChpbnNlcnRpb25Qb2ludCA8IChsYXN0QnVuZGxlLnN0cmluZ3NQb3NpdGlvbiArIHN0YXJ0KSAmJiBpbmNyZW1lbnRQb3NpdGlvbiA9PT0gLTEpXG5cdFx0XHRcdFx0XHRcdGluY3JlbWVudFBvc2l0aW9uID0gMDtcblx0XHRcdFx0XHRcdGlmIChpbnNlcnRpb25Qb2ludCA+IChsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQpKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpbmNyZW1lbnRQb3NpdGlvbiA+PSAwKVxuXHRcdFx0XHRcdFx0XHRcdGluY3JlbWVudFBvc2l0aW9uICs9IDY7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5jcmVtZW50UG9zaXRpb24gPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHVwZGF0ZSB0aGUgYnVuZGxlIHJlZmVyZW5jZSBub3dcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQsXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LmdldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQpICsgaW5jcmVtZW50UG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHRcdGluY3JlbWVudFBvc2l0aW9uID0gLTE7IC8vIHJlc2V0XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bGFzdEJ1bmRsZSA9IGxhc3RCdW5kbGUucHJldmlvdXM7XG5cdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGluY3JlbWVudFBvc2l0aW9uID49IDAgJiYgbGFzdEJ1bmRsZSkge1xuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBidW5kbGUgcmVmZXJlbmNlIG5vd1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIobGFzdEJ1bmRsZS5wb3NpdGlvbiArIHN0YXJ0LFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LmdldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQpICsgaW5jcmVtZW50UG9zaXRpb24pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3NpdGlvbiArPSBpZHNUb0luc2VydC5sZW5ndGggKiA2O1xuXHRcdFx0XHRcdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRtYWtlUm9vbShwb3NpdGlvbik7XG5cdFx0XHRcdFx0cGFja3Iub2Zmc2V0ID0gcG9zaXRpb247XG5cdFx0XHRcdFx0bGV0IHNlcmlhbGl6ZWQgPSBpbnNlcnRJZHModGFyZ2V0LnN1YmFycmF5KHN0YXJ0LCBwb3NpdGlvbiksIGlkc1RvSW5zZXJ0KTtcblx0XHRcdFx0XHRyZWZlcmVuY2VNYXAgPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiBzZXJpYWxpemVkXG5cdFx0XHRcdH1cblx0XHRcdFx0cGFja3Iub2Zmc2V0ID0gcG9zaXRpb247IC8vIHVwZGF0ZSB0aGUgb2Zmc2V0IHNvIG5leHQgc2VyaWFsaXphdGlvbiBkb2Vzbid0IHdyaXRlIG92ZXIgb3VyIGJ1ZmZlciwgYnV0IGNhbiBjb250aW51ZSB3cml0aW5nIHRvIHNhbWUgYnVmZmVyIHNlcXVlbnRpYWxseVxuXHRcdFx0XHRpZiAoZW5jb2RlT3B0aW9ucyAmIFJFVVNFX0JVRkZFUl9NT0RFKSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRcdFx0dGFyZ2V0LmVuZCA9IHBvc2l0aW9uO1xuXHRcdFx0XHRcdHJldHVybiB0YXJnZXRcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LnN1YmFycmF5KHN0YXJ0LCBwb3NpdGlvbikgLy8gcG9zaXRpb24gY2FuIGNoYW5nZSBpZiB3ZSBjYWxsIHBhY2sgYWdhaW4gaW4gc2F2ZVN0cnVjdHVyZXMsIHNvIHdlIGdldCB0aGUgYnVmZmVyIG5vd1xuXHRcdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0XHRlbmNvZGluZ0Vycm9yID0gZXJyb3I7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKHN0cnVjdHVyZXMpIHtcblx0XHRcdFx0XHRyZXNldFN0cnVjdHVyZXMoKTtcblx0XHRcdFx0XHRpZiAoaGFzU2hhcmVkVXBkYXRlICYmIHBhY2tyLnNhdmVTdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMDtcblx0XHRcdFx0XHRcdC8vIHdlIGNhbid0IHJlbHkgb24gc3RhcnQvZW5kIHdpdGggUkVVU0VfQlVGRkVSX01PREUgc2luY2UgdGhleSB3aWxsIChwcm9iYWJseSkgY2hhbmdlIHdoZW4gd2Ugc2F2ZVxuXHRcdFx0XHRcdFx0bGV0IHJldHVybkJ1ZmZlciA9IHRhcmdldC5zdWJhcnJheShzdGFydCwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0bGV0IG5ld1NoYXJlZERhdGEgPSBwcmVwYXJlU3RydWN0dXJlcyQxKHN0cnVjdHVyZXMsIHBhY2tyKTtcblx0XHRcdFx0XHRcdGlmICghZW5jb2RpbmdFcnJvcikgeyAvLyBUT0RPOiBJZiB0aGVyZSBpcyBhbiBlbmNvZGluZyBlcnJvciwgc2hvdWxkIG1ha2UgdGhlIHN0cnVjdHVyZXMgYXMgdW5pbml0aWFsaXplZCBzbyB0aGV5IGdldCByZWJ1aWx0IG5leHQgdGltZVxuXHRcdFx0XHRcdFx0XHRpZiAocGFja3Iuc2F2ZVN0cnVjdHVyZXMobmV3U2hhcmVkRGF0YSwgbmV3U2hhcmVkRGF0YS5pc0NvbXBhdGlibGUpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGdldCB1cGRhdGVkIHN0cnVjdHVyZXMgYW5kIHRyeSBhZ2FpbiBpZiB0aGUgdXBkYXRlIGZhaWxlZFxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBwYWNrci5wYWNrKHZhbHVlLCBlbmNvZGVPcHRpb25zKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHBhY2tyLmxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGggPSBzaGFyZWRMZW5ndGg7XG5cdFx0XHRcdFx0XHRcdC8vIGRvbid0IGtlZXAgbGFyZ2UgYnVmZmVycyBhcm91bmRcblx0XHRcdFx0XHRcdFx0aWYgKHRhcmdldC5sZW5ndGggPiAweDQwMDAwMDAwKSB0YXJnZXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuQnVmZmVyXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGRvbid0IGtlZXAgbGFyZ2UgYnVmZmVycyBhcm91bmQsIHRoZXkgdGFrZSB0b28gbXVjaCBtZW1vcnkgYW5kIGNhdXNlIHByb2JsZW1zIChsaW1pdCBhdCAxR0IpXG5cdFx0XHRcdGlmICh0YXJnZXQubGVuZ3RoID4gMHg0MDAwMDAwMCkgdGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0aWYgKGVuY29kZU9wdGlvbnMgJiBSRVNFVF9CVUZGRVJfTU9ERSlcblx0XHRcdFx0XHRwb3NpdGlvbiA9IHN0YXJ0O1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y29uc3QgcmVzZXRTdHJ1Y3R1cmVzID0gKCkgPT4ge1xuXHRcdFx0aWYgKHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCA8IDEwKVxuXHRcdFx0XHRzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQrKztcblx0XHRcdGxldCBzaGFyZWRMZW5ndGggPSBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwO1xuXHRcdFx0aWYgKHN0cnVjdHVyZXMubGVuZ3RoID4gc2hhcmVkTGVuZ3RoICYmICFpc1NlcXVlbnRpYWwpXG5cdFx0XHRcdHN0cnVjdHVyZXMubGVuZ3RoID0gc2hhcmVkTGVuZ3RoO1xuXHRcdFx0aWYgKHRyYW5zaXRpb25zQ291bnQgPiAxMDAwMCkge1xuXHRcdFx0XHQvLyBmb3JjZSBhIHJlYnVpbGQgb2NjYXNpb25hbGx5IGFmdGVyIGEgbG90IG9mIHRyYW5zaXRpb25zIHNvIGl0IGNhbiBnZXQgY2xlYW5lZCB1cFxuXHRcdFx0XHRzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gbnVsbDtcblx0XHRcdFx0c2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkID0gMDtcblx0XHRcdFx0dHJhbnNpdGlvbnNDb3VudCA9IDA7XG5cdFx0XHRcdGlmIChyZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlID0gW107XG5cdFx0XHR9IGVsc2UgaWYgKHJlY29yZElkc1RvUmVtb3ZlLmxlbmd0aCA+IDAgJiYgIWlzU2VxdWVudGlhbCkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHJlY29yZElkc1RvUmVtb3ZlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlW2ldW1JFQ09SRF9TWU1CT0xdID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZSA9IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y29uc3QgcGFja0FycmF5ID0gKHZhbHVlKSA9PiB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg5MCB8IGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRjO1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gODtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGQ7XG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpO1xuXHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRwYWNrKHZhbHVlW2ldKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IHBhY2sgPSAodmFsdWUpID0+IHtcblx0XHRcdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uKTtcblxuXHRcdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdFx0XHR2YXIgbGVuZ3RoO1xuXHRcdFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGxldCBzdHJMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncyAmJiBzdHJMZW5ndGggPj0gNCAmJiBzdHJMZW5ndGggPCAweDEwMDApIHtcblx0XHRcdFx0XHRpZiAoKGJ1bmRsZWRTdHJpbmdzLnNpemUgKz0gc3RyTGVuZ3RoKSA+IE1BWF9CVU5ETEVfU0laRSkge1xuXHRcdFx0XHRcdFx0bGV0IGV4dFN0YXJ0O1xuXHRcdFx0XHRcdFx0bGV0IG1heEJ5dGVzID0gKGJ1bmRsZWRTdHJpbmdzWzBdID8gYnVuZGxlZFN0cmluZ3NbMF0ubGVuZ3RoICogMyArIGJ1bmRsZWRTdHJpbmdzWzFdLmxlbmd0aCA6IDApICsgMTA7XG5cdFx0XHRcdFx0XHRpZiAocG9zaXRpb24gKyBtYXhCeXRlcyA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uICsgbWF4Qnl0ZXMpO1xuXHRcdFx0XHRcdFx0bGV0IGxhc3RCdW5kbGU7XG5cdFx0XHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MucG9zaXRpb24pIHsgLy8gaGVyZSB3ZSB1c2UgdGhlIDB4NjIgZXh0ZW5zaW9uIHRvIHdyaXRlIHRoZSBsYXN0IGJ1bmRsZSBhbmQgcmVzZXJ2ZSBzcGFjZSBmb3IgdGhlIHJlZmVyZW5jZSBwb2ludGVyIHRvIHRoZSBuZXh0L2N1cnJlbnQgYnVuZGxlXG5cdFx0XHRcdFx0XHRcdGxhc3RCdW5kbGUgPSBidW5kbGVkU3RyaW5ncztcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uXSA9IDB4Yzg7IC8vIGV4dCAxNlxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSAzOyAvLyByZXNlcnZlIGZvciB0aGUgd3JpdGluZyBidW5kbGUgc2l6ZVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDYyOyAvLyAnYidcblx0XHRcdFx0XHRcdFx0ZXh0U3RhcnQgPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0OyAvLyByZXNlcnZlIGZvciB3cml0aW5nIGJ1bmRsZSByZWZlcmVuY2Vcblx0XHRcdFx0XHRcdFx0d3JpdGVCdW5kbGVzKHN0YXJ0LCBwYWNrLCAwKTsgLy8gd3JpdGUgdGhlIGxhc3QgYnVuZGxlc1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQxNihleHRTdGFydCArIHN0YXJ0IC0gMywgcG9zaXRpb24gLSBzdGFydCAtIGV4dFN0YXJ0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7IC8vIGhlcmUgd2UgdXNlIHRoZSAweDYyIGV4dGVuc2lvbiBqdXN0IHRvIHJlc2VydmUgdGhlIHNwYWNlIGZvciB0aGUgcmVmZXJlbmNlIHBvaW50ZXIgdG8gdGhlIGJ1bmRsZSAod2lsbCBiZSB1cGRhdGVkIG9uY2UgdGhlIGJ1bmRsZSBpcyB3cml0dGVuKVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2OyAvLyBmaXhleHQgNFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDYyOyAvLyAnYidcblx0XHRcdFx0XHRcdFx0ZXh0U3RhcnQgPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0OyAvLyByZXNlcnZlIGZvciB3cml0aW5nIGJ1bmRsZSByZWZlcmVuY2Vcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzID0gWycnLCAnJ107IC8vIGNyZWF0ZSBuZXcgb25lc1xuXHRcdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3MucHJldmlvdXMgPSBsYXN0QnVuZGxlO1xuXHRcdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3Muc2l6ZSA9IDA7XG5cdFx0XHRcdFx0XHRidW5kbGVkU3RyaW5ncy5wb3NpdGlvbiA9IGV4dFN0YXJ0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZXQgdHdvQnl0ZSA9IGhhc05vbkxhdGluLnRlc3QodmFsdWUpO1xuXHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzW3R3b0J5dGUgPyAwIDogMV0gKz0gdmFsdWU7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjMTtcblx0XHRcdFx0XHRwYWNrKHR3b0J5dGUgPyAtc3RyTGVuZ3RoIDogc3RyTGVuZ3RoKTtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgaGVhZGVyU2l6ZTtcblx0XHRcdFx0Ly8gZmlyc3Qgd2UgZXN0aW1hdGUgdGhlIGhlYWRlciBzaXplLCBzbyB3ZSBjYW4gd3JpdGUgdG8gdGhlIGNvcnJlY3QgbG9jYXRpb25cblx0XHRcdFx0aWYgKHN0ckxlbmd0aCA8IDB4MjApIHtcblx0XHRcdFx0XHRoZWFkZXJTaXplID0gMTtcblx0XHRcdFx0fSBlbHNlIGlmIChzdHJMZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSAyO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN0ckxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRoZWFkZXJTaXplID0gMztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoZWFkZXJTaXplID0gNTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgbWF4Qnl0ZXMgPSBzdHJMZW5ndGggKiAzO1xuXHRcdFx0XHRpZiAocG9zaXRpb24gKyBtYXhCeXRlcyA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0dGFyZ2V0ID0gbWFrZVJvb20ocG9zaXRpb24gKyBtYXhCeXRlcyk7XG5cblx0XHRcdFx0aWYgKHN0ckxlbmd0aCA8IDB4NDAgfHwgIWVuY29kZVV0ZjgpIHtcblx0XHRcdFx0XHRsZXQgaSwgYzEsIGMyLCBzdHJQb3NpdGlvbiA9IHBvc2l0aW9uICsgaGVhZGVyU2l6ZTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGMxID0gdmFsdWUuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0XHRcdGlmIChjMSA8IDB4ODApIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzE7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGMxIDwgMHg4MDApIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gNiB8IDB4YzA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdFx0XHQoYzEgJiAweGZjMDApID09PSAweGQ4MDAgJiZcblx0XHRcdFx0XHRcdFx0KChjMiA9IHZhbHVlLmNoYXJDb2RlQXQoaSArIDEpKSAmIDB4ZmMwMCkgPT09IDB4ZGMwMFxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG5cdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gMTggfCAweGYwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiAxMiAmIDB4M2YgfCAweDgwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiAxMiB8IDB4ZTA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDYgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGVuZ3RoID0gc3RyUG9zaXRpb24gLSBwb3NpdGlvbiAtIGhlYWRlclNpemU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGVuZ3RoID0gZW5jb2RlVXRmOCh2YWx1ZSwgcG9zaXRpb24gKyBoZWFkZXJTaXplKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChsZW5ndGggPCAweDIwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhhMCB8IGxlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJTaXplIDwgMikge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24gKyAyLCBwb3NpdGlvbiArIDEsIHBvc2l0aW9uICsgMSArIGxlbmd0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDk7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRpZiAoaGVhZGVyU2l6ZSA8IDMpIHtcblx0XHRcdFx0XHRcdHRhcmdldC5jb3B5V2l0aGluKHBvc2l0aW9uICsgMywgcG9zaXRpb24gKyAyLCBwb3NpdGlvbiArIDIgKyBsZW5ndGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRhO1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4O1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGhlYWRlclNpemUgPCA1KSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihwb3NpdGlvbiArIDUsIHBvc2l0aW9uICsgMywgcG9zaXRpb24gKyAzICsgbGVuZ3RoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkYjtcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoKTtcblx0XHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBvc2l0aW9uICs9IGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0aWYgKHZhbHVlID4+PiAwID09PSB2YWx1ZSkgey8vIHBvc2l0aXZlIGludGVnZXIsIDMyLWJpdCBvciBsZXNzXG5cdFx0XHRcdFx0Ly8gcG9zaXRpdmUgdWludFxuXHRcdFx0XHRcdGlmICh2YWx1ZSA8IDB4MjAgfHwgKHZhbHVlIDwgMHg4MCAmJiB0aGlzLnVzZVJlY29yZHMgPT09IGZhbHNlKSB8fCAodmFsdWUgPCAweDQwICYmICF0aGlzLnJhbmRvbUFjY2Vzc1N0cnVjdHVyZSkpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAweDEwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjYztcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAweDEwMDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNkO1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWUgPj4gODtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlICYgMHhmZjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjZTtcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+PiAwID09PSB2YWx1ZSkgeyAvLyBuZWdhdGl2ZSBpbnRlZ2VyXG5cdFx0XHRcdFx0aWYgKHZhbHVlID49IC0weDIwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDEwMCArIHZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPj0gLTB4ODApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDA7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSArIDB4MTAwO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPj0gLTB4ODAwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkMTtcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0SW50MTYocG9zaXRpb24sIHZhbHVlKTtcblx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDI7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEludDMyKHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZXQgdXNlRmxvYXQzMjtcblx0XHRcdFx0XHRpZiAoKHVzZUZsb2F0MzIgPSB0aGlzLnVzZUZsb2F0MzIpID4gMCAmJiB2YWx1ZSA8IDB4MTAwMDAwMDAwICYmIHZhbHVlID49IC0weDgwMDAwMDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNhO1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDMyKHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRsZXQgeFNoaWZ0ZWQ7XG5cdFx0XHRcdFx0XHRpZiAodXNlRmxvYXQzMiA8IDQgfHxcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzIGNoZWNrcyBmb3Igcm91bmRpbmcgb2YgbnVtYmVycyB0aGF0IHdlcmUgZW5jb2RlZCBpbiAzMi1iaXQgZmxvYXQgdG8gbmVhcmVzdCBzaWduaWZpY2FudCBkZWNpbWFsIGRpZ2l0IHRoYXQgY291bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRcdFx0XHRcdFx0KCh4U2hpZnRlZCA9IHZhbHVlICogbXVsdDEwWygodGFyZ2V0W3Bvc2l0aW9uXSAmIDB4N2YpIDw8IDEpIHwgKHRhcmdldFtwb3NpdGlvbiArIDFdID4+IDcpXSkgPj4gMCkgPT09IHhTaGlmdGVkKSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uLS07IC8vIG1vdmUgYmFjayBpbnRvIHBvc2l0aW9uIGZvciB3cml0aW5nIGEgZG91YmxlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2I7XG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDY0KHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gODtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGlmICghdmFsdWUpXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjMDtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHJlZmVyZW5jZU1hcCkge1xuXHRcdFx0XHRcdFx0bGV0IHJlZmVyZWUgPSByZWZlcmVuY2VNYXAuZ2V0KHZhbHVlKTtcblx0XHRcdFx0XHRcdGlmIChyZWZlcmVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghcmVmZXJlZS5pZCkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBpZHNUb0luc2VydCA9IHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydCB8fCAocmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0ID0gW10pO1xuXHRcdFx0XHRcdFx0XHRcdHJlZmVyZWUuaWQgPSBpZHNUb0luc2VydC5wdXNoKHJlZmVyZWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDY7IC8vIGZpeGV4dCA0XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzA7IC8vIFwicFwiIGZvciBwb2ludGVyXG5cdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCByZWZlcmVlLmlkKTtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0cmVmZXJlbmNlTWFwLnNldCh2YWx1ZSwgeyBvZmZzZXQ6IHBvc2l0aW9uIC0gc3RhcnQgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxldCBjb25zdHJ1Y3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yO1xuXHRcdFx0XHRcdGlmIChjb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG5cdFx0XHRcdFx0XHR3cml0ZU9iamVjdCh2YWx1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcblx0XHRcdFx0XHRcdHBhY2tBcnJheSh2YWx1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjb25zdHJ1Y3RvciA9PT0gTWFwKSB7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5tYXBBc0VtcHR5T2JqZWN0KSB0YXJnZXRbcG9zaXRpb24rK10gPSAweDgwO1xuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxlbmd0aCA9IHZhbHVlLnNpemU7XG5cdFx0XHRcdFx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg4MCB8IGxlbmd0aDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZTtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gODtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGY7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBba2V5LCBlbnRyeVZhbHVlXSBvZiB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhY2soa2V5KTtcblx0XHRcdFx0XHRcdFx0XHRwYWNrKGVudHJ5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gZXh0ZW5zaW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0bGV0IGV4dGVuc2lvbkNsYXNzID0gZXh0ZW5zaW9uQ2xhc3Nlc1tpXTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgZXh0ZW5zaW9uQ2xhc3MpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1tpXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uLndyaXRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uLnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNDsgLy8gb25lIGJ5dGUgXCJ0YWdcIiBleHRlbnNpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gZXh0ZW5zaW9uLnR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgd3JpdGVSZXN1bHQgPSBleHRlbnNpb24ud3JpdGUuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAod3JpdGVSZXN1bHQgPT09IHZhbHVlKSB7IC8vIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYWNrQXJyYXkodmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlT2JqZWN0KHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFjayh3cml0ZVJlc3VsdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRUYXJnZXRWaWV3ID0gdGFyZ2V0Vmlldztcblx0XHRcdFx0XHRcdFx0XHRsZXQgY3VycmVudFBvc2l0aW9uID0gcG9zaXRpb247XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRsZXQgcmVzdWx0O1xuXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgPSBleHRlbnNpb24ucGFjay5jYWxsKHRoaXMsIHZhbHVlLCAoc2l6ZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyByZXN0b3JlIHRhcmdldCBhbmQgdXNlIGl0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSBzaXplO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1ha2VSb29tKHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9uOiBwb3NpdGlvbiAtIHNpemVcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSwgcGFjayk7XG5cdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHJlc3RvcmUgY3VycmVudCB0YXJnZXQgaW5mb3JtYXRpb24gKHVubGVzcyBhbHJlYWR5IHJlc3RvcmVkKVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRUYXJnZXQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gY3VycmVudFRhcmdldDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0VmlldyA9IGN1cnJlbnRUYXJnZXRWaWV3O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHJlc3VsdC5sZW5ndGggKyBwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1ha2VSb29tKHJlc3VsdC5sZW5ndGggKyBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiA9IHdyaXRlRXh0ZW5zaW9uRGF0YShyZXN1bHQsIHRhcmdldCwgcG9zaXRpb24sIGV4dGVuc2lvbi50eXBlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGNoZWNrIGlzQXJyYXkgYWZ0ZXIgZXh0ZW5zaW9ucywgYmVjYXVzZSBleHRlbnNpb25zIGNhbiBleHRlbmQgQXJyYXlcblx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRwYWNrQXJyYXkodmFsdWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gdXNlIHRoaXMgYXMgYW4gYWx0ZXJuYXRlIG1lY2hhbmlzbSBmb3IgZXhwcmVzc2luZyBob3cgdG8gc2VyaWFsaXplXG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZS50b0pTT04pIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBqc29uID0gdmFsdWUudG9KU09OKCk7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgZm9yIHNvbWUgcmVhc29uIHZhbHVlLnRvSlNPTiByZXR1cm5zIGl0c2VsZiBpdCdsbCBsb29wIGZvcmV2ZXJcblx0XHRcdFx0XHRcdFx0XHRpZiAoanNvbiAhPT0gdmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFjayhqc29uKVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSB3cml0ZUZ1bmN0aW9uLCB1c2UgaXQsIG90aGVyd2lzZSBqdXN0IGVuY29kZSBhcyB1bmRlZmluZWRcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdmdW5jdGlvbicpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhY2sodGhpcy53cml0ZUZ1bmN0aW9uICYmIHRoaXMud3JpdGVGdW5jdGlvbih2YWx1ZSkpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIG5vIGV4dGVuc2lvbiBmb3VuZCwgd3JpdGUgYXMgcGxhaW4gb2JqZWN0XG5cdFx0XHRcdFx0XHRcdHdyaXRlT2JqZWN0KHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlID8gMHhjMyA6IDB4YzI7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdiaWdpbnQnKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSA8IChCaWdJbnQoMSk8PEJpZ0ludCg2MykpICYmIHZhbHVlID49IC0oQmlnSW50KDEpPDxCaWdJbnQoNjMpKSkge1xuXHRcdFx0XHRcdC8vIHVzZSBhIHNpZ25lZCBpbnQgYXMgbG9uZyBhcyBpdCBmaXRzXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkMztcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEJpZ0ludDY0KHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAoQmlnSW50KDEpPDxCaWdJbnQoNjQpKSAmJiB2YWx1ZSA+IDApIHtcblx0XHRcdFx0XHQvLyBpZiB3ZSBjYW4gZml0IGFuIHVuc2lnbmVkIGludCwgdXNlIHRoYXRcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNmO1xuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0QmlnVWludDY0KHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gb3ZlcmZsb3dcblx0XHRcdFx0XHRpZiAodGhpcy5sYXJnZUJpZ0ludFRvRmxvYXQpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2I7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIE51bWJlcih2YWx1ZSkpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy51c2VCaWdJbnRFeHRlbnNpb24gJiYgdmFsdWUgPCAybioqKDEwMjNuKSAmJiB2YWx1ZSA+IC0oMm4qKigxMDIzbikpKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM3O1xuXHRcdFx0XHRcdFx0cG9zaXRpb24rKztcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NDI7IC8vIFwiQlwiIGZvciBCaWdJbnRcblx0XHRcdFx0XHRcdGxldCBieXRlcyA9IFtdO1xuXHRcdFx0XHRcdFx0bGV0IGFsaWduZWRTaWduO1xuXHRcdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0XHRsZXQgYnl0ZSA9IHZhbHVlICYgMHhmZm47XG5cdFx0XHRcdFx0XHRcdGFsaWduZWRTaWduID0gKGJ5dGUgJiAweDgwbikgPT09ICh2YWx1ZSA8IDBuID8gMHg4MG4gOiAwbik7XG5cdFx0XHRcdFx0XHRcdGJ5dGVzLnB1c2goYnl0ZSk7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID4+PSA4bjtcblx0XHRcdFx0XHRcdH0gd2hpbGUgKCEoKHZhbHVlID09PSAwbiB8fCB2YWx1ZSA9PT0gLTFuKSAmJiBhbGlnbmVkU2lnbikpO1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uLTJdID0gYnl0ZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGJ5dGVzLmxlbmd0aDsgaSA+IDA7KSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IE51bWJlcihieXRlc1stLWldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcih2YWx1ZSArICcgd2FzIHRvbyBsYXJnZSB0byBmaXQgaW4gTWVzc2FnZVBhY2sgNjQtYml0IGludGVnZXIgZm9ybWF0LCB1c2UnICtcblx0XHRcdFx0XHRcdFx0JyB1c2VCaWdJbnRFeHRlbnNpb24gb3Igc2V0IGxhcmdlQmlnSW50VG9GbG9hdCB0byBjb252ZXJ0IHRvIGZsb2F0LTY0Jylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zaXRpb24gKz0gODtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0aWYgKHRoaXMuZW5jb2RlVW5kZWZpbmVkQXNOaWwpXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjMDtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNDsgLy8gYSBudW1iZXIgb2YgaW1wbGVtZW50YXRpb25zIHVzZSBmaXhleHQxIHdpdGggdHlwZSAwLCBkYXRhIDAgdG8gZGVub3RlIHVuZGVmaW5lZCwgc28gd2UgZm9sbG93IHN1aXRlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMDtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZTogJyArIHR5cGUpXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGNvbnN0IHdyaXRlUGxhaW5PYmplY3QgPSAodGhpcy52YXJpYWJsZU1hcFNpemUgfHwgdGhpcy5jb2VyY2libGVLZXlBc051bWJlciB8fCB0aGlzLnNraXBWYWx1ZXMpID8gKG9iamVjdCkgPT4ge1xuXHRcdFx0Ly8gdGhpcyBtZXRob2QgaXMgc2xpZ2h0bHkgc2xvd2VyLCBidXQgZ2VuZXJhdGVzIFwicHJlZmVycmVkIHNlcmlhbGl6YXRpb25cIiAob3B0aW1hbGx5IHNtYWxsIGZvciBzbWFsbGVyIG9iamVjdHMpXG5cdFx0XHRsZXQga2V5cztcblx0XHRcdGlmICh0aGlzLnNraXBWYWx1ZXMpIHtcblx0XHRcdFx0a2V5cyA9IFtdO1xuXHRcdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdFx0aWYgKCh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSAmJlxuXHRcdFx0XHRcdFx0IXRoaXMuc2tpcFZhbHVlcy5pbmNsdWRlcyhvYmplY3Rba2V5XSkpXG5cdFx0XHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cdFx0XHR9XG5cdFx0XHRsZXQgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDgwIHwgbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGU7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4O1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZjtcblx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aCk7XG5cdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHR9XG5cdFx0XHRsZXQga2V5O1xuXHRcdFx0aWYgKHRoaXMuY29lcmNpYmxlS2V5QXNOdW1iZXIpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHRcdFx0bGV0IG51bSA9IE51bWJlcihrZXkpO1xuXHRcdFx0XHRcdHBhY2soaXNOYU4obnVtKSA/IGtleSA6IG51bSk7XG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHBhY2soa2V5ID0ga2V5c1tpXSk7XG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IDpcblx0XHQob2JqZWN0KSA9PiB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRlOyAvLyBhbHdheXMgdXNpbmcgbWFwIDE2LCBzbyB3ZSBjYW4gcHJlYWxsb2NhdGUgYW5kIHNldCB0aGUgbGVuZ3RoIGFmdGVyd2FyZHNcblx0XHRcdGxldCBvYmplY3RPZmZzZXQgPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdFx0cG9zaXRpb24gKz0gMjtcblx0XHRcdGxldCBzaXplID0gMDtcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRwYWNrKGtleSk7XG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSk7XG5cdFx0XHRcdFx0c2l6ZSsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0KysgKyBzdGFydF0gPSBzaXplID4+IDg7XG5cdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0ICsgc3RhcnRdID0gc2l6ZSAmIDB4ZmY7XG5cdFx0fTtcblxuXHRcdGNvbnN0IHdyaXRlUmVjb3JkID0gdGhpcy51c2VSZWNvcmRzID09PSBmYWxzZSA/IHdyaXRlUGxhaW5PYmplY3QgOlxuXHRcdChvcHRpb25zLnByb2dyZXNzaXZlUmVjb3JkcyAmJiAhdXNlVHdvQnl0ZVJlY29yZHMpID8gIC8vIHRoaXMgaXMgYWJvdXQgMiUgZmFzdGVyIGZvciBoaWdobHkgc3RhYmxlIHN0cnVjdHVyZXMsIHNpbmNlIGl0IG9ubHkgcmVxdWlyZXMgb25lIGZvci1pbiBsb29wIChidXQgbXVjaCBtb3JlIGV4cGVuc2l2ZSB3aGVuIG5ldyBzdHJ1Y3R1cmUgbmVlZHMgdG8gYmUgd3JpdHRlbilcblx0XHQob2JqZWN0KSA9PiB7XG5cdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zIHx8IChzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdFx0XHRsZXQgb2JqZWN0T2Zmc2V0ID0gcG9zaXRpb24rKyAtIHN0YXJ0O1xuXHRcdFx0bGV0IHdyb3RlS2V5cztcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRcdFx0XHRpZiAobmV4dFRyYW5zaXRpb24pXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb247XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyByZWNvcmQgZG9lc24ndCBleGlzdCwgY3JlYXRlIGZ1bGwgbmV3IHJlY29yZCBhbmQgaW5zZXJ0IGl0XG5cdFx0XHRcdFx0XHRsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cdFx0XHRcdFx0XHRsZXQgbGFzdFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IHN0cnVjdHVyZXMudHJhbnNpdGlvbnM7XG5cdFx0XHRcdFx0XHRsZXQgbmV3VHJhbnNpdGlvbnMgPSAwO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRsZXQga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV07XG5cdFx0XHRcdFx0XHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNpdGlvbnMrKztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb247XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAob2JqZWN0T2Zmc2V0ICsgc3RhcnQgKyAxID09IHBvc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGZpcnN0IGtleSwgc28gd2UgZG9uJ3QgbmVlZCB0byBpbnNlcnQsIHdlIGNhbiBqdXN0IHdyaXRlIHJlY29yZCBkaXJlY3RseVxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbi0tO1xuXHRcdFx0XHRcdFx0XHRuZXdSZWNvcmQodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIC8vIG90aGVyd2lzZSB3ZSBuZWVkIHRvIGluc2VydCB0aGUgcmVjb3JkLCBtb3ZpbmcgZXhpc3RpbmcgZGF0YSBhZnRlciB0aGUgcmVjb3JkXG5cdFx0XHRcdFx0XHRcdGluc2VydE5ld1JlY29yZCh0cmFuc2l0aW9uLCBrZXlzLCBvYmplY3RPZmZzZXQsIG5ld1RyYW5zaXRpb25zKTtcblx0XHRcdFx0XHRcdHdyb3RlS2V5cyA9IHRydWU7XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbGFzdFRyYW5zaXRpb25ba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghd3JvdGVLZXlzKSB7XG5cdFx0XHRcdGxldCByZWNvcmRJZCA9IHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF07XG5cdFx0XHRcdGlmIChyZWNvcmRJZClcblx0XHRcdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0ICsgc3RhcnRdID0gcmVjb3JkSWQ7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRpbnNlcnROZXdSZWNvcmQodHJhbnNpdGlvbiwgT2JqZWN0LmtleXMob2JqZWN0KSwgb2JqZWN0T2Zmc2V0LCAwKTtcblx0XHRcdH1cblx0XHR9IDpcblx0XHQob2JqZWN0KSA9PiB7XG5cdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zIHx8IChzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdFx0XHRsZXQgbmV3VHJhbnNpdGlvbnMgPSAwO1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIG9iamVjdCkgaWYgKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV07XG5cdFx0XHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHRcdFx0bmV3VHJhbnNpdGlvbnMrKztcblx0XHRcdFx0fVxuXHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb247XG5cdFx0XHR9XG5cdFx0XHRsZXQgcmVjb3JkSWQgPSB0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdO1xuXHRcdFx0aWYgKHJlY29yZElkKSB7XG5cdFx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDYwICYmIHVzZVR3b0J5dGVSZWNvcmRzKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKChyZWNvcmRJZCAtPSAweDYwKSAmIDB4MWYpICsgMHg2MDtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZCA+PiA1O1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1JlY29yZCh0cmFuc2l0aW9uLCB0cmFuc2l0aW9uLl9fa2V5c19fIHx8IE9iamVjdC5rZXlzKG9iamVjdCksIG5ld1RyYW5zaXRpb25zKTtcblx0XHRcdH1cblx0XHRcdC8vIG5vdyB3cml0ZSB0aGUgdmFsdWVzXG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KVxuXHRcdFx0XHRpZiAodHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdHBhY2sob2JqZWN0W2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIGNyZWF0ZSByZWZlcmVuY2UgdG8gdXNlUmVjb3JkcyBpZiB1c2VSZWNvcmRzIGlzIGEgZnVuY3Rpb25cblx0XHRjb25zdCBjaGVja1VzZVJlY29yZHMgPSB0eXBlb2YgdGhpcy51c2VSZWNvcmRzID09ICdmdW5jdGlvbicgJiYgdGhpcy51c2VSZWNvcmRzO1xuXG5cdFx0Y29uc3Qgd3JpdGVPYmplY3QgPSBjaGVja1VzZVJlY29yZHMgPyAob2JqZWN0KSA9PiB7XG5cdFx0XHRjaGVja1VzZVJlY29yZHMob2JqZWN0KSA/IHdyaXRlUmVjb3JkKG9iamVjdCkgOiB3cml0ZVBsYWluT2JqZWN0KG9iamVjdCk7XG5cdFx0fSA6IHdyaXRlUmVjb3JkO1xuXG5cdFx0Y29uc3QgbWFrZVJvb20gPSAoZW5kKSA9PiB7XG5cdFx0XHRsZXQgbmV3U2l6ZTtcblx0XHRcdGlmIChlbmQgPiAweDEwMDAwMDApIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBoYW5kbGluZyBmb3IgcmVhbGx5IGxhcmdlIGJ1ZmZlcnNcblx0XHRcdFx0aWYgKChlbmQgLSBzdGFydCkgPiBNQVhfQlVGRkVSX1NJWkUpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgYnVmZmVyIHdvdWxkIGJlIGxhcmdlciB0aGFuIG1heGltdW0gYnVmZmVyIHNpemUnKVxuXHRcdFx0XHRuZXdTaXplID0gTWF0aC5taW4oTUFYX0JVRkZFUl9TSVpFLFxuXHRcdFx0XHRcdE1hdGgucm91bmQoTWF0aC5tYXgoKGVuZCAtIHN0YXJ0KSAqIChlbmQgPiAweDQwMDAwMDAgPyAxLjI1IDogMiksIDB4NDAwMDAwKSAvIDB4MTAwMCkgKiAweDEwMDApO1xuXHRcdFx0fSBlbHNlIC8vIGZhc3RlciBoYW5kbGluZyBmb3Igc21hbGxlciBidWZmZXJzXG5cdFx0XHRcdG5ld1NpemUgPSAoKE1hdGgubWF4KChlbmQgLSBzdGFydCkgPDwgMiwgdGFyZ2V0Lmxlbmd0aCAtIDEpID4+IDEyKSArIDEpIDw8IDEyO1xuXHRcdFx0bGV0IG5ld0J1ZmZlciA9IG5ldyBCeXRlQXJyYXlBbGxvY2F0ZShuZXdTaXplKTtcblx0XHRcdHRhcmdldFZpZXcgPSBuZXdCdWZmZXIuZGF0YVZpZXcgfHwgKG5ld0J1ZmZlci5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhuZXdCdWZmZXIuYnVmZmVyLCAwLCBuZXdTaXplKSk7XG5cdFx0XHRlbmQgPSBNYXRoLm1pbihlbmQsIHRhcmdldC5sZW5ndGgpO1xuXHRcdFx0aWYgKHRhcmdldC5jb3B5KVxuXHRcdFx0XHR0YXJnZXQuY29weShuZXdCdWZmZXIsIDAsIHN0YXJ0LCBlbmQpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRuZXdCdWZmZXIuc2V0KHRhcmdldC5zbGljZShzdGFydCwgZW5kKSk7XG5cdFx0XHRwb3NpdGlvbiAtPSBzdGFydDtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHRcdHNhZmVFbmQgPSBuZXdCdWZmZXIubGVuZ3RoIC0gMTA7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0ID0gbmV3QnVmZmVyXG5cdFx0fTtcblx0XHRjb25zdCBuZXdSZWNvcmQgPSAodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpID0+IHtcblx0XHRcdGxldCByZWNvcmRJZCA9IHN0cnVjdHVyZXMubmV4dElkO1xuXHRcdFx0aWYgKCFyZWNvcmRJZClcblx0XHRcdFx0cmVjb3JkSWQgPSAweDQwO1xuXHRcdFx0aWYgKHJlY29yZElkIDwgc2hhcmVkTGltaXRJZCAmJiB0aGlzLnNob3VsZFNoYXJlU3RydWN0dXJlICYmICF0aGlzLnNob3VsZFNoYXJlU3RydWN0dXJlKGtleXMpKSB7XG5cdFx0XHRcdHJlY29yZElkID0gc3RydWN0dXJlcy5uZXh0T3duSWQ7XG5cdFx0XHRcdGlmICghKHJlY29yZElkIDwgbWF4U3RydWN0dXJlSWQpKVxuXHRcdFx0XHRcdHJlY29yZElkID0gc2hhcmVkTGltaXRJZDtcblx0XHRcdFx0c3RydWN0dXJlcy5uZXh0T3duSWQgPSByZWNvcmRJZCArIDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAocmVjb3JkSWQgPj0gbWF4U3RydWN0dXJlSWQpLy8gY3ljbGUgYmFjayBhcm91bmRcblx0XHRcdFx0XHRyZWNvcmRJZCA9IHNoYXJlZExpbWl0SWQ7XG5cdFx0XHRcdHN0cnVjdHVyZXMubmV4dElkID0gcmVjb3JkSWQgKyAxO1xuXHRcdFx0fVxuXHRcdFx0bGV0IGhpZ2hCeXRlID0ga2V5cy5oaWdoQnl0ZSA9IHJlY29yZElkID49IDB4NjAgJiYgdXNlVHdvQnl0ZVJlY29yZHMgPyAocmVjb3JkSWQgLSAweDYwKSA+PiA1IDogLTE7XG5cdFx0XHR0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdID0gcmVjb3JkSWQ7XG5cdFx0XHR0cmFuc2l0aW9uLl9fa2V5c19fID0ga2V5cztcblx0XHRcdHN0cnVjdHVyZXNbcmVjb3JkSWQgLSAweDQwXSA9IGtleXM7XG5cblx0XHRcdGlmIChyZWNvcmRJZCA8IHNoYXJlZExpbWl0SWQpIHtcblx0XHRcdFx0a2V5cy5pc1NoYXJlZCA9IHRydWU7XG5cdFx0XHRcdHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gcmVjb3JkSWQgLSAweDNmO1xuXHRcdFx0XHRoYXNTaGFyZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRpZiAoaGlnaEJ5dGUgPj0gMCkge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChyZWNvcmRJZCAmIDB4MWYpICsgMHg2MDtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBoaWdoQnl0ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGhpZ2hCeXRlID49IDApIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ1OyAvLyBmaXhleHQgMlxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzI7IC8vIFwiclwiIHJlY29yZCBkZWZpbnRpb24gZXh0ZW5zaW9uIHR5cGVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAocmVjb3JkSWQgJiAweDFmKSArIDB4NjA7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gaGlnaEJ5dGU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNDsgLy8gZml4ZXh0IDFcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDcyOyAvLyBcInJcIiByZWNvcmQgZGVmaW50aW9uIGV4dGVuc2lvbiB0eXBlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVjb3JkSWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRcdFx0dHJhbnNpdGlvbnNDb3VudCArPSBzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgKiBuZXdUcmFuc2l0aW9ucztcblx0XHRcdFx0Ly8gcmVjb3JkIHRoZSByZW1vdmFsIG9mIHRoZSBpZCwgd2UgY2FuIG1haW50YWluIG91ciBzaGFyZWQgc3RydWN0dXJlXG5cdFx0XHRcdGlmIChyZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGggPj0gbWF4T3duU3RydWN0dXJlcylcblx0XHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZS5zaGlmdCgpW1JFQ09SRF9TWU1CT0xdID0gMDsgLy8gd2UgYXJlIGN5Y2xpbmcgYmFjayB0aHJvdWdoLCBhbmQgaGF2ZSB0byByZW1vdmUgb2xkIG9uZXNcblx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmUucHVzaCh0cmFuc2l0aW9uKTtcblx0XHRcdFx0cGFjayhrZXlzKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IGluc2VydE5ld1JlY29yZCA9ICh0cmFuc2l0aW9uLCBrZXlzLCBpbnNlcnRpb25PZmZzZXQsIG5ld1RyYW5zaXRpb25zKSA9PiB7XG5cdFx0XHRsZXQgbWFpblRhcmdldCA9IHRhcmdldDtcblx0XHRcdGxldCBtYWluUG9zaXRpb24gPSBwb3NpdGlvbjtcblx0XHRcdGxldCBtYWluU2FmZUVuZCA9IHNhZmVFbmQ7XG5cdFx0XHRsZXQgbWFpblN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHR0YXJnZXQgPSBrZXlzVGFyZ2V0O1xuXHRcdFx0cG9zaXRpb24gPSAwO1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0aWYgKCF0YXJnZXQpXG5cdFx0XHRcdGtleXNUYXJnZXQgPSB0YXJnZXQgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUoODE5Mik7XG5cdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHRcdFx0bmV3UmVjb3JkKHRyYW5zaXRpb24sIGtleXMsIG5ld1RyYW5zaXRpb25zKTtcblx0XHRcdGtleXNUYXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHRsZXQga2V5c1Bvc2l0aW9uID0gcG9zaXRpb247XG5cdFx0XHR0YXJnZXQgPSBtYWluVGFyZ2V0O1xuXHRcdFx0cG9zaXRpb24gPSBtYWluUG9zaXRpb247XG5cdFx0XHRzYWZlRW5kID0gbWFpblNhZmVFbmQ7XG5cdFx0XHRzdGFydCA9IG1haW5TdGFydDtcblx0XHRcdGlmIChrZXlzUG9zaXRpb24gPiAxKSB7XG5cdFx0XHRcdGxldCBuZXdFbmQgPSBwb3NpdGlvbiArIGtleXNQb3NpdGlvbiAtIDE7XG5cdFx0XHRcdGlmIChuZXdFbmQgPiBzYWZlRW5kKVxuXHRcdFx0XHRcdG1ha2VSb29tKG5ld0VuZCk7XG5cdFx0XHRcdGxldCBpbnNlcnRpb25Qb3NpdGlvbiA9IGluc2VydGlvbk9mZnNldCArIHN0YXJ0O1xuXHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihpbnNlcnRpb25Qb3NpdGlvbiArIGtleXNQb3NpdGlvbiwgaW5zZXJ0aW9uUG9zaXRpb24gKyAxLCBwb3NpdGlvbik7XG5cdFx0XHRcdHRhcmdldC5zZXQoa2V5c1RhcmdldC5zbGljZSgwLCBrZXlzUG9zaXRpb24pLCBpbnNlcnRpb25Qb3NpdGlvbik7XG5cdFx0XHRcdHBvc2l0aW9uID0gbmV3RW5kO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0W2luc2VydGlvbk9mZnNldCArIHN0YXJ0XSA9IGtleXNUYXJnZXRbMF07XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCB3cml0ZVN0cnVjdCA9IChvYmplY3QpID0+IHtcblx0XHRcdGxldCBuZXdQb3NpdGlvbiA9IHdyaXRlU3RydWN0U2xvdHMob2JqZWN0LCB0YXJnZXQsIHN0YXJ0LCBwb3NpdGlvbiwgc3RydWN0dXJlcywgbWFrZVJvb20sICh2YWx1ZSwgbmV3UG9zaXRpb24sIG5vdGlmeVNoYXJlZFVwZGF0ZSkgPT4ge1xuXHRcdFx0XHRpZiAobm90aWZ5U2hhcmVkVXBkYXRlKVxuXHRcdFx0XHRcdHJldHVybiBoYXNTaGFyZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuXHRcdFx0XHRsZXQgc3RhcnRUYXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHRcdHBhY2sodmFsdWUpO1xuXHRcdFx0XHRyZXNldFN0cnVjdHVyZXMoKTtcblx0XHRcdFx0aWYgKHN0YXJ0VGFyZ2V0ICE9PSB0YXJnZXQpIHtcblx0XHRcdFx0XHRyZXR1cm4geyBwb3NpdGlvbiwgdGFyZ2V0VmlldywgdGFyZ2V0IH07IC8vIGluZGljYXRlIHRoZSBidWZmZXIgd2FzIHJlLWFsbG9jYXRlZFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwb3NpdGlvbjtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0aWYgKG5ld1Bvc2l0aW9uID09PSAwKSAvLyBiYWlsIGFuZCBnbyB0byBhIG1zZ3BhY2sgb2JqZWN0XG5cdFx0XHRcdHJldHVybiB3cml0ZU9iamVjdChvYmplY3QpO1xuXHRcdFx0cG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcblx0XHR9O1xuXHR9XG5cdHVzZUJ1ZmZlcihidWZmZXIpIHtcblx0XHQvLyB0aGlzIG1lYW5zIHdlIGFyZSBmaW5pc2hlZCB1c2luZyBvdXIgb3duIGJ1ZmZlciBhbmQgd2UgY2FuIHdyaXRlIG92ZXIgaXQgc2FmZWx5XG5cdFx0dGFyZ2V0ID0gYnVmZmVyO1xuXHRcdHRhcmdldC5kYXRhVmlldyB8fCAodGFyZ2V0LmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aCkpO1xuXHRcdHBvc2l0aW9uID0gMDtcblx0fVxuXHRzZXQgcG9zaXRpb24gKHZhbHVlKSB7XG5cdFx0cG9zaXRpb24gPSB2YWx1ZTtcblx0fVxuXHRnZXQgcG9zaXRpb24oKSB7XG5cdFx0cmV0dXJuIHBvc2l0aW9uO1xuXHR9XG5cdGNsZWFyU2hhcmVkRGF0YSgpIHtcblx0XHRpZiAodGhpcy5zdHJ1Y3R1cmVzKVxuXHRcdFx0dGhpcy5zdHJ1Y3R1cmVzID0gW107XG5cdFx0aWYgKHRoaXMudHlwZWRTdHJ1Y3RzKVxuXHRcdFx0dGhpcy50eXBlZFN0cnVjdHMgPSBbXTtcblx0fVxufVxuXG5leHRlbnNpb25DbGFzc2VzID0gWyBEYXRlLCBTZXQsIEVycm9yLCBSZWdFeHAsIEFycmF5QnVmZmVyLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yIC8qVHlwZWRBcnJheSovLCBDMVR5cGUgXTtcbmV4dGVuc2lvbnMgPSBbe1xuXHRwYWNrKGRhdGUsIGFsbG9jYXRlRm9yV3JpdGUsIHBhY2spIHtcblx0XHRsZXQgc2Vjb25kcyA9IGRhdGUuZ2V0VGltZSgpIC8gMTAwMDtcblx0XHRpZiAoKHRoaXMudXNlVGltZXN0YW1wMzIgfHwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSA9PT0gMCkgJiYgc2Vjb25kcyA+PSAwICYmIHNlY29uZHMgPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0Ly8gVGltZXN0YW1wIDMyXG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoNik7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2O1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhmZjtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBzZWNvbmRzKTtcblx0XHR9IGVsc2UgaWYgKHNlY29uZHMgPiAwICYmIHNlY29uZHMgPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0Ly8gVGltZXN0YW1wIDY0XG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoMTApO1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNztcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmY7XG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAqIDQwMDAwMDAgKyAoKHNlY29uZHMgLyAxMDAwIC8gMHgxMDAwMDAwMDApID4+IDApKTtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uICsgNCwgc2Vjb25kcyk7XG5cdFx0fSBlbHNlIGlmIChpc05hTihzZWNvbmRzKSkge1xuXHRcdFx0aWYgKHRoaXMub25JbnZhbGlkRGF0ZSkge1xuXHRcdFx0XHRhbGxvY2F0ZUZvcldyaXRlKDApO1xuXHRcdFx0XHRyZXR1cm4gcGFjayh0aGlzLm9uSW52YWxpZERhdGUoKSlcblx0XHRcdH1cblx0XHRcdC8vIEludGVudGlvbmFsbHkgaW52YWxpZCB0aW1lc3RhbXBcblx0XHRcdGxldCB7IHRhcmdldCwgdGFyZ2V0VmlldywgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSgzKTtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQ7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmO1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhmZjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVGltZXN0YW1wIDk2XG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoMTUpO1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjNztcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDEyO1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhmZjtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpICogMTAwMDAwMCk7XG5cdFx0XHR0YXJnZXRWaWV3LnNldEJpZ0ludDY0KHBvc2l0aW9uICsgNCwgQmlnSW50KE1hdGguZmxvb3Ioc2Vjb25kcykpKTtcblx0XHR9XG5cdH1cbn0sIHtcblx0cGFjayhzZXQsIGFsbG9jYXRlRm9yV3JpdGUsIHBhY2spIHtcblx0XHRpZiAodGhpcy5zZXRBc0VtcHR5T2JqZWN0KSB7XG5cdFx0XHRhbGxvY2F0ZUZvcldyaXRlKDApO1xuXHRcdFx0cmV0dXJuIHBhY2soe30pXG5cdFx0fVxuXHRcdGxldCBhcnJheSA9IEFycmF5LmZyb20oc2V0KTtcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUodGhpcy5tb3JlVHlwZXMgPyAzIDogMCk7XG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKSB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0O1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3MzsgLy8gJ3MnIGZvciBTZXRcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDA7XG5cdFx0fVxuXHRcdHBhY2soYXJyYXkpO1xuXHR9XG59LCB7XG5cdHBhY2soZXJyb3IsIGFsbG9jYXRlRm9yV3JpdGUsIHBhY2spIHtcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUodGhpcy5tb3JlVHlwZXMgPyAzIDogMCk7XG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKSB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0O1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg2NTsgLy8gJ2UnIGZvciBlcnJvclxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMDtcblx0XHR9XG5cdFx0cGFjayhbIGVycm9yLm5hbWUsIGVycm9yLm1lc3NhZ2UsIGVycm9yLmNhdXNlIF0pO1xuXHR9XG59LCB7XG5cdHBhY2socmVnZXgsIGFsbG9jYXRlRm9yV3JpdGUsIHBhY2spIHtcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUodGhpcy5tb3JlVHlwZXMgPyAzIDogMCk7XG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKSB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0O1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3ODsgLy8gJ3gnIGZvciByZWdlWHBcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDA7XG5cdFx0fVxuXHRcdHBhY2soWyByZWdleC5zb3VyY2UsIHJlZ2V4LmZsYWdzIF0pO1xuXHR9XG59LCB7XG5cdHBhY2soYXJyYXlCdWZmZXIsIGFsbG9jYXRlRm9yV3JpdGUpIHtcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpXG5cdFx0XHR3cml0ZUV4dEJ1ZmZlcihhcnJheUJ1ZmZlciwgMHgxMCwgYWxsb2NhdGVGb3JXcml0ZSk7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVCdWZmZXIoaGFzTm9kZUJ1ZmZlciQxID8gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpIDogbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLCBhbGxvY2F0ZUZvcldyaXRlKTtcblx0fVxufSwge1xuXHRwYWNrKHR5cGVkQXJyYXksIGFsbG9jYXRlRm9yV3JpdGUpIHtcblx0XHRsZXQgY29uc3RydWN0b3IgPSB0eXBlZEFycmF5LmNvbnN0cnVjdG9yO1xuXHRcdGlmIChjb25zdHJ1Y3RvciAhPT0gQnl0ZUFycmF5ICYmIHRoaXMubW9yZVR5cGVzKVxuXHRcdFx0d3JpdGVFeHRCdWZmZXIodHlwZWRBcnJheSwgdHlwZWRBcnJheXMuaW5kZXhPZihjb25zdHJ1Y3Rvci5uYW1lKSwgYWxsb2NhdGVGb3JXcml0ZSk7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVCdWZmZXIodHlwZWRBcnJheSwgYWxsb2NhdGVGb3JXcml0ZSk7XG5cdH1cbn0sIHtcblx0cGFjayhjMSwgYWxsb2NhdGVGb3JXcml0ZSkgeyAvLyBzcGVjaWZpYyAweEMxIG9iamVjdFxuXHRcdGxldCB7IHRhcmdldCwgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSgxKTtcblx0XHR0YXJnZXRbcG9zaXRpb25dID0gMHhjMTtcblx0fVxufV07XG5cbmZ1bmN0aW9uIHdyaXRlRXh0QnVmZmVyKHR5cGVkQXJyYXksIHR5cGUsIGFsbG9jYXRlRm9yV3JpdGUsIGVuY29kZSkge1xuXHRsZXQgbGVuZ3RoID0gdHlwZWRBcnJheS5ieXRlTGVuZ3RoO1xuXHRpZiAobGVuZ3RoICsgMSA8IDB4MTAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZSg0ICsgbGVuZ3RoKTtcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM3O1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCArIDE7XG5cdH0gZWxzZSBpZiAobGVuZ3RoICsgMSA8IDB4MTAwMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKDUgKyBsZW5ndGgpO1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzg7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCArIDEpID4+IDg7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCArIDEpICYgMHhmZjtcblx0fSBlbHNlIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uLCB0YXJnZXRWaWV3IH0gPSBhbGxvY2F0ZUZvcldyaXRlKDcgKyBsZW5ndGgpO1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzk7XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aCArIDEpOyAvLyBwbHVzIG9uZSBmb3IgdGhlIHR5cGUgYnl0ZVxuXHRcdHBvc2l0aW9uICs9IDQ7XG5cdH1cblx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3NDsgLy8gXCJ0XCIgZm9yIHR5cGVkIGFycmF5XG5cdHRhcmdldFtwb3NpdGlvbisrXSA9IHR5cGU7XG5cdGlmICghdHlwZWRBcnJheS5idWZmZXIpIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5KTtcblx0dGFyZ2V0LnNldChuZXcgVWludDhBcnJheSh0eXBlZEFycmF5LmJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5LmJ5dGVMZW5ndGgpLCBwb3NpdGlvbik7XG59XG5mdW5jdGlvbiB3cml0ZUJ1ZmZlcihidWZmZXIsIGFsbG9jYXRlRm9yV3JpdGUpIHtcblx0bGV0IGxlbmd0aCA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuXHR2YXIgdGFyZ2V0LCBwb3NpdGlvbjtcblx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZShsZW5ndGggKyAyKTtcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM0O1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aDtcblx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZShsZW5ndGggKyAzKTtcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM1O1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4O1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmY7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiwgdGFyZ2V0VmlldyB9ID0gYWxsb2NhdGVGb3JXcml0ZShsZW5ndGggKyA1KTtcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM2O1xuXHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpO1xuXHRcdHBvc2l0aW9uICs9IDQ7XG5cdH1cblx0dGFyZ2V0LnNldChidWZmZXIsIHBvc2l0aW9uKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVFeHRlbnNpb25EYXRhKHJlc3VsdCwgdGFyZ2V0LCBwb3NpdGlvbiwgdHlwZSkge1xuXHRsZXQgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblx0c3dpdGNoIChsZW5ndGgpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0O1xuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDI6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ1O1xuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDQ6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2O1xuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDg6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ3O1xuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDE2OlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkODtcblx0XHRcdGJyZWFrXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM3O1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjODtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDg7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmY7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM5O1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gMjQ7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChsZW5ndGggPj4gMTYpICYgMHhmZjtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCA+PiA4KSAmIDB4ZmY7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmY7XG5cdFx0XHR9XG5cdH1cblx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdHlwZTtcblx0dGFyZ2V0LnNldChyZXN1bHQsIHBvc2l0aW9uKTtcblx0cG9zaXRpb24gKz0gbGVuZ3RoO1xuXHRyZXR1cm4gcG9zaXRpb25cbn1cblxuZnVuY3Rpb24gaW5zZXJ0SWRzKHNlcmlhbGl6ZWQsIGlkc1RvSW5zZXJ0KSB7XG5cdC8vIGluc2VydCB0aGUgaWRzIHRoYXQgbmVlZCB0byBiZSByZWZlcmVuY2VkIGZvciBzdHJ1Y3R1cmVkIGNsb25lc1xuXHRsZXQgbmV4dElkO1xuXHRsZXQgZGlzdGFuY2VUb01vdmUgPSBpZHNUb0luc2VydC5sZW5ndGggKiA2O1xuXHRsZXQgbGFzdEVuZCA9IHNlcmlhbGl6ZWQubGVuZ3RoIC0gZGlzdGFuY2VUb01vdmU7XG5cdHdoaWxlIChuZXh0SWQgPSBpZHNUb0luc2VydC5wb3AoKSkge1xuXHRcdGxldCBvZmZzZXQgPSBuZXh0SWQub2Zmc2V0O1xuXHRcdGxldCBpZCA9IG5leHRJZC5pZDtcblx0XHRzZXJpYWxpemVkLmNvcHlXaXRoaW4ob2Zmc2V0ICsgZGlzdGFuY2VUb01vdmUsIG9mZnNldCwgbGFzdEVuZCk7XG5cdFx0ZGlzdGFuY2VUb01vdmUgLT0gNjtcblx0XHRsZXQgcG9zaXRpb24gPSBvZmZzZXQgKyBkaXN0YW5jZVRvTW92ZTtcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gMHhkNjtcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gMHg2OTsgLy8gJ2knXG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IGlkID4+IDI0O1xuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAoaWQgPj4gMTYpICYgMHhmZjtcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gKGlkID4+IDgpICYgMHhmZjtcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gaWQgJiAweGZmO1xuXHRcdGxhc3RFbmQgPSBvZmZzZXQ7XG5cdH1cblx0cmV0dXJuIHNlcmlhbGl6ZWRcbn1cblxuZnVuY3Rpb24gd3JpdGVCdW5kbGVzKHN0YXJ0LCBwYWNrLCBpbmNyZW1lbnRQb3NpdGlvbikge1xuXHRpZiAoYnVuZGxlZFN0cmluZ3MubGVuZ3RoID4gMCkge1xuXHRcdHRhcmdldFZpZXcuc2V0VWludDMyKGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uICsgc3RhcnQsIHBvc2l0aW9uICsgaW5jcmVtZW50UG9zaXRpb24gLSBidW5kbGVkU3RyaW5ncy5wb3NpdGlvbiAtIHN0YXJ0KTtcblx0XHRidW5kbGVkU3RyaW5ncy5zdHJpbmdzUG9zaXRpb24gPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdGxldCB3cml0ZVN0cmluZ3MgPSBidW5kbGVkU3RyaW5ncztcblx0XHRidW5kbGVkU3RyaW5ncyA9IG51bGw7XG5cdFx0cGFjayh3cml0ZVN0cmluZ3NbMF0pO1xuXHRcdHBhY2sod3JpdGVTdHJpbmdzWzFdKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhZGRFeHRlbnNpb24oZXh0ZW5zaW9uKSB7XG5cdGlmIChleHRlbnNpb24uQ2xhc3MpIHtcblx0XHRpZiAoIWV4dGVuc2lvbi5wYWNrICYmICFleHRlbnNpb24ud3JpdGUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBoYXMgbm8gcGFjayBvciB3cml0ZSBmdW5jdGlvbicpXG5cdFx0aWYgKGV4dGVuc2lvbi5wYWNrICYmICFleHRlbnNpb24udHlwZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIGhhcyBubyB0eXBlIChudW1lcmljIGNvZGUgdG8gaWRlbnRpZnkgdGhlIGV4dGVuc2lvbiknKVxuXHRcdGV4dGVuc2lvbkNsYXNzZXMudW5zaGlmdChleHRlbnNpb24uQ2xhc3MpO1xuXHRcdGV4dGVuc2lvbnMudW5zaGlmdChleHRlbnNpb24pO1xuXHR9XG5cdGFkZEV4dGVuc2lvbiQxKGV4dGVuc2lvbik7XG59XG5mdW5jdGlvbiBwcmVwYXJlU3RydWN0dXJlcyQxKHN0cnVjdHVyZXMsIHBhY2tyKSB7XG5cdHN0cnVjdHVyZXMuaXNDb21wYXRpYmxlID0gKGV4aXN0aW5nU3RydWN0dXJlcykgPT4ge1xuXHRcdGxldCBjb21wYXRpYmxlID0gIWV4aXN0aW5nU3RydWN0dXJlcyB8fCAoKHBhY2tyLmxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGggfHwgMCkgPT09IGV4aXN0aW5nU3RydWN0dXJlcy5sZW5ndGgpO1xuXHRcdGlmICghY29tcGF0aWJsZSkgLy8gd2Ugd2FudCB0byBtZXJnZSB0aGVzZSBleGlzdGluZyBzdHJ1Y3R1cmVzIGltbWVkaWF0ZWx5IHNpbmNlIHdlIGFscmVhZHkgaGF2ZSBpdCBhbmQgd2UgYXJlIGluIHRoZSByaWdodCB0cmFuc2FjdGlvblxuXHRcdFx0cGFja3IuX21lcmdlU3RydWN0dXJlcyhleGlzdGluZ1N0cnVjdHVyZXMpO1xuXHRcdHJldHVybiBjb21wYXRpYmxlO1xuXHR9O1xuXHRyZXR1cm4gc3RydWN0dXJlc1xufVxuZnVuY3Rpb24gc2V0V3JpdGVTdHJ1Y3RTbG90cyh3cml0ZVNsb3RzLCBtYWtlU3RydWN0dXJlcykge1xuXHR3cml0ZVN0cnVjdFNsb3RzID0gd3JpdGVTbG90cztcblx0cHJlcGFyZVN0cnVjdHVyZXMkMSA9IG1ha2VTdHJ1Y3R1cmVzO1xufVxuXG5sZXQgZGVmYXVsdFBhY2tyID0gbmV3IFBhY2tyKHsgdXNlUmVjb3JkczogZmFsc2UgfSk7XG5jb25zdCBwYWNrID0gZGVmYXVsdFBhY2tyLnBhY2s7XG5jb25zdCBlbmNvZGUgPSBkZWZhdWx0UGFja3IucGFjaztcbmNvbnN0IEVuY29kZXIgPSBQYWNrcjtcbmNvbnN0IHsgTkVWRVIsIEFMV0FZUywgREVDSU1BTF9ST1VORCwgREVDSU1BTF9GSVQgfSA9IEZMT0FUMzJfT1BUSU9OUztcbmNvbnN0IFJFVVNFX0JVRkZFUl9NT0RFID0gNTEyO1xuY29uc3QgUkVTRVRfQlVGRkVSX01PREUgPSAxMDI0O1xuY29uc3QgUkVTRVJWRV9TVEFSVF9TUEFDRSA9IDIwNDg7XG5cbmNvbnN0IEFTQ0lJID0gMzsgLy8gdGhlIE1JQmVudW0gZnJvbSBodHRwczovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9jaGFyYWN0ZXItc2V0cy9jaGFyYWN0ZXItc2V0cy54aHRtbCAoYW5kIG90aGVyIGNoYXJhY3RlciBlbmNvZGluZ3MgY291bGQgYmUgcmVmZXJlbmNlZCBieSBNSUJlbnVtKVxuY29uc3QgTlVNQkVSID0gMDtcbmNvbnN0IFVURjggPSAyO1xuY29uc3QgT0JKRUNUX0RBVEEgPSAxO1xuY29uc3QgREFURSA9IDE2O1xuY29uc3QgVFlQRV9OQU1FUyA9IFsnbnVtJywgJ29iamVjdCcsICdzdHJpbmcnLCAnYXNjaWknXTtcblRZUEVfTkFNRVNbREFURV0gPSAnZGF0ZSc7XG5jb25zdCBmbG9hdDMySGVhZGVycyA9IFtmYWxzZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCB0cnVlLCB0cnVlLCBmYWxzZV07XG5sZXQgZXZhbFN1cHBvcnRlZDtcbnRyeSB7XG5cdG5ldyBGdW5jdGlvbignJyk7XG5cdGV2YWxTdXBwb3J0ZWQgPSB0cnVlO1xufSBjYXRjaChlcnJvcikge1xuXHQvLyBpZiBldmFsIHZhcmlhbnRzIGFyZSBub3Qgc3VwcG9ydGVkLCBkbyBub3QgY3JlYXRlIGlubGluZSBvYmplY3QgcmVhZGVycyBldmVyXG59XG5cbmxldCB1cGRhdGVkUG9zaXRpb247XG5jb25zdCBoYXNOb2RlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG5sZXQgdGV4dEVuY29kZXIsIGN1cnJlbnRTb3VyY2U7XG50cnkge1xuXHR0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xufSBjYXRjaCAoZXJyb3IpIHt9XG5jb25zdCBlbmNvZGVVdGY4ID0gaGFzTm9kZUJ1ZmZlciA/IGZ1bmN0aW9uKHRhcmdldCwgc3RyaW5nLCBwb3NpdGlvbikge1xuXHRyZXR1cm4gdGFyZ2V0LnV0ZjhXcml0ZShzdHJpbmcsIHBvc2l0aW9uLCAweGZmZmZmZmZmKVxufSA6ICh0ZXh0RW5jb2RlciAmJiB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKSA/XG5cdGZ1bmN0aW9uKHRhcmdldCwgc3RyaW5nLCBwb3NpdGlvbikge1xuXHRcdHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHN0cmluZywgdGFyZ2V0LnN1YmFycmF5KHBvc2l0aW9uKSkud3JpdHRlblxuXHR9IDogZmFsc2U7XG5zZXRXcml0ZVN0cnVjdFNsb3RzKHdyaXRlU3RydWN0LCBwcmVwYXJlU3RydWN0dXJlcyk7XG5mdW5jdGlvbiB3cml0ZVN0cnVjdChvYmplY3QsIHRhcmdldCwgZW5jb2RpbmdTdGFydCwgcG9zaXRpb24sIHN0cnVjdHVyZXMsIG1ha2VSb29tLCBwYWNrLCBwYWNrcikge1xuXHRsZXQgdHlwZWRTdHJ1Y3RzID0gcGFja3IudHlwZWRTdHJ1Y3RzIHx8IChwYWNrci50eXBlZFN0cnVjdHMgPSBbXSk7XG5cdC8vIG5vdGUgdGhhdCB3ZSByZWx5IG9uIHBhY2suanMgdG8gbG9hZCBzdG9yZWQgc3RydWN0dXJlcyBiZWZvcmUgd2UgZ2V0IHRvIHRoaXMgcG9pbnRcblx0bGV0IHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdGxldCByZWZzU3RhcnRQb3NpdGlvbiA9ICh0eXBlZFN0cnVjdHMubGFzdFN0cmluZ1N0YXJ0IHx8IDEwMCkgKyBwb3NpdGlvbjtcblx0bGV0IHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTA7XG5cdGxldCBzdGFydCA9IHBvc2l0aW9uO1xuXHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKSB7XG5cdFx0dGFyZ2V0ID0gbWFrZVJvb20ocG9zaXRpb24pO1xuXHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdFx0cG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRzdGFydCAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdHJlZnNTdGFydFBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0ZW5jb2RpbmdTdGFydCA9IDA7XG5cdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0fVxuXG5cdGxldCByZWZPZmZzZXQsIHJlZlBvc2l0aW9uID0gcmVmc1N0YXJ0UG9zaXRpb247XG5cblx0bGV0IHRyYW5zaXRpb24gPSB0eXBlZFN0cnVjdHMudHJhbnNpdGlvbnMgfHwgKHR5cGVkU3RydWN0cy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHRsZXQgbmV4dElkID0gdHlwZWRTdHJ1Y3RzLm5leHRJZCB8fCB0eXBlZFN0cnVjdHMubGVuZ3RoO1xuXHRsZXQgaGVhZGVyU2l6ZSA9XG5cdFx0bmV4dElkIDwgMHhmID8gMSA6XG5cdFx0XHRuZXh0SWQgPCAweGYwID8gMiA6XG5cdFx0XHRcdG5leHRJZCA8IDB4ZjAwMCA/IDMgOlxuXHRcdFx0XHRcdG5leHRJZCA8IDB4ZjAwMDAwID8gNCA6IDA7XG5cdGlmIChoZWFkZXJTaXplID09PSAwKVxuXHRcdHJldHVybiAwO1xuXHRwb3NpdGlvbiArPSBoZWFkZXJTaXplO1xuXHRsZXQgcXVldWVkUmVmZXJlbmNlcyA9IFtdO1xuXHRsZXQgdXNlZEFzY2lpMDtcblx0bGV0IGtleUluZGV4ID0gMDtcblx0Zm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuXHRcdGxldCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXHRcdGxldCBuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHR0cmFuc2l0aW9uW2tleV0gPSBuZXh0VHJhbnNpdGlvbiA9IHtcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRwYXJlbnQ6IHRyYW5zaXRpb24sXG5cdFx0XHRcdGVudW1lcmF0aW9uT2Zmc2V0OiAwLFxuXHRcdFx0XHRhc2NpaTA6IG51bGwsXG5cdFx0XHRcdGFzY2lpODogbnVsbCxcblx0XHRcdFx0bnVtODogbnVsbCxcblx0XHRcdFx0c3RyaW5nMTY6IG51bGwsXG5cdFx0XHRcdG9iamVjdDE2OiBudWxsLFxuXHRcdFx0XHRudW0zMjogbnVsbCxcblx0XHRcdFx0ZmxvYXQ2NDogbnVsbCxcblx0XHRcdFx0ZGF0ZTY0OiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKSB7XG5cdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbik7XG5cdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3O1xuXHRcdFx0cG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdHN0YXJ0IC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRyZWZzU3RhcnRQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0cmVmUG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdGVuY29kaW5nU3RhcnQgPSAwO1xuXHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0XHR9XG5cdFx0c3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcblx0XHRcdGNhc2UgJ251bWJlcic6XG5cdFx0XHRcdGxldCBudW1iZXIgPSB2YWx1ZTtcblx0XHRcdFx0Ly8gZmlyc3QgY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSB1c2luZyBhIGxvdCBvZiBpZHMgYW5kIHNob3VsZCBkZWZhdWx0IHRvIHdpZGUvY29tbW9uIGZvcm1hdFxuXHRcdFx0XHRpZiAobmV4dElkIDwgMjAwIHx8ICFuZXh0VHJhbnNpdGlvbi5udW02NCkge1xuXHRcdFx0XHRcdGlmIChudW1iZXIgPj4gMCA9PT0gbnVtYmVyICYmIG51bWJlciA8IDB4MjAwMDAwMDAgJiYgbnVtYmVyID4gLTB4MWYwMDAwMDApIHtcblx0XHRcdFx0XHRcdGlmIChudW1iZXIgPCAweGY2ICYmIG51bWJlciA+PSAwICYmIChuZXh0VHJhbnNpdGlvbi5udW04ICYmICEobmV4dElkID4gMjAwICYmIG5leHRUcmFuc2l0aW9uLm51bTMyKSB8fCBudW1iZXIgPCAweDIwICYmICFuZXh0VHJhbnNpdGlvbi5udW0zMikpIHtcblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTggfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgMSk7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IG51bWJlcjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5udW0zMiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgTlVNQkVSLCA0KTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIG51bWJlciwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwICYmIG51bWJlciA+PSAtMHg4MDAwMDAwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDMyKHBvc2l0aW9uLCBudW1iZXIsIHRydWUpO1xuXHRcdFx0XHRcdFx0aWYgKGZsb2F0MzJIZWFkZXJzW3RhcmdldFtwb3NpdGlvbiArIDNdID4+PiA1XSkge1xuXHRcdFx0XHRcdFx0XHRsZXQgeFNoaWZ0ZWQ7XG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgY2hlY2tzIGZvciByb3VuZGluZyBvZiBudW1iZXJzIHRoYXQgd2VyZSBlbmNvZGVkIGluIDMyLWJpdCBmbG9hdCB0byBuZWFyZXN0IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXQgdGhhdCBjb3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdFx0XHRcdFx0aWYgKCgoeFNoaWZ0ZWQgPSBudW1iZXIgKiBtdWx0MTBbKCh0YXJnZXRbcG9zaXRpb24gKyAzXSAmIDB4N2YpIDw8IDEpIHwgKHRhcmdldFtwb3NpdGlvbiArIDJdID4+IDcpXSkgPj4gMCkgPT09IHhTaGlmdGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTMyIHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDQpO1xuXHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTY0IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDgpO1xuXHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIG51bWJlciwgdHJ1ZSk7XG5cdFx0XHRcdHBvc2l0aW9uICs9IDg7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdFx0bGV0IHN0ckxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0cmVmT2Zmc2V0ID0gcmVmUG9zaXRpb24gLSByZWZzU3RhcnRQb3NpdGlvbjtcblx0XHRcdFx0aWYgKChzdHJMZW5ndGggPDwgMikgKyByZWZQb3NpdGlvbiA+IHNhZmVFbmQpIHtcblx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbSgoc3RyTGVuZ3RoIDw8IDIpICsgcmVmUG9zaXRpb24pO1xuXHRcdFx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0XHRzdGFydCAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRcdHJlZnNTdGFydFBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRcdFx0cmVmUG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0XHRlbmNvZGluZ1N0YXJ0ID0gMDtcblx0XHRcdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPiAoKDB4ZmYwMCArIHJlZk9mZnNldCkgPj4gMikpIHtcblx0XHRcdFx0XHRxdWV1ZWRSZWZlcmVuY2VzLnB1c2goa2V5LCB2YWx1ZSwgcG9zaXRpb24gLSBzdGFydCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IGlzTm90QXNjaWk7XG5cdFx0XHRcdGxldCBzdHJTdGFydCA9IHJlZlBvc2l0aW9uO1xuXHRcdFx0XHRpZiAoc3RyTGVuZ3RoIDwgMHg0MCkge1xuXHRcdFx0XHRcdGxldCBpLCBjMSwgYzI7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHN0ckxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjMSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRcdFx0XHRpZiAoYzEgPCAweDgwKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjMSA8IDB4ODAwKSB7XG5cdFx0XHRcdFx0XHRcdGlzTm90QXNjaWkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiA2IHwgMHhjMDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0XHRcdChjMSAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxuXHRcdFx0XHRcdFx0XHQoKGMyID0gdmFsdWUuY2hhckNvZGVBdChpICsgMSkpICYgMHhmYzAwKSA9PT0gMHhkYzAwXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0aXNOb3RBc2NpaSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG5cdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgPj4gMTggfCAweGYwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiAxMiAmIDB4M2YgfCAweDgwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpc05vdEFzY2lpID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgPj4gMTIgfCAweGUwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlZlBvc2l0aW9uICs9IGVuY29kZVV0ZjgodGFyZ2V0LCB2YWx1ZSwgcmVmUG9zaXRpb24pO1xuXHRcdFx0XHRcdGlzTm90QXNjaWkgPSByZWZQb3NpdGlvbiAtIHN0clN0YXJ0ID4gc3RyTGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZWZPZmZzZXQgPCAweGEwIHx8IChyZWZPZmZzZXQgPCAweGY2ICYmIChuZXh0VHJhbnNpdGlvbi5hc2NpaTggfHwgbmV4dFRyYW5zaXRpb24uc3RyaW5nOCkpKSB7XG5cdFx0XHRcdFx0Ly8gc2hvcnQgc3RyaW5nc1xuXHRcdFx0XHRcdGlmIChpc05vdEFzY2lpKSB7XG5cdFx0XHRcdFx0XHRpZiAoISh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uc3RyaW5nOCkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVkU3RydWN0cy5sZW5ndGggPiAxMCAmJiAodHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLmFzY2lpOCkpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBjYW4gc2FmZWx5IGNoYW5nZSBhc2NpaSB0byB1dGY4IGluIHBsYWNlIHNpbmNlIHRoZXkgYXJlIGNvbXBhdGlibGVcblx0XHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uLl9fdHlwZSA9IFVURjg7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24uYXNjaWk4ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbi5zdHJpbmc4ID0gdHJhbnNpdGlvbjtcblx0XHRcdFx0XHRcdFx0XHRwYWNrKG51bGwsIDAsIHRydWUpOyAvLyBzcGVjaWFsIGNhbGwgdG8gbm90aWZ5IHRoYXQgc3RydWN0dXJlcyBoYXZlIGJlZW4gdXBkYXRlZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgVVRGOCwgMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJlZk9mZnNldCA9PT0gMCAmJiAhdXNlZEFzY2lpMCkge1xuXHRcdFx0XHRcdFx0dXNlZEFzY2lpMCA9IHRydWU7XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uYXNjaWkwIHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBBU0NJSSwgMCk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gZG9uJ3QgaW5jcmVtZW50IHBvc2l0aW9uXG5cdFx0XHRcdFx0fS8vIGVsc2UgYXNjaWk6XG5cdFx0XHRcdFx0ZWxzZSBpZiAoISh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uYXNjaWk4KSAmJiAhKHR5cGVkU3RydWN0cy5sZW5ndGggPiAxMCAmJiAodHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLnN0cmluZzgpKSlcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgQVNDSUksIDEpO1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlZk9mZnNldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBUT0RPOiBFbmFibGUgYXNjaWkxNiBhdCBzb21lIHBvaW50LCBidXQgZ2V0IHRoZSBsb2dpYyByaWdodFxuXHRcdFx0XHRcdC8vaWYgKGlzTm90QXNjaWkpXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uc3RyaW5nMTYgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIFVURjgsIDIpO1xuXHRcdFx0XHRcdC8vZWxzZVxuXHRcdFx0XHRcdFx0Ly90cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uYXNjaWkxNiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgQVNDSUksIDIpO1xuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDE2KHBvc2l0aW9uLCByZWZPZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdvYmplY3QnOlxuXHRcdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IERhdGUpIHtcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5kYXRlNjQgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIERBVEUsIDgpO1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDY0KHBvc2l0aW9uLCB2YWx1ZS5nZXRUaW1lKCksIHRydWUpO1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gODtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIGtleUluZGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSB7IC8vIG51bGxcblx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IGFueVR5cGUobmV4dFRyYW5zaXRpb24sIHBvc2l0aW9uLCB0YXJnZXRWaWV3LCAtMTApOyAvLyBtYXRjaCBDQk9SIHdpdGggdGhpc1xuXHRcdFx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uO1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gPSB1cGRhdGVkUG9zaXRpb247XG5cdFx0XHRcdFx0fSBlbHNlIHF1ZXVlZFJlZmVyZW5jZXMucHVzaChrZXksIHZhbHVlLCBrZXlJbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdib29sZWFuJzpcblx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTggfHwgbmV4dFRyYW5zaXRpb24uYXNjaWk4IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDEpO1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSA/IDB4ZjkgOiAweGY4OyAvLyBtYXRjaCBDQk9SIHdpdGggdGhlc2Vcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd1bmRlZmluZWQnOlxuXHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IGFueVR5cGUobmV4dFRyYW5zaXRpb24sIHBvc2l0aW9uLCB0YXJnZXRWaWV3LCAtOSk7IC8vIG1hdGNoIENCT1Igd2l0aCB0aGlzXG5cdFx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbjtcblx0XHRcdFx0XHRwb3NpdGlvbiA9IHVwZGF0ZWRQb3NpdGlvbjtcblx0XHRcdFx0fSBlbHNlIHF1ZXVlZFJlZmVyZW5jZXMucHVzaChrZXksIHZhbHVlLCBrZXlJbmRleCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIGtleUluZGV4KTtcblx0XHR9XG5cdFx0a2V5SW5kZXgrKztcblx0fVxuXG5cdGZvciAobGV0IGkgPSAwLCBsID0gcXVldWVkUmVmZXJlbmNlcy5sZW5ndGg7IGkgPCBsOykge1xuXHRcdGxldCBrZXkgPSBxdWV1ZWRSZWZlcmVuY2VzW2krK107XG5cdFx0bGV0IHZhbHVlID0gcXVldWVkUmVmZXJlbmNlc1tpKytdO1xuXHRcdGxldCBwcm9wZXJ0eUluZGV4ID0gcXVldWVkUmVmZXJlbmNlc1tpKytdO1xuXHRcdGxldCBuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHR0cmFuc2l0aW9uW2tleV0gPSBuZXh0VHJhbnNpdGlvbiA9IHtcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRwYXJlbnQ6IHRyYW5zaXRpb24sXG5cdFx0XHRcdGVudW1lcmF0aW9uT2Zmc2V0OiBwcm9wZXJ0eUluZGV4IC0ga2V5SW5kZXgsXG5cdFx0XHRcdGFzY2lpMDogbnVsbCxcblx0XHRcdFx0YXNjaWk4OiBudWxsLFxuXHRcdFx0XHRudW04OiBudWxsLFxuXHRcdFx0XHRzdHJpbmcxNjogbnVsbCxcblx0XHRcdFx0b2JqZWN0MTY6IG51bGwsXG5cdFx0XHRcdG51bTMyOiBudWxsLFxuXHRcdFx0XHRmbG9hdDY0OiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRsZXQgbmV3UG9zaXRpb247XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHQvKmlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7IC8vIFRPRE86IHdlIGNvdWxkIHJlLWVuYWJsZSBsb25nIHN0cmluZ3Ncblx0XHRcdFx0aWYgKHBvc2l0aW9uICsgdmFsdWUubGVuZ3RoICogMyA+IHNhZmVFbmQpIHtcblx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbiArIHZhbHVlLmxlbmd0aCAqIDMpO1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IHN0YXJ0O1xuXHRcdFx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdFx0XHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld1Bvc2l0aW9uID0gcG9zaXRpb24gKyB0YXJnZXQudXRmOFdyaXRlKHZhbHVlLCBwb3NpdGlvbiwgMHhmZmZmZmZmZik7XG5cdFx0XHR9IGVsc2UgeyAqL1xuXHRcdFx0bGV0IHNpemU7XG5cdFx0XHRyZWZPZmZzZXQgPSByZWZQb3NpdGlvbiAtIHJlZnNTdGFydFBvc2l0aW9uO1xuXHRcdFx0aWYgKHJlZk9mZnNldCA8IDB4ZmYwMCkge1xuXHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ub2JqZWN0MTY7XG5cdFx0XHRcdGlmICh0cmFuc2l0aW9uKVxuXHRcdFx0XHRcdHNpemUgPSAyO1xuXHRcdFx0XHRlbHNlIGlmICgodHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm9iamVjdDMyKSlcblx0XHRcdFx0XHRzaXplID0gNDtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dHJhbnNpdGlvbiA9IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBPQkpFQ1RfREFUQSwgMik7XG5cdFx0XHRcdFx0c2l6ZSA9IDI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5vYmplY3QzMiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgT0JKRUNUX0RBVEEsIDQpO1xuXHRcdFx0XHRzaXplID0gNDtcblx0XHRcdH1cblx0XHRcdG5ld1Bvc2l0aW9uID0gcGFjayh2YWx1ZSwgcmVmUG9zaXRpb24pO1xuXHRcdFx0Ly99XG5cdFx0XHRpZiAodHlwZW9mIG5ld1Bvc2l0aW9uID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHQvLyByZS1hbGxvY2F0ZWRcblx0XHRcdFx0cmVmUG9zaXRpb24gPSBuZXdQb3NpdGlvbi5wb3NpdGlvbjtcblx0XHRcdFx0dGFyZ2V0VmlldyA9IG5ld1Bvc2l0aW9uLnRhcmdldFZpZXc7XG5cdFx0XHRcdHRhcmdldCA9IG5ld1Bvc2l0aW9uLnRhcmdldDtcblx0XHRcdFx0cmVmc1N0YXJ0UG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0cG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0c3RhcnQgLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0ZW5jb2RpbmdTdGFydCA9IDA7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0cmVmUG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcblx0XHRcdGlmIChzaXplID09PSAyKSB7XG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDE2KHBvc2l0aW9uLCByZWZPZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRwb3NpdGlvbiArPSAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIHJlZk9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgLy8gbnVsbCBvciB1bmRlZmluZWRcblx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5vYmplY3QxNiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgT0JKRUNUX0RBVEEsIDIpO1xuXHRcdFx0dGFyZ2V0Vmlldy5zZXRJbnQxNihwb3NpdGlvbiwgdmFsdWUgPT09IG51bGwgPyAtMTAgOiAtOSwgdHJ1ZSk7XG5cdFx0XHRwb3NpdGlvbiArPSAyO1xuXHRcdH1cblx0XHRrZXlJbmRleCsrO1xuXHR9XG5cblxuXHRsZXQgcmVjb3JkSWQgPSB0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdO1xuXHRpZiAocmVjb3JkSWQgPT0gbnVsbCkge1xuXHRcdHJlY29yZElkID0gcGFja3IudHlwZWRTdHJ1Y3RzLmxlbmd0aDtcblx0XHRsZXQgc3RydWN0dXJlID0gW107XG5cdFx0bGV0IG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblx0XHRsZXQga2V5LCB0eXBlO1xuXHRcdHdoaWxlICgodHlwZSA9IG5leHRUcmFuc2l0aW9uLl9fdHlwZSkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bGV0IHNpemUgPSBuZXh0VHJhbnNpdGlvbi5fX3NpemU7XG5cdFx0XHRuZXh0VHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLl9fcGFyZW50O1xuXHRcdFx0a2V5ID0gbmV4dFRyYW5zaXRpb24ua2V5O1xuXHRcdFx0bGV0IHByb3BlcnR5ID0gW3R5cGUsIHNpemUsIGtleV07XG5cdFx0XHRpZiAobmV4dFRyYW5zaXRpb24uZW51bWVyYXRpb25PZmZzZXQpXG5cdFx0XHRcdHByb3BlcnR5LnB1c2gobmV4dFRyYW5zaXRpb24uZW51bWVyYXRpb25PZmZzZXQpO1xuXHRcdFx0c3RydWN0dXJlLnB1c2gocHJvcGVydHkpO1xuXHRcdFx0bmV4dFRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5wYXJlbnQ7XG5cdFx0fVxuXHRcdHN0cnVjdHVyZS5yZXZlcnNlKCk7XG5cdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IHJlY29yZElkO1xuXHRcdHBhY2tyLnR5cGVkU3RydWN0c1tyZWNvcmRJZF0gPSBzdHJ1Y3R1cmU7XG5cdFx0cGFjayhudWxsLCAwLCB0cnVlKTsgLy8gc3BlY2lhbCBjYWxsIHRvIG5vdGlmeSB0aGF0IHN0cnVjdHVyZXMgaGF2ZSBiZWVuIHVwZGF0ZWRcblx0fVxuXG5cblx0c3dpdGNoIChoZWFkZXJTaXplKSB7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0aWYgKHJlY29yZElkID49IDB4MTApIHJldHVybiAwO1xuXHRcdFx0dGFyZ2V0W3N0YXJ0XSA9IHJlY29yZElkICsgMHgyMDtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDEwMCkgcmV0dXJuIDA7XG5cdFx0XHR0YXJnZXRbc3RhcnRdID0gMHgzODtcblx0XHRcdHRhcmdldFtzdGFydCArIDFdID0gcmVjb3JkSWQ7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRpZiAocmVjb3JkSWQgPj0gMHgxMDAwMCkgcmV0dXJuIDA7XG5cdFx0XHR0YXJnZXRbc3RhcnRdID0gMHgzOTtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDE2KHN0YXJ0ICsgMSwgcmVjb3JkSWQsIHRydWUpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA0OlxuXHRcdFx0aWYgKHJlY29yZElkID49IDB4MTAwMDAwMCkgcmV0dXJuIDA7XG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihzdGFydCwgKHJlY29yZElkIDw8IDgpICsgMHgzYSwgdHJ1ZSk7XG5cdFx0XHRicmVhaztcblx0fVxuXG5cdGlmIChwb3NpdGlvbiA8IHJlZnNTdGFydFBvc2l0aW9uKSB7XG5cdFx0aWYgKHJlZnNTdGFydFBvc2l0aW9uID09PSByZWZQb3NpdGlvbilcblx0XHRcdHJldHVybiBwb3NpdGlvbjsgLy8gbm8gcmVmc1xuXHRcdC8vIGFkanVzdCBwb3NpdGlvbmluZ1xuXHRcdHRhcmdldC5jb3B5V2l0aGluKHBvc2l0aW9uLCByZWZzU3RhcnRQb3NpdGlvbiwgcmVmUG9zaXRpb24pO1xuXHRcdHJlZlBvc2l0aW9uICs9IHBvc2l0aW9uIC0gcmVmc1N0YXJ0UG9zaXRpb247XG5cdFx0dHlwZWRTdHJ1Y3RzLmxhc3RTdHJpbmdTdGFydCA9IHBvc2l0aW9uIC0gc3RhcnQ7XG5cdH0gZWxzZSBpZiAocG9zaXRpb24gPiByZWZzU3RhcnRQb3NpdGlvbikge1xuXHRcdGlmIChyZWZzU3RhcnRQb3NpdGlvbiA9PT0gcmVmUG9zaXRpb24pXG5cdFx0XHRyZXR1cm4gcG9zaXRpb247IC8vIG5vIHJlZnNcblx0XHR0eXBlZFN0cnVjdHMubGFzdFN0cmluZ1N0YXJ0ID0gcG9zaXRpb24gLSBzdGFydDtcblx0XHRyZXR1cm4gd3JpdGVTdHJ1Y3Qob2JqZWN0LCB0YXJnZXQsIGVuY29kaW5nU3RhcnQsIHN0YXJ0LCBzdHJ1Y3R1cmVzLCBtYWtlUm9vbSwgcGFjaywgcGFja3IpO1xuXHR9XG5cdHJldHVybiByZWZQb3NpdGlvbjtcbn1cbmZ1bmN0aW9uIGFueVR5cGUodHJhbnNpdGlvbiwgcG9zaXRpb24sIHRhcmdldFZpZXcsIHZhbHVlKSB7XG5cdGxldCBuZXh0VHJhbnNpdGlvbjtcblx0aWYgKChuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb24uYXNjaWk4IHx8IHRyYW5zaXRpb24ubnVtOCkpIHtcblx0XHR0YXJnZXRWaWV3LnNldEludDgocG9zaXRpb24sIHZhbHVlLCB0cnVlKTtcblx0XHR1cGRhdGVkUG9zaXRpb24gPSBwb3NpdGlvbiArIDE7XG5cdFx0cmV0dXJuIG5leHRUcmFuc2l0aW9uO1xuXHR9XG5cdGlmICgobmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uLnN0cmluZzE2IHx8IHRyYW5zaXRpb24ub2JqZWN0MTYpKSB7XG5cdFx0dGFyZ2V0Vmlldy5zZXRJbnQxNihwb3NpdGlvbiwgdmFsdWUsIHRydWUpO1xuXHRcdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgMjtcblx0XHRyZXR1cm4gbmV4dFRyYW5zaXRpb247XG5cdH1cblx0aWYgKG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbi5udW0zMikge1xuXHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCAweGUwMDAwMTAwICsgdmFsdWUsIHRydWUpO1xuXHRcdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgNDtcblx0XHRyZXR1cm4gbmV4dFRyYW5zaXRpb247XG5cdH1cblx0Ly8gdHJhbnNpdGlvbi5mbG9hdDY0XG5cdGlmIChuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb24ubnVtNjQpIHtcblx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIE5hTiwgdHJ1ZSk7XG5cdFx0dGFyZ2V0Vmlldy5zZXRJbnQ4KHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0dXBkYXRlZFBvc2l0aW9uID0gcG9zaXRpb24gKyA4O1xuXHRcdHJldHVybiBuZXh0VHJhbnNpdGlvbjtcblx0fVxuXHR1cGRhdGVkUG9zaXRpb24gPSBwb3NpdGlvbjtcblx0Ly8gVE9ETzogY2FuIHdlIGRvIGFuIFwiYW55XCIgdHlwZSB3aGVyZSB3ZSBkZWZlciB0aGUgZGVjaXNpb24/XG5cdHJldHVybjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVUcmFuc2l0aW9uKHRyYW5zaXRpb24sIHR5cGUsIHNpemUpIHtcblx0bGV0IHR5cGVOYW1lID0gVFlQRV9OQU1FU1t0eXBlXSArIChzaXplIDw8IDMpO1xuXHRsZXQgbmV3VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25bdHlwZU5hbWVdIHx8ICh0cmFuc2l0aW9uW3R5cGVOYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHRuZXdUcmFuc2l0aW9uLl9fdHlwZSA9IHR5cGU7XG5cdG5ld1RyYW5zaXRpb24uX19zaXplID0gc2l6ZTtcblx0bmV3VHJhbnNpdGlvbi5fX3BhcmVudCA9IHRyYW5zaXRpb247XG5cdHJldHVybiBuZXdUcmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gb25Mb2FkZWRTdHJ1Y3R1cmVzKHNoYXJlZERhdGEpIHtcblx0aWYgKCEoc2hhcmVkRGF0YSBpbnN0YW5jZW9mIE1hcCkpXG5cdFx0cmV0dXJuIHNoYXJlZERhdGE7XG5cdGxldCB0eXBlZCA9IHNoYXJlZERhdGEuZ2V0KCd0eXBlZCcpIHx8IFtdO1xuXHRpZiAoT2JqZWN0LmlzRnJvemVuKHR5cGVkKSlcblx0XHR0eXBlZCA9IHR5cGVkLm1hcChzdHJ1Y3R1cmUgPT4gc3RydWN0dXJlLnNsaWNlKDApKTtcblx0bGV0IG5hbWVkID0gc2hhcmVkRGF0YS5nZXQoJ25hbWVkJyk7XG5cdGxldCB0cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGZvciAobGV0IGkgPSAwLCBsID0gdHlwZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0bGV0IHN0cnVjdHVyZSA9IHR5cGVkW2ldO1xuXHRcdGxldCB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbnM7XG5cdFx0Zm9yIChsZXQgW3R5cGUsIHNpemUsIGtleV0gb2Ygc3RydWN0dXJlKSB7XG5cdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV07XG5cdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdHRyYW5zaXRpb25ba2V5XSA9IG5leHRUcmFuc2l0aW9uID0ge1xuXHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRwYXJlbnQ6IHRyYW5zaXRpb24sXG5cdFx0XHRcdFx0ZW51bWVyYXRpb25PZmZzZXQ6IDAsXG5cdFx0XHRcdFx0YXNjaWkwOiBudWxsLFxuXHRcdFx0XHRcdGFzY2lpODogbnVsbCxcblx0XHRcdFx0XHRudW04OiBudWxsLFxuXHRcdFx0XHRcdHN0cmluZzE2OiBudWxsLFxuXHRcdFx0XHRcdG9iamVjdDE2OiBudWxsLFxuXHRcdFx0XHRcdG51bTMyOiBudWxsLFxuXHRcdFx0XHRcdGZsb2F0NjQ6IG51bGwsXG5cdFx0XHRcdFx0ZGF0ZTY0OiBudWxsLFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0dHJhbnNpdGlvbiA9IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCB0eXBlLCBzaXplKTtcblx0XHR9XG5cdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IGk7XG5cdH1cblx0dHlwZWQudHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcblx0dGhpcy50eXBlZFN0cnVjdHMgPSB0eXBlZDtcblx0dGhpcy5sYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gdHlwZWQubGVuZ3RoO1xuXHRyZXR1cm4gbmFtZWQ7XG59XG52YXIgc291cmNlU3ltYm9sID0gU3ltYm9sLmZvcignc291cmNlJyk7XG5mdW5jdGlvbiByZWFkU3RydWN0KHNyYywgcG9zaXRpb24sIHNyY0VuZCwgdW5wYWNrcikge1xuXHRsZXQgcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK10gLSAweDIwO1xuXHRpZiAocmVjb3JkSWQgPj0gMjQpIHtcblx0XHRzd2l0Y2gocmVjb3JkSWQpIHtcblx0XHRcdGNhc2UgMjQ6IHJlY29yZElkID0gc3JjW3Bvc2l0aW9uKytdOyBicmVhaztcblx0XHRcdC8vIGxpdHRsZSBlbmRpYW46XG5cdFx0XHRjYXNlIDI1OiByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXSArIChzcmNbcG9zaXRpb24rK10gPDwgOCk7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyNjogcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK10gKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDgpICsgKHNyY1twb3NpdGlvbisrXSA8PCAxNik7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyNzogcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK10gKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDgpICsgKHNyY1twb3NpdGlvbisrXSA8PCAxNikgKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDI0KTsgYnJlYWs7XG5cdFx0fVxuXHR9XG5cdGxldCBzdHJ1Y3R1cmUgPSB1bnBhY2tyLnR5cGVkU3RydWN0cyAmJiB1bnBhY2tyLnR5cGVkU3RydWN0c1tyZWNvcmRJZF07XG5cdGlmICghc3RydWN0dXJlKSB7XG5cdFx0Ly8gY29weSBzcmMgYnVmZmVyIGJlY2F1c2UgZ2V0U3RydWN0dXJlcyB3aWxsIG92ZXJyaWRlIGl0XG5cdFx0c3JjID0gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzcmMsIHBvc2l0aW9uLCBzcmNFbmQpO1xuXHRcdHNyY0VuZCAtPSBwb3NpdGlvbjtcblx0XHRwb3NpdGlvbiA9IDA7XG5cdFx0aWYgKCF1bnBhY2tyLmdldFN0cnVjdHVyZXMpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFJlZmVyZW5jZSB0byBzaGFyZWQgc3RydWN0dXJlICR7cmVjb3JkSWR9IHdpdGhvdXQgZ2V0U3RydWN0dXJlcyBtZXRob2RgKTtcblx0XHR1bnBhY2tyLl9tZXJnZVN0cnVjdHVyZXModW5wYWNrci5nZXRTdHJ1Y3R1cmVzKCkpO1xuXHRcdGlmICghdW5wYWNrci50eXBlZFN0cnVjdHMpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGFueSBzaGFyZWQgdHlwZWQgc3RydWN0dXJlcycpO1xuXHRcdHVucGFja3IubGFzdFR5cGVkU3RydWN0dXJlc0xlbmd0aCA9IHVucGFja3IudHlwZWRTdHJ1Y3RzLmxlbmd0aDtcblx0XHRzdHJ1Y3R1cmUgPSB1bnBhY2tyLnR5cGVkU3RydWN0c1tyZWNvcmRJZF07XG5cdFx0aWYgKCFzdHJ1Y3R1cmUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHR5cGVkIHN0cnVjdHVyZSAnICsgcmVjb3JkSWQpO1xuXHR9XG5cdHZhciBjb25zdHJ1Y3QgPSBzdHJ1Y3R1cmUuY29uc3RydWN0O1xuXHRpZiAoIWNvbnN0cnVjdCkge1xuXHRcdGNvbnN0cnVjdCA9IHN0cnVjdHVyZS5jb25zdHJ1Y3QgPSBmdW5jdGlvbiBMYXp5T2JqZWN0KCkge1xuXHRcdH07XG5cdFx0dmFyIHByb3RvdHlwZSA9IGNvbnN0cnVjdC5wcm90b3R5cGU7XG5cdFx0bGV0IHByb3BlcnRpZXMgPSBbXTtcblx0XHRsZXQgY3VycmVudE9mZnNldCA9IDA7XG5cdFx0bGV0IGxhc3RSZWZQcm9wZXJ0eTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHN0cnVjdHVyZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGxldCBkZWZpbml0aW9uID0gc3RydWN0dXJlW2ldO1xuXHRcdFx0bGV0IFsgdHlwZSwgc2l6ZSwga2V5LCBlbnVtZXJhdGlvbk9mZnNldCBdID0gZGVmaW5pdGlvbjtcblx0XHRcdGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuXHRcdFx0XHRrZXkgPSAnX19wcm90b18nO1xuXHRcdFx0bGV0IHByb3BlcnR5ID0ge1xuXHRcdFx0XHRrZXksXG5cdFx0XHRcdG9mZnNldDogY3VycmVudE9mZnNldCxcblx0XHRcdH07XG5cdFx0XHRpZiAoZW51bWVyYXRpb25PZmZzZXQpXG5cdFx0XHRcdHByb3BlcnRpZXMuc3BsaWNlKGkgKyBlbnVtZXJhdGlvbk9mZnNldCwgMCwgcHJvcGVydHkpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuXHRcdFx0bGV0IGdldFJlZjtcblx0XHRcdHN3aXRjaChzaXplKSB7IC8vIFRPRE86IE1vdmUgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uXG5cdFx0XHRcdGNhc2UgMDogZ2V0UmVmID0gKCkgPT4gMDsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRnZXRSZWYgPSAoc291cmNlLCBwb3NpdGlvbikgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IHJlZiA9IHNvdXJjZS5ieXRlc1twb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldF07XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVmID49IDB4ZjYgPyB0b0NvbnN0YW50KHJlZikgOiByZWY7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdGdldFJlZiA9IChzb3VyY2UsIHBvc2l0aW9uKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRsZXQgcmVmID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRcdHJldHVybiByZWYgPj0gMHhmZjAwID8gdG9Db25zdGFudChyZWYgJiAweGZmKSA6IHJlZjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0Z2V0UmVmID0gKHNvdXJjZSwgcG9zaXRpb24pID0+IHtcblx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZiA+PSAweGZmZmZmZjAwID8gdG9Db25zdGFudChyZWYgJiAweGZmKSA6IHJlZjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cHJvcGVydHkuZ2V0UmVmID0gZ2V0UmVmO1xuXHRcdFx0Y3VycmVudE9mZnNldCArPSBzaXplO1xuXHRcdFx0bGV0IGdldDtcblx0XHRcdHN3aXRjaCh0eXBlKSB7XG5cdFx0XHRcdGNhc2UgQVNDSUk6XG5cdFx0XHRcdFx0aWYgKGxhc3RSZWZQcm9wZXJ0eSAmJiAhbGFzdFJlZlByb3BlcnR5Lm5leHQpXG5cdFx0XHRcdFx0XHRsYXN0UmVmUHJvcGVydHkubmV4dCA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdGxhc3RSZWZQcm9wZXJ0eSA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdHByb3BlcnR5Lm11bHRpR2V0Q291bnQgPSAwO1xuXHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdGxldCBwb3NpdGlvbiA9IHNvdXJjZS5wb3NpdGlvbjtcblx0XHRcdFx0XHRcdGxldCByZWZTdGFydCA9IGN1cnJlbnRPZmZzZXQgKyBwb3NpdGlvbjtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBnZXRSZWYoc291cmNlLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHJlZiAhPT0gJ251bWJlcicpIHJldHVybiByZWY7XG5cblx0XHRcdFx0XHRcdGxldCBlbmQsIG5leHQgPSBwcm9wZXJ0eS5uZXh0O1xuXHRcdFx0XHRcdFx0d2hpbGUobmV4dCkge1xuXHRcdFx0XHRcdFx0XHRlbmQgPSBuZXh0LmdldFJlZihzb3VyY2UsIHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBlbmQgPT09ICdudW1iZXInKVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0ZW5kID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0bmV4dCA9IG5leHQubmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChlbmQgPT0gbnVsbClcblx0XHRcdFx0XHRcdFx0ZW5kID0gc291cmNlLmJ5dGVzRW5kIC0gcmVmU3RhcnQ7XG5cdFx0XHRcdFx0XHRpZiAoc291cmNlLnNyY1N0cmluZykge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc291cmNlLnNyY1N0cmluZy5zbGljZShyZWYsIGVuZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvKmlmIChwcm9wZXJ0eS5tdWx0aUdldENvdW50ID4gMCkge1xuXHRcdFx0XHRcdFx0XHRsZXQgYXNjaWlFbmQ7XG5cdFx0XHRcdFx0XHRcdG5leHQgPSBmaXJzdFJlZlByb3BlcnR5O1xuXHRcdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0XHRcdGFzY2lpRW5kID0gZGF0YVZpZXcuZ2V0VWludDE2KHNvdXJjZS5wb3NpdGlvbiArIG5leHQub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoYXNjaWlFbmQgPCAweGZmMDApXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0XHRhc2NpaUVuZCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH0gd2hpbGUoKG5leHQgPSBuZXh0Lm5leHQpKTtcblx0XHRcdFx0XHRcdFx0aWYgKGFzY2lpRW5kID09IG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0YXNjaWlFbmQgPSBzb3VyY2UuYnl0ZXNFbmQgLSByZWZTdGFydFxuXHRcdFx0XHRcdFx0XHRzb3VyY2Uuc3JjU3RyaW5nID0gc3JjLnRvU3RyaW5nKCdsYXRpbjEnLCByZWZTdGFydCwgcmVmU3RhcnQgKyBhc2NpaUVuZCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzb3VyY2Uuc3JjU3RyaW5nLnNsaWNlKHJlZiwgZW5kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChzb3VyY2UucHJldlN0cmluZ0dldCkge1xuXHRcdFx0XHRcdFx0XHRzb3VyY2UucHJldlN0cmluZ0dldC5tdWx0aUdldENvdW50ICs9IDI7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzb3VyY2UucHJldlN0cmluZ0dldCA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eS5tdWx0aUdldENvdW50LS07XG5cdFx0XHRcdFx0XHR9Ki9cblx0XHRcdFx0XHRcdHJldHVybiByZWFkU3RyaW5nKHNyYywgcmVmICsgcmVmU3RhcnQsIGVuZCAtIHJlZik7XG5cdFx0XHRcdFx0XHQvL3JldHVybiBzcmMudG9TdHJpbmcoJ2xhdGluMScsIHJlZiArIHJlZlN0YXJ0LCBlbmQgKyByZWZTdGFydCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBVVEY4OiBjYXNlIE9CSkVDVF9EQVRBOlxuXHRcdFx0XHRcdGlmIChsYXN0UmVmUHJvcGVydHkgJiYgIWxhc3RSZWZQcm9wZXJ0eS5uZXh0KVxuXHRcdFx0XHRcdFx0bGFzdFJlZlByb3BlcnR5Lm5leHQgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRsYXN0UmVmUHJvcGVydHkgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdFx0XHRcdGxldCBwb3NpdGlvbiA9IHNvdXJjZS5wb3NpdGlvbjtcblx0XHRcdFx0XHRcdGxldCByZWZTdGFydCA9IGN1cnJlbnRPZmZzZXQgKyBwb3NpdGlvbjtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBnZXRSZWYoc291cmNlLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHJlZiAhPT0gJ251bWJlcicpIHJldHVybiByZWY7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IGVuZCwgbmV4dCA9IHByb3BlcnR5Lm5leHQ7XG5cdFx0XHRcdFx0XHR3aGlsZShuZXh0KSB7XG5cdFx0XHRcdFx0XHRcdGVuZCA9IG5leHQuZ2V0UmVmKHNvdXJjZSwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicpXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRlbmQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRuZXh0ID0gbmV4dC5uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGVuZCA9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHRlbmQgPSBzb3VyY2UuYnl0ZXNFbmQgLSByZWZTdGFydDtcblx0XHRcdFx0XHRcdGlmICh0eXBlID09PSBVVEY4KSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzcmMudG9TdHJpbmcoJ3V0ZjgnLCByZWYgKyByZWZTdGFydCwgZW5kICsgcmVmU3RhcnQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFNvdXJjZSA9IHNvdXJjZTtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdW5wYWNrci51bnBhY2soc3JjLCB7IHN0YXJ0OiByZWYgKyByZWZTdGFydCwgZW5kOiBlbmQgKyByZWZTdGFydCB9KTtcblx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50U291cmNlID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgTlVNQkVSOlxuXHRcdFx0XHRcdHN3aXRjaChzaXplKSB7XG5cdFx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRcdGxldCBwb3NpdGlvbiA9IHNvdXJjZS5wb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldDtcblx0XHRcdFx0XHRcdFx0XHRsZXQgdmFsdWUgPSBkYXRhVmlldy5nZXRJbnQzMihwb3NpdGlvbiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlIDwgMHgyMDAwMDAwMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlID4gLTB4MWYwMDAwMDApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA+IC0weDIwMDAwMDAwKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdG9Db25zdGFudCh2YWx1ZSAmIDB4ZmYpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRsZXQgZlZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihwb3NpdGlvbiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBkb2VzIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdFx0XHRcdGxldCBtdWx0aXBsaWVyID0gbXVsdDEwWygoc3JjW3Bvc2l0aW9uICsgM10gJiAweDdmKSA8PCAxKSB8IChzcmNbcG9zaXRpb24gKyAyXSA+PiA3KV07XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICgobXVsdGlwbGllciAqIGZWYWx1ZSArIChmVmFsdWUgPiAwID8gMC41IDogLTAuNSkpID4+IDApIC8gbXVsdGlwbGllcjtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDg6XG5cdFx0XHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRcdGxldCB2YWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0NjQoc291cmNlLnBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgYnl0ZSA9IHNyY1tzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXRdO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGJ5dGUgPj0gMHhmNilcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRvQ29uc3RhbnQoYnl0ZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0XHRcdGxldCB2YWx1ZSA9IHNyY1tzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXRdO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZSA8IDB4ZjYgPyB2YWx1ZSA6IHRvQ29uc3RhbnQodmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgREFURTpcblx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IERhdGUoZGF0YVZpZXcuZ2V0RmxvYXQ2NChzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXQsIHRydWUpKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cdFx0XHRwcm9wZXJ0eS5nZXQgPSBnZXQ7XG5cdFx0fVxuXHRcdC8vIFRPRE86IGxvYWQgdGhlIHNyY1N0cmluZyBmb3IgZmFzdGVyIHN0cmluZyBkZWNvZGluZyBvbiB0b0pTT05cblx0XHRpZiAoZXZhbFN1cHBvcnRlZCkge1xuXHRcdFx0bGV0IG9iamVjdExpdGVyYWxQcm9wZXJ0aWVzID0gW107XG5cdFx0XHRsZXQgYXJncyA9IFtdO1xuXHRcdFx0bGV0IGkgPSAwO1xuXHRcdFx0bGV0IGhhc0luaGVyaXRlZFByb3BlcnRpZXM7XG5cdFx0XHRmb3IgKGxldCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7IC8vIGFzc2lnbiBpbiBlbnVtZXJhdGlvbiBvcmRlclxuXHRcdFx0XHRpZiAodW5wYWNrci5hbHdheXNMYXp5UHJvcGVydHkgJiYgdW5wYWNrci5hbHdheXNMYXp5UHJvcGVydHkocHJvcGVydHkua2V5KSkge1xuXHRcdFx0XHRcdC8vIHRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBlYWdlcmx5IGV2YWx1YXRlZCBhbmQgdGhpcyBjYW4gYmUgdXNlZCBmb3IgY3JlYXRpbmcgcHJvcGVydGllc1xuXHRcdFx0XHRcdC8vIHRoYXQgYXJlIG5vdCBzZXJpYWxpemVkIGFzIEpTT05cblx0XHRcdFx0XHRoYXNJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBwcm9wZXJ0eS5rZXksIHsgZ2V0OiB3aXRoU291cmNlKHByb3BlcnR5LmdldCksIGVudW1lcmFibGU6IHRydWUgfSk7XG5cdFx0XHRcdGxldCB2YWx1ZUZ1bmN0aW9uID0gJ3YnICsgaSsrO1xuXHRcdFx0XHRhcmdzLnB1c2godmFsdWVGdW5jdGlvbik7XG5cdFx0XHRcdG9iamVjdExpdGVyYWxQcm9wZXJ0aWVzLnB1c2goJ1snICsgSlNPTi5zdHJpbmdpZnkocHJvcGVydHkua2V5KSArICddOicgKyB2YWx1ZUZ1bmN0aW9uICsgJyhzKScpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc0luaGVyaXRlZFByb3BlcnRpZXMpIHtcblx0XHRcdFx0b2JqZWN0TGl0ZXJhbFByb3BlcnRpZXMucHVzaCgnX19wcm90b19fOnRoaXMnKTtcblx0XHRcdH1cblx0XHRcdGxldCB0b09iamVjdCA9IChuZXcgRnVuY3Rpb24oLi4uYXJncywgJ3JldHVybiBmdW5jdGlvbihzKXtyZXR1cm57JyArIG9iamVjdExpdGVyYWxQcm9wZXJ0aWVzLmpvaW4oJywnKSArICd9fScpKS5hcHBseShudWxsLCBwcm9wZXJ0aWVzLm1hcChwcm9wID0+IHByb3AuZ2V0KSk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAndG9KU09OJywge1xuXHRcdFx0XHR2YWx1ZShvbWl0VW5kZXJzY29yZWRQcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRvT2JqZWN0LmNhbGwodGhpcywgdGhpc1tzb3VyY2VTeW1ib2xdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICd0b0pTT04nLCB7XG5cdFx0XHRcdHZhbHVlKG9taXRVbmRlcnNjb3JlZFByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHQvLyByZXR1cm4gYW4gZW51bWVyYWJsZSBvYmplY3Qgd2l0aCBvd24gcHJvcGVydGllcyB0byBKU09OIHN0cmluZ2lmeVxuXHRcdFx0XHRcdGxldCByZXNvbHZlZCA9IHt9O1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdC8vIFRPRE86IGNoZWNrIGFsd2F5c0xhenlQcm9wZXJ0eVxuXHRcdFx0XHRcdFx0bGV0IGtleSA9IHByb3BlcnRpZXNbaV0ua2V5O1xuXG5cdFx0XHRcdFx0XHRyZXNvbHZlZFtrZXldID0gdGhpc1trZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZWQ7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIG5vdCBlbnVtZXJhYmxlIG9yIGFueXRoaW5nXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0dmFyIGluc3RhbmNlID0gbmV3IGNvbnN0cnVjdCgpO1xuXHRpbnN0YW5jZVtzb3VyY2VTeW1ib2xdID0ge1xuXHRcdGJ5dGVzOiBzcmMsXG5cdFx0cG9zaXRpb24sXG5cdFx0c3JjU3RyaW5nOiAnJyxcblx0XHRieXRlc0VuZDogc3JjRW5kXG5cdH07XG5cdHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHRvQ29uc3RhbnQoY29kZSkge1xuXHRzd2l0Y2goY29kZSkge1xuXHRcdGNhc2UgMHhmNjogcmV0dXJuIG51bGw7XG5cdFx0Y2FzZSAweGY3OiByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdGNhc2UgMHhmODogcmV0dXJuIGZhbHNlO1xuXHRcdGNhc2UgMHhmOTogcmV0dXJuIHRydWU7XG5cdH1cblx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbnN0YW50Jyk7XG59XG5mdW5jdGlvbiB3aXRoU291cmNlKGdldCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGdldCh0aGlzW3NvdXJjZVN5bWJvbF0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHNhdmVTdGF0ZSgpIHtcblx0aWYgKGN1cnJlbnRTb3VyY2UpIHtcblx0XHRjdXJyZW50U291cmNlLmJ5dGVzID0gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjdXJyZW50U291cmNlLmJ5dGVzLCBjdXJyZW50U291cmNlLnBvc2l0aW9uLCBjdXJyZW50U291cmNlLmJ5dGVzRW5kKTtcblx0XHRjdXJyZW50U291cmNlLnBvc2l0aW9uID0gMDtcblx0XHRjdXJyZW50U291cmNlLmJ5dGVzRW5kID0gY3VycmVudFNvdXJjZS5ieXRlcy5sZW5ndGg7XG5cdH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVTdHJ1Y3R1cmVzKHN0cnVjdHVyZXMsIHBhY2tyKSB7XG5cdGlmIChwYWNrci50eXBlZFN0cnVjdHMpIHtcblx0XHRsZXQgc3RydWN0TWFwID0gbmV3IE1hcCgpO1xuXHRcdHN0cnVjdE1hcC5zZXQoJ25hbWVkJywgc3RydWN0dXJlcyk7XG5cdFx0c3RydWN0TWFwLnNldCgndHlwZWQnLCBwYWNrci50eXBlZFN0cnVjdHMpO1xuXHRcdHN0cnVjdHVyZXMgPSBzdHJ1Y3RNYXA7XG5cdH1cblx0bGV0IGxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGggPSBwYWNrci5sYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoIHx8IDA7XG5cdHN0cnVjdHVyZXMuaXNDb21wYXRpYmxlID0gZXhpc3RpbmcgPT4ge1xuXHRcdGxldCBjb21wYXRpYmxlID0gdHJ1ZTtcblx0XHRpZiAoZXhpc3RpbmcgaW5zdGFuY2VvZiBNYXApIHtcblx0XHRcdGxldCBuYW1lZCA9IGV4aXN0aW5nLmdldCgnbmFtZWQnKSB8fCBbXTtcblx0XHRcdGlmIChuYW1lZC5sZW5ndGggIT09IChwYWNrci5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoIHx8IDApKVxuXHRcdFx0XHRjb21wYXRpYmxlID0gZmFsc2U7XG5cdFx0XHRsZXQgdHlwZWQgPSBleGlzdGluZy5nZXQoJ3R5cGVkJykgfHwgW107XG5cdFx0XHRpZiAodHlwZWQubGVuZ3RoICE9PSBsYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoKVxuXHRcdFx0XHRjb21wYXRpYmxlID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChleGlzdGluZyBpbnN0YW5jZW9mIEFycmF5IHx8IEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpKSB7XG5cdFx0XHRpZiAoZXhpc3RpbmcubGVuZ3RoICE9PSAocGFja3IubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCB8fCAwKSlcblx0XHRcdFx0Y29tcGF0aWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoIWNvbXBhdGlibGUpXG5cdFx0XHRwYWNrci5fbWVyZ2VTdHJ1Y3R1cmVzKGV4aXN0aW5nKTtcblx0XHRyZXR1cm4gY29tcGF0aWJsZTtcblx0fTtcblx0cGFja3IubGFzdFR5cGVkU3RydWN0dXJlc0xlbmd0aCA9IHBhY2tyLnR5cGVkU3RydWN0cyAmJiBwYWNrci50eXBlZFN0cnVjdHMubGVuZ3RoO1xuXHRyZXR1cm4gc3RydWN0dXJlcztcbn1cblxuc2V0UmVhZFN0cnVjdChyZWFkU3RydWN0LCBvbkxvYWRlZFN0cnVjdHVyZXMsIHNhdmVTdGF0ZSk7XG5cbmNsYXNzIFBhY2tyU3RyZWFtIGV4dGVuZHMgc3RyZWFtLlRyYW5zZm9ybSB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMpXG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0b3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUgPSB0cnVlO1xuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHRcdG9wdGlvbnMuc2VxdWVudGlhbCA9IHRydWU7XG5cdFx0dGhpcy5wYWNrciA9IG9wdGlvbnMucGFja3IgfHwgbmV3IFBhY2tyKG9wdGlvbnMpO1xuXHR9XG5cdF90cmFuc2Zvcm0odmFsdWUsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuXHRcdHRoaXMucHVzaCh0aGlzLnBhY2tyLnBhY2sodmFsdWUpKTtcblx0XHRjYWxsYmFjaygpO1xuXHR9XG59XG5cbmNsYXNzIFVucGFja3JTdHJlYW0gZXh0ZW5kcyBzdHJlYW0uVHJhbnNmb3JtIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRvcHRpb25zLm9iamVjdE1vZGUgPSB0cnVlO1xuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHRcdG9wdGlvbnMuc3RydWN0dXJlcyA9IFtdO1xuXHRcdHRoaXMudW5wYWNrciA9IG9wdGlvbnMudW5wYWNrciB8fCBuZXcgVW5wYWNrcihvcHRpb25zKTtcblx0fVxuXHRfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcblx0XHRpZiAodGhpcy5pbmNvbXBsZXRlQnVmZmVyKSB7XG5cdFx0XHRjaHVuayA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuaW5jb21wbGV0ZUJ1ZmZlciwgY2h1bmtdKTtcblx0XHRcdHRoaXMuaW5jb21wbGV0ZUJ1ZmZlciA9IG51bGw7XG5cdFx0fVxuXHRcdGxldCB2YWx1ZXM7XG5cdFx0dHJ5IHtcblx0XHRcdHZhbHVlcyA9IHRoaXMudW5wYWNrci51bnBhY2tNdWx0aXBsZShjaHVuayk7XG5cdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0aWYgKGVycm9yLmluY29tcGxldGUpIHtcblx0XHRcdFx0dGhpcy5pbmNvbXBsZXRlQnVmZmVyID0gY2h1bmsuc2xpY2UoZXJyb3IubGFzdFBvc2l0aW9uKTtcblx0XHRcdFx0dmFsdWVzID0gZXJyb3IudmFsdWVzO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMgfHwgW10pIHtcblx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsKVxuXHRcdFx0XHRcdHZhbHVlID0gdGhpcy5nZXROdWxsVmFsdWUoKTtcblx0XHRcdFx0dGhpcy5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuXHR9XG5cdGdldE51bGxWYWx1ZSgpIHtcblx0XHRyZXR1cm4gU3ltYm9sLmZvcihudWxsKVxuXHR9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gSXRlcmFibGUgZmlyc3QgYXJndW1lbnQsIHJldHVybnMgYW4gSXRlcmFibGUgd2hlcmUgZWFjaCB2YWx1ZSBpcyBwYWNrZWQgYXMgYSBCdWZmZXJcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBvbmx5IEFzeW5jIEl0ZXJhYmxlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgYW4gQXN5bmMgSXRlcmFibGUuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfEl0ZXJhdG9yfEFzeW5jSXRlcmFibGV8QXN5bmNJdGVyYXRvcn0gb2JqZWN0SXRlcmF0b3IgLSBpdGVyYWJsZSBzb3VyY2UsIGxpa2UgYSBSZWFkYWJsZSBvYmplY3Qgc3RyZWFtLCBhbiBhcnJheSwgU2V0LCBvciBjdXN0b20gb2JqZWN0XG4gKiBAcGFyYW0ge29wdGlvbnN9IFtvcHRpb25zXSAtIG1zZ3BhY2tyIHBhY2sgb3B0aW9uc1xuICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3J8UHJvbWlzZS48QXN5bmNJdGVyYWJsZUl0ZXJhdG9yPn1cbiAqL1xuZnVuY3Rpb24gcGFja0l0ZXIgKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFvYmplY3RJdGVyYXRvciB8fCB0eXBlb2Ygb2JqZWN0SXRlcmF0b3IgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEl0ZXJhYmxlLCBBc3luYyBJdGVyYWJsZSwgb3IgYSBQcm9taXNlIGZvciBhbiBBc3luYyBJdGVyYWJsZScpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdEl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGFja0l0ZXJTeW5jKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3RJdGVyYXRvci50aGVuID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmplY3RJdGVyYXRvcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGFja0l0ZXJBc3luYyhvYmplY3RJdGVyYXRvciwgb3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gSXRlcmFibGUsIEFzeW5jIEl0ZXJhYmxlLCBJdGVyYXRvciwgQXN5bmMgSXRlcmF0b3IsIG9yIGEgUHJvbWlzZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gKiBwYWNrSXRlclN5bmMgKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhY2tyID0gbmV3IFBhY2tyKG9wdGlvbnMpO1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iamVjdEl0ZXJhdG9yKSB7XG4gICAgeWllbGQgcGFja3IucGFjayh2YWx1ZSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gKiBwYWNrSXRlckFzeW5jIChvYmplY3RJdGVyYXRvciwgb3B0aW9ucykge1xuICBjb25zdCBwYWNrciA9IG5ldyBQYWNrcihvcHRpb25zKTtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBvYmplY3RJdGVyYXRvcikge1xuICAgIHlpZWxkIHBhY2tyLnBhY2sodmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gSXRlcmFibGUvSXRlcmF0b3IgaW5wdXQgd2hpY2ggeWllbGRzIGJ1ZmZlcnMsIHJldHVybnMgYW4gSXRlcmFibGVJdGVyYXRvciB3aGljaCB5aWVsZHMgc3luYyBkZWNvZGVkIG9iamVjdHNcbiAqIE9yLCBnaXZlbiBhbiBBc3luYyBJdGVyYWJsZS9JdGVyYXRvciB3aGljaCB5aWVsZHMgcHJvbWlzZXMgcmVzb2x2aW5nIGluIGJ1ZmZlcnMsIHJldHVybnMgYW4gQXN5bmNJdGVyYWJsZUl0ZXJhdG9yLlxuICogQHBhcmFtIHtJdGVyYWJsZXxJdGVyYXRvcnxBc3luY0l0ZXJhYmxlfEFzeW5jSXRlcmFibGVJdGVyYXRvcn0gYnVmZmVySXRlcmF0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSB1bnBhY2tyIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yfFByb21pc2UuPEFzeW5jSXRlcmFibGVJdGVyYXRvcn1cbiAqL1xuZnVuY3Rpb24gdW5wYWNrSXRlciAoYnVmZmVySXRlcmF0b3IsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIWJ1ZmZlckl0ZXJhdG9yIHx8IHR5cGVvZiBidWZmZXJJdGVyYXRvciAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gSXRlcmFibGUsIEFzeW5jIEl0ZXJhYmxlLCBJdGVyYXRvciwgQXN5bmMgSXRlcmF0b3IsIG9yIGEgcHJvbWlzZScpXG4gIH1cblxuICBjb25zdCB1bnBhY2tyID0gbmV3IFVucGFja3Iob3B0aW9ucyk7XG4gIGxldCBpbmNvbXBsZXRlO1xuICBjb25zdCBwYXJzZXIgPSAoY2h1bmspID0+IHtcbiAgICBsZXQgeWllbGRzO1xuICAgIC8vIGlmIHRoZXJlJ3MgaW5jb21wbGV0ZSBkYXRhIGZyb20gcHJldmlvdXMgY2h1bmssIGNvbmNhdGluYXRlIGFuZCB0cnkgYWdhaW5cbiAgICBpZiAoaW5jb21wbGV0ZSkge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuY29uY2F0KFtpbmNvbXBsZXRlLCBjaHVua10pO1xuICAgICAgaW5jb21wbGV0ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgeWllbGRzID0gdW5wYWNrci51bnBhY2tNdWx0aXBsZShjaHVuayk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmluY29tcGxldGUpIHtcbiAgICAgICAgaW5jb21wbGV0ZSA9IGNodW5rLnNsaWNlKGVyci5sYXN0UG9zaXRpb24pO1xuICAgICAgICB5aWVsZHMgPSBlcnIudmFsdWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB5aWVsZHNcbiAgfTtcblxuICBpZiAodHlwZW9mIGJ1ZmZlckl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uICogaXRlciAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGJ1ZmZlckl0ZXJhdG9yKSB7XG4gICAgICAgIHlpZWxkICogcGFyc2VyKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KSgpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGJ1ZmZlckl0ZXJhdG9yW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAoYXN5bmMgZnVuY3Rpb24gKiBpdGVyICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYnVmZmVySXRlcmF0b3IpIHtcbiAgICAgICAgeWllbGQgKiBwYXJzZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0pKClcbiAgfVxufVxuY29uc3QgZGVjb2RlSXRlciA9IHVucGFja0l0ZXI7XG5jb25zdCBlbmNvZGVJdGVyID0gcGFja0l0ZXI7XG5cbmNvbnN0IHVzZVJlY29yZHMgPSBmYWxzZTtcbmNvbnN0IG1hcHNBc09iamVjdHMgPSB0cnVlO1xuXG5jb25zdCBuYXRpdmVBY2NlbGVyYXRpb25EaXNhYmxlZCA9IHByb2Nlc3MuZW52Lk1TR1BBQ0tSX05BVElWRV9BQ0NFTEVSQVRJT05fRElTQUJMRUQgIT09IHVuZGVmaW5lZCAmJiBwcm9jZXNzLmVudi5NU0dQQUNLUl9OQVRJVkVfQUNDRUxFUkFUSU9OX0RJU0FCTEVELnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcblxuaWYgKCFuYXRpdmVBY2NlbGVyYXRpb25EaXNhYmxlZCkge1xuXHRsZXQgZXh0cmFjdG9yO1xuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgcmVxdWlyZSA9PSAnZnVuY3Rpb24nKVxuXHRcdFx0ZXh0cmFjdG9yID0gcmVxdWlyZSgnbXNncGFja3ItZXh0cmFjdCcpO1xuXHRcdGVsc2Vcblx0XHRcdGV4dHJhY3RvciA9IG1vZHVsZSQxLmNyZWF0ZVJlcXVpcmUoKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyBuZXcgKHJlcXVpcmUoJ3UnICsgJ3JsJykuVVJMKSgnZmlsZTonICsgX19maWxlbmFtZSkuaHJlZiA6IChkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjIHx8IG5ldyBVUkwoJ25vZGUuY2pzJywgZG9jdW1lbnQuYmFzZVVSSSkuaHJlZikpKSgnbXNncGFja3ItZXh0cmFjdCcpO1xuXHRcdGlmIChleHRyYWN0b3IpXG5cdFx0XHRzZXRFeHRyYWN0b3IoZXh0cmFjdG9yLmV4dHJhY3RTdHJpbmdzKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBuYXRpdmUgbW9kdWxlIGlzIG9wdGlvbmFsXG5cdH1cbn1cblxuZXhwb3J0cy5BTFdBWVMgPSBBTFdBWVM7XG5leHBvcnRzLkMxID0gQzE7XG5leHBvcnRzLkRFQ0lNQUxfRklUID0gREVDSU1BTF9GSVQ7XG5leHBvcnRzLkRFQ0lNQUxfUk9VTkQgPSBERUNJTUFMX1JPVU5EO1xuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcbmV4cG9ydHMuRGVjb2RlclN0cmVhbSA9IFVucGFja3JTdHJlYW07XG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuZXhwb3J0cy5FbmNvZGVyU3RyZWFtID0gUGFja3JTdHJlYW07XG5leHBvcnRzLkZMT0FUMzJfT1BUSU9OUyA9IEZMT0FUMzJfT1BUSU9OUztcbmV4cG9ydHMuTkVWRVIgPSBORVZFUjtcbmV4cG9ydHMuUGFja3IgPSBQYWNrcjtcbmV4cG9ydHMuUGFja3JTdHJlYW0gPSBQYWNrclN0cmVhbTtcbmV4cG9ydHMuVW5wYWNrciA9IFVucGFja3I7XG5leHBvcnRzLlVucGFja3JTdHJlYW0gPSBVbnBhY2tyU3RyZWFtO1xuZXhwb3J0cy5hZGRFeHRlbnNpb24gPSBhZGRFeHRlbnNpb247XG5leHBvcnRzLmNsZWFyU291cmNlID0gY2xlYXJTb3VyY2U7XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmV4cG9ydHMuZGVjb2RlSXRlciA9IGRlY29kZUl0ZXI7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZW5jb2RlSXRlciA9IGVuY29kZUl0ZXI7XG5leHBvcnRzLm1hcHNBc09iamVjdHMgPSBtYXBzQXNPYmplY3RzO1xuZXhwb3J0cy5wYWNrID0gcGFjaztcbmV4cG9ydHMucm91bmRGbG9hdDMyID0gcm91bmRGbG9hdDMyO1xuZXhwb3J0cy51bnBhY2sgPSB1bnBhY2s7XG5leHBvcnRzLnVucGFja011bHRpcGxlID0gdW5wYWNrTXVsdGlwbGU7XG5leHBvcnRzLnVzZVJlY29yZHMgPSB1c2VSZWNvcmRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS5janMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/msgpackr/dist/node.cjs\n");

/***/ })

};
;