"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bull";
exports.ids = ["vendor-chunks/bull"];
exports.modules = {

/***/ "(action-browser)/../../node_modules/bull/index.js":
/*!****************************************!*\
  !*** ../../node_modules/bull/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nmodule.exports = __webpack_require__(/*! ./lib/queue */ \"(action-browser)/../../node_modules/bull/lib/queue.js\");\nmodule.exports.Job = __webpack_require__(/*! ./lib/job */ \"(action-browser)/../../node_modules/bull/lib/job.js\");\nmodule.exports.utils = __webpack_require__(/*! ./lib/utils */ \"(action-browser)/../../node_modules/bull/lib/utils.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnSEFBdUM7QUFDdkMsZ0hBQXlDO0FBQ3pDLHNIQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9pbmRleC5qcz8wYjljIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9xdWV1ZScpO1xubW9kdWxlLmV4cG9ydHMuSm9iID0gcmVxdWlyZSgnLi9saWIvam9iJyk7XG5tb2R1bGUuZXhwb3J0cy51dGlscyA9IHJlcXVpcmUoJy4vbGliL3V0aWxzJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/index.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/backoffs.js":
/*!***********************************************!*\
  !*** ../../node_modules/bull/lib/backoffs.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../../node_modules/lodash/lodash.js\");\n\nconst builtinStrategies = {\n  fixed(delay) {\n    return function() {\n      return delay;\n    };\n  },\n\n  exponential(delay) {\n    return function(attemptsMade) {\n      return Math.round((Math.pow(2, attemptsMade) - 1) * delay);\n    };\n  }\n};\n\nfunction lookupStrategy(backoff, customStrategies) {\n  if (backoff.type in customStrategies) {\n    return customStrategies[backoff.type];\n  } else if (backoff.type in builtinStrategies) {\n    return builtinStrategies[backoff.type](backoff.delay);\n  } else {\n    throw new Error(\n      'Unknown backoff strategy ' +\n        backoff.type +\n        '. If a custom backoff strategy is used, specify it when the queue is created.'\n    );\n  }\n}\n\nmodule.exports = {\n  normalize(backoff) {\n    if (_.isFinite(backoff)) {\n      return {\n        type: 'fixed',\n        delay: backoff\n      };\n    } else if (backoff) {\n      return backoff;\n    }\n  },\n\n  calculate(backoff, attemptsMade, customStrategies, err, strategyOptions) {\n    if (backoff) {\n      const strategy = lookupStrategy(\n        backoff,\n        customStrategies,\n        strategyOptions\n      );\n\n      return strategy(attemptsMade, err, strategyOptions);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvYmFja29mZnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLG9FQUFROztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9iYWNrb2Zmcy5qcz9kZGQ3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5jb25zdCBidWlsdGluU3RyYXRlZ2llcyA9IHtcbiAgZml4ZWQoZGVsYXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVsYXk7XG4gICAgfTtcbiAgfSxcblxuICBleHBvbmVudGlhbChkZWxheSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhdHRlbXB0c01hZGUpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKChNYXRoLnBvdygyLCBhdHRlbXB0c01hZGUpIC0gMSkgKiBkZWxheSk7XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gbG9va3VwU3RyYXRlZ3koYmFja29mZiwgY3VzdG9tU3RyYXRlZ2llcykge1xuICBpZiAoYmFja29mZi50eXBlIGluIGN1c3RvbVN0cmF0ZWdpZXMpIHtcbiAgICByZXR1cm4gY3VzdG9tU3RyYXRlZ2llc1tiYWNrb2ZmLnR5cGVdO1xuICB9IGVsc2UgaWYgKGJhY2tvZmYudHlwZSBpbiBidWlsdGluU3RyYXRlZ2llcykge1xuICAgIHJldHVybiBidWlsdGluU3RyYXRlZ2llc1tiYWNrb2ZmLnR5cGVdKGJhY2tvZmYuZGVsYXkpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdVbmtub3duIGJhY2tvZmYgc3RyYXRlZ3kgJyArXG4gICAgICAgIGJhY2tvZmYudHlwZSArXG4gICAgICAgICcuIElmIGEgY3VzdG9tIGJhY2tvZmYgc3RyYXRlZ3kgaXMgdXNlZCwgc3BlY2lmeSBpdCB3aGVuIHRoZSBxdWV1ZSBpcyBjcmVhdGVkLidcbiAgICApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBub3JtYWxpemUoYmFja29mZikge1xuICAgIGlmIChfLmlzRmluaXRlKGJhY2tvZmYpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZml4ZWQnLFxuICAgICAgICBkZWxheTogYmFja29mZlxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGJhY2tvZmYpIHtcbiAgICAgIHJldHVybiBiYWNrb2ZmO1xuICAgIH1cbiAgfSxcblxuICBjYWxjdWxhdGUoYmFja29mZiwgYXR0ZW1wdHNNYWRlLCBjdXN0b21TdHJhdGVnaWVzLCBlcnIsIHN0cmF0ZWd5T3B0aW9ucykge1xuICAgIGlmIChiYWNrb2ZmKSB7XG4gICAgICBjb25zdCBzdHJhdGVneSA9IGxvb2t1cFN0cmF0ZWd5KFxuICAgICAgICBiYWNrb2ZmLFxuICAgICAgICBjdXN0b21TdHJhdGVnaWVzLFxuICAgICAgICBzdHJhdGVneU9wdGlvbnNcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBzdHJhdGVneShhdHRlbXB0c01hZGUsIGVyciwgc3RyYXRlZ3lPcHRpb25zKTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/backoffs.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/errors.js":
/*!*********************************************!*\
  !*** ../../node_modules/bull/lib/errors.js ***!
  \*********************************************/
/***/ ((module) => {

eval("\n\nmodule.exports.Messages = {\n  RETRY_JOB_NOT_EXIST: \"Couldn't retry job: The job doesn't exist\",\n  RETRY_JOB_IS_LOCKED: \"Couldn't retry job: The job is locked\",\n  RETRY_JOB_NOT_FAILED:\n    \"Couldn't retry job: The job has been already retried or has not failed\",\n  MISSING_REDIS_OPTS: `Using a redis instance with enableReadyCheck or maxRetriesPerRequest for bclient/subscriber is not permitted.\n  see https://github.com/OptimalBits/bull/issues/1873\n  `\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9lcnJvcnMuanM/NjY1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VzID0ge1xuICBSRVRSWV9KT0JfTk9UX0VYSVNUOiBcIkNvdWxkbid0IHJldHJ5IGpvYjogVGhlIGpvYiBkb2Vzbid0IGV4aXN0XCIsXG4gIFJFVFJZX0pPQl9JU19MT0NLRUQ6IFwiQ291bGRuJ3QgcmV0cnkgam9iOiBUaGUgam9iIGlzIGxvY2tlZFwiLFxuICBSRVRSWV9KT0JfTk9UX0ZBSUxFRDpcbiAgICBcIkNvdWxkbid0IHJldHJ5IGpvYjogVGhlIGpvYiBoYXMgYmVlbiBhbHJlYWR5IHJldHJpZWQgb3IgaGFzIG5vdCBmYWlsZWRcIixcbiAgTUlTU0lOR19SRURJU19PUFRTOiBgVXNpbmcgYSByZWRpcyBpbnN0YW5jZSB3aXRoIGVuYWJsZVJlYWR5Q2hlY2sgb3IgbWF4UmV0cmllc1BlclJlcXVlc3QgZm9yIGJjbGllbnQvc3Vic2NyaWJlciBpcyBub3QgcGVybWl0dGVkLlxuICBzZWUgaHR0cHM6Ly9naXRodWIuY29tL09wdGltYWxCaXRzL2J1bGwvaXNzdWVzLzE4NzNcbiAgYFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/errors.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/getters.js":
/*!**********************************************!*\
  !*** ../../node_modules/bull/lib/getters.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../../node_modules/lodash/lodash.js\");\nconst Job = __webpack_require__(/*! ./job */ \"(action-browser)/../../node_modules/bull/lib/job.js\");\nconst scripts = __webpack_require__(/*! ./scripts */ \"(action-browser)/../../node_modules/bull/lib/scripts.js\");\n\nmodule.exports = function(Queue) {\n  Queue.prototype.getJob = async function(jobId) {\n    await this.isReady();\n    return Job.fromId(this, jobId);\n  };\n\n  Queue.prototype.getCountsPerPriority = async function(priorities) {\n    const uniquePriorities = [...new Set(priorities)];\n    const responses = await scripts.getCountsPerPriority(\n      this,\n      uniquePriorities\n    );\n\n    const counts = {};\n    responses.forEach((res, index) => {\n      counts[`${uniquePriorities[index]}`] = res || 0;\n    });\n\n    return counts;\n  };\n\n  Queue.prototype._commandByType = function(types, count, callback) {\n    return _.map(types, type => {\n      type = type === 'waiting' ? 'wait' : type; // alias\n\n      const key = this.toKey(type);\n\n      switch (type) {\n        case 'completed':\n        case 'failed':\n        case 'delayed':\n        case 'repeat':\n          return callback(key, count ? 'zcard' : 'zrange');\n        case 'active':\n        case 'wait':\n        case 'paused':\n          return callback(key, count ? 'llen' : 'lrange');\n      }\n    });\n  };\n\n  /**\n    Returns the number of jobs waiting to be processed.\n  */\n  Queue.prototype.count = function() {\n    return this.getJobCountByTypes('wait', 'paused', 'delayed');\n  };\n\n  // Job counts by type\n  // Queue#getJobCountByTypes('completed') => completed count\n  // Queue#getJobCountByTypes('completed,failed') => completed + failed count\n  // Queue#getJobCountByTypes('completed', 'failed') => completed + failed count\n  // Queue#getJobCountByTypes('completed,waiting', 'failed') => completed + waiting + failed count\n  Queue.prototype.getJobCountByTypes = function() {\n    return this.getJobCounts.apply(this, arguments).then(result => {\n      return _.chain(result)\n        .values()\n        .sum()\n        .value();\n    });\n  };\n\n  /**\n   * Returns the job counts for each type specified or every list/set in the queue by default.\n   *\n   */\n  Queue.prototype.getJobCounts = function() {\n    const types = parseTypeArg(arguments);\n    const multi = this.multi();\n\n    this._commandByType(types, true, (key, command) => {\n      multi[command](key);\n    });\n\n    return multi.exec().then(res => {\n      const counts = {};\n      res.forEach((res, index) => {\n        counts[types[index]] = res[1] || 0;\n      });\n      return counts;\n    });\n  };\n\n  Queue.prototype.getCompletedCount = function() {\n    return this.getJobCountByTypes('completed');\n  };\n\n  Queue.prototype.getFailedCount = function() {\n    return this.getJobCountByTypes('failed');\n  };\n\n  Queue.prototype.getDelayedCount = function() {\n    return this.getJobCountByTypes('delayed');\n  };\n\n  Queue.prototype.getActiveCount = function() {\n    return this.getJobCountByTypes('active');\n  };\n\n  Queue.prototype.getWaitingCount = function() {\n    return this.getJobCountByTypes('wait', 'paused');\n  };\n\n  /**\n   *\n   * @returns the potential stalled jobs. Only useful for tests.\n   */\n  Queue.prototype.getStalledCount = function() {\n    const key = this.toKey('stalled');\n    return this.client.scard(key);\n  };\n\n  // TO BE DEPRECATED --->\n  Queue.prototype.getPausedCount = function() {\n    return this.getJobCountByTypes('paused');\n  };\n  // <-----\n\n  Queue.prototype.getWaiting = function(start, end, opts) {\n    return this.getJobs(['wait', 'paused'], start, end, true, opts);\n  };\n\n  Queue.prototype.getActive = function(start, end, opts) {\n    return this.getJobs('active', start, end, true, opts);\n  };\n\n  Queue.prototype.getDelayed = function(start, end, opts) {\n    return this.getJobs('delayed', start, end, true, opts);\n  };\n\n  Queue.prototype.getCompleted = function(start, end, opts) {\n    return this.getJobs('completed', start, end, false, opts);\n  };\n\n  Queue.prototype.getFailed = function(start, end, opts) {\n    return this.getJobs('failed', start, end, false, opts);\n  };\n\n  Queue.prototype.getRanges = function(types, start, end, asc) {\n    start = _.isUndefined(start) ? 0 : start;\n    end = _.isUndefined(end) ? -1 : end;\n\n    const multi = this.multi();\n    const multiCommands = [];\n\n    this._commandByType(parseTypeArg(types), false, (key, command) => {\n      switch (command) {\n        case 'lrange':\n          if (asc) {\n            multiCommands.push('lrange');\n            multi.lrange(key, -(end + 1), -(start + 1));\n          } else {\n            multi.lrange(key, start, end);\n          }\n          break;\n        case 'zrange':\n          multiCommands.push('zrange');\n          if (asc) {\n            multi.zrange(key, start, end);\n          } else {\n            multi.zrevrange(key, start, end);\n          }\n          break;\n      }\n    });\n\n    return multi.exec().then(responses => {\n      let results = [];\n\n      responses.forEach((response, index) => {\n        const result = response[1] || [];\n\n        if (asc && multiCommands[index] === 'lrange') {\n          results = results.concat(result.reverse());\n        } else {\n          results = results.concat(result);\n        }\n      });\n      return results;\n    });\n  };\n\n  Queue.prototype.getJobs = function(types, start, end, asc, opts) {\n    return this.getRanges(types, start, end, asc).then(jobIds => {\n      return Promise.all(jobIds.map(jobId => this.getJobFromId(jobId, opts)));\n    });\n  };\n\n  Queue.prototype.getJobLogs = function(jobId, start, end, asc = true) {\n    start = _.isUndefined(start) ? 0 : start;\n    end = _.isUndefined(end) ? -1 : end;\n\n    const multi = this.multi();\n\n    const logsKey = this.toKey(jobId + ':logs');\n    if (asc) {\n      multi.lrange(logsKey, start, end);\n    } else {\n      multi.lrange(logsKey, -(end + 1), -(start + 1));\n    }\n    multi.llen(logsKey);\n    return multi.exec().then(result => {\n      if (!asc) {\n        result[0][1].reverse();\n      }\n      return {\n        logs: result[0][1],\n        count: result[1][1]\n      };\n    });\n  };\n\n  /**\n   * Get queue metrics related to the queue.\n   *\n   * This method returns the gathered metrics for the queue.\n   * The metrics are represented as an array of job counts\n   * per unit of time (1 minute).\n   *\n   * @param start - Start point of the metrics, where 0\n   * is the newest point to be returned.\n   * @param end - End poinf of the metrics, where -1 is the\n   * oldest point to be returned.\n   *\n   * @returns - Returns an object with queue metrics.\n   */\n  Queue.prototype.getMetrics = async function(type, start = 0, end = -1) {\n    const metricsKey = this.toKey(`metrics:${type}`);\n    const dataKey = `${metricsKey}:data`;\n\n    const multi = this.multi();\n    multi.hmget(metricsKey, 'count', 'prevTS', 'prevCount');\n    multi.lrange(dataKey, start, end);\n    multi.llen(dataKey);\n\n    const [hmget, range, len] = await multi.exec();\n    const [err, [count, prevTS, prevCount]] = hmget;\n    const [err2, data] = range;\n    const [err3, numPoints] = len;\n    if (err || err2) {\n      throw err || err2 || err3;\n    }\n\n    return {\n      meta: {\n        count: parseInt(count || '0', 10),\n        prevTS: parseInt(prevTS || '0', 10),\n        prevCount: parseInt(prevCount || '0', 10)\n      },\n      data,\n      count: numPoints\n    };\n  };\n};\n\nfunction parseTypeArg(args) {\n  const types = _.chain([])\n    .concat(args)\n    .join(',')\n    .split(/\\s*,\\s*/g)\n    .compact()\n    .value();\n\n  return types.length\n    ? types\n    : ['waiting', 'active', 'completed', 'failed', 'delayed', 'paused'];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvZ2V0dGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLG1CQUFPLENBQUMsb0VBQVE7QUFDMUIsWUFBWSxtQkFBTyxDQUFDLGtFQUFPO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QyxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xELHVCQUF1QixXQUFXOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL2dldHRlcnMuanM/YmUzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IEpvYiA9IHJlcXVpcmUoJy4vam9iJyk7XG5jb25zdCBzY3JpcHRzID0gcmVxdWlyZSgnLi9zY3JpcHRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUXVldWUpIHtcbiAgUXVldWUucHJvdG90eXBlLmdldEpvYiA9IGFzeW5jIGZ1bmN0aW9uKGpvYklkKSB7XG4gICAgYXdhaXQgdGhpcy5pc1JlYWR5KCk7XG4gICAgcmV0dXJuIEpvYi5mcm9tSWQodGhpcywgam9iSWQpO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRDb3VudHNQZXJQcmlvcml0eSA9IGFzeW5jIGZ1bmN0aW9uKHByaW9yaXRpZXMpIHtcbiAgICBjb25zdCB1bmlxdWVQcmlvcml0aWVzID0gWy4uLm5ldyBTZXQocHJpb3JpdGllcyldO1xuICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IHNjcmlwdHMuZ2V0Q291bnRzUGVyUHJpb3JpdHkoXG4gICAgICB0aGlzLFxuICAgICAgdW5pcXVlUHJpb3JpdGllc1xuICAgICk7XG5cbiAgICBjb25zdCBjb3VudHMgPSB7fTtcbiAgICByZXNwb25zZXMuZm9yRWFjaCgocmVzLCBpbmRleCkgPT4ge1xuICAgICAgY291bnRzW2Ake3VuaXF1ZVByaW9yaXRpZXNbaW5kZXhdfWBdID0gcmVzIHx8IDA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY291bnRzO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5fY29tbWFuZEJ5VHlwZSA9IGZ1bmN0aW9uKHR5cGVzLCBjb3VudCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gXy5tYXAodHlwZXMsIHR5cGUgPT4ge1xuICAgICAgdHlwZSA9IHR5cGUgPT09ICd3YWl0aW5nJyA/ICd3YWl0JyA6IHR5cGU7IC8vIGFsaWFzXG5cbiAgICAgIGNvbnN0IGtleSA9IHRoaXMudG9LZXkodHlwZSk7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICBjYXNlICdkZWxheWVkJzpcbiAgICAgICAgY2FzZSAncmVwZWF0JzpcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soa2V5LCBjb3VudCA/ICd6Y2FyZCcgOiAnenJhbmdlJyk7XG4gICAgICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICAgIGNhc2UgJ3dhaXQnOlxuICAgICAgICBjYXNlICdwYXVzZWQnOlxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhrZXksIGNvdW50ID8gJ2xsZW4nIDogJ2xyYW5nZScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgIFJldHVybnMgdGhlIG51bWJlciBvZiBqb2JzIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkLlxuICAqL1xuICBRdWV1ZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ3dhaXQnLCAncGF1c2VkJywgJ2RlbGF5ZWQnKTtcbiAgfTtcblxuICAvLyBKb2IgY291bnRzIGJ5IHR5cGVcbiAgLy8gUXVldWUjZ2V0Sm9iQ291bnRCeVR5cGVzKCdjb21wbGV0ZWQnKSA9PiBjb21wbGV0ZWQgY291bnRcbiAgLy8gUXVldWUjZ2V0Sm9iQ291bnRCeVR5cGVzKCdjb21wbGV0ZWQsZmFpbGVkJykgPT4gY29tcGxldGVkICsgZmFpbGVkIGNvdW50XG4gIC8vIFF1ZXVlI2dldEpvYkNvdW50QnlUeXBlcygnY29tcGxldGVkJywgJ2ZhaWxlZCcpID0+IGNvbXBsZXRlZCArIGZhaWxlZCBjb3VudFxuICAvLyBRdWV1ZSNnZXRKb2JDb3VudEJ5VHlwZXMoJ2NvbXBsZXRlZCx3YWl0aW5nJywgJ2ZhaWxlZCcpID0+IGNvbXBsZXRlZCArIHdhaXRpbmcgKyBmYWlsZWQgY291bnRcbiAgUXVldWUucHJvdG90eXBlLmdldEpvYkNvdW50QnlUeXBlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldEpvYkNvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIHJldHVybiBfLmNoYWluKHJlc3VsdClcbiAgICAgICAgLnZhbHVlcygpXG4gICAgICAgIC5zdW0oKVxuICAgICAgICAudmFsdWUoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgam9iIGNvdW50cyBmb3IgZWFjaCB0eXBlIHNwZWNpZmllZCBvciBldmVyeSBsaXN0L3NldCBpbiB0aGUgcXVldWUgYnkgZGVmYXVsdC5cbiAgICpcbiAgICovXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRKb2JDb3VudHMgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0eXBlcyA9IHBhcnNlVHlwZUFyZyhhcmd1bWVudHMpO1xuICAgIGNvbnN0IG11bHRpID0gdGhpcy5tdWx0aSgpO1xuXG4gICAgdGhpcy5fY29tbWFuZEJ5VHlwZSh0eXBlcywgdHJ1ZSwgKGtleSwgY29tbWFuZCkgPT4ge1xuICAgICAgbXVsdGlbY29tbWFuZF0oa2V5KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBtdWx0aS5leGVjKCkudGhlbihyZXMgPT4ge1xuICAgICAgY29uc3QgY291bnRzID0ge307XG4gICAgICByZXMuZm9yRWFjaCgocmVzLCBpbmRleCkgPT4ge1xuICAgICAgICBjb3VudHNbdHlwZXNbaW5kZXhdXSA9IHJlc1sxXSB8fCAwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY291bnRzO1xuICAgIH0pO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRDb21wbGV0ZWRDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldEpvYkNvdW50QnlUeXBlcygnY29tcGxldGVkJyk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLmdldEZhaWxlZENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Sm9iQ291bnRCeVR5cGVzKCdmYWlsZWQnKTtcbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUuZ2V0RGVsYXllZENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Sm9iQ291bnRCeVR5cGVzKCdkZWxheWVkJyk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLmdldEFjdGl2ZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Sm9iQ291bnRCeVR5cGVzKCdhY3RpdmUnKTtcbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUuZ2V0V2FpdGluZ0NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Sm9iQ291bnRCeVR5cGVzKCd3YWl0JywgJ3BhdXNlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgcG90ZW50aWFsIHN0YWxsZWQgam9icy4gT25seSB1c2VmdWwgZm9yIHRlc3RzLlxuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLmdldFN0YWxsZWRDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMudG9LZXkoJ3N0YWxsZWQnKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuc2NhcmQoa2V5KTtcbiAgfTtcblxuICAvLyBUTyBCRSBERVBSRUNBVEVEIC0tLT5cbiAgUXVldWUucHJvdG90eXBlLmdldFBhdXNlZENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Sm9iQ291bnRCeVR5cGVzKCdwYXVzZWQnKTtcbiAgfTtcbiAgLy8gPC0tLS0tXG5cbiAgUXVldWUucHJvdG90eXBlLmdldFdhaXRpbmcgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Sm9icyhbJ3dhaXQnLCAncGF1c2VkJ10sIHN0YXJ0LCBlbmQsIHRydWUsIG9wdHMpO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRBY3RpdmUgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Sm9icygnYWN0aXZlJywgc3RhcnQsIGVuZCwgdHJ1ZSwgb3B0cyk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLmdldERlbGF5ZWQgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Sm9icygnZGVsYXllZCcsIHN0YXJ0LCBlbmQsIHRydWUsIG9wdHMpO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRDb21wbGV0ZWQgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Sm9icygnY29tcGxldGVkJywgc3RhcnQsIGVuZCwgZmFsc2UsIG9wdHMpO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRGYWlsZWQgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Sm9icygnZmFpbGVkJywgc3RhcnQsIGVuZCwgZmFsc2UsIG9wdHMpO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRSYW5nZXMgPSBmdW5jdGlvbih0eXBlcywgc3RhcnQsIGVuZCwgYXNjKSB7XG4gICAgc3RhcnQgPSBfLmlzVW5kZWZpbmVkKHN0YXJ0KSA/IDAgOiBzdGFydDtcbiAgICBlbmQgPSBfLmlzVW5kZWZpbmVkKGVuZCkgPyAtMSA6IGVuZDtcblxuICAgIGNvbnN0IG11bHRpID0gdGhpcy5tdWx0aSgpO1xuICAgIGNvbnN0IG11bHRpQ29tbWFuZHMgPSBbXTtcblxuICAgIHRoaXMuX2NvbW1hbmRCeVR5cGUocGFyc2VUeXBlQXJnKHR5cGVzKSwgZmFsc2UsIChrZXksIGNvbW1hbmQpID0+IHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlICdscmFuZ2UnOlxuICAgICAgICAgIGlmIChhc2MpIHtcbiAgICAgICAgICAgIG11bHRpQ29tbWFuZHMucHVzaCgnbHJhbmdlJyk7XG4gICAgICAgICAgICBtdWx0aS5scmFuZ2Uoa2V5LCAtKGVuZCArIDEpLCAtKHN0YXJ0ICsgMSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdWx0aS5scmFuZ2Uoa2V5LCBzdGFydCwgZW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3pyYW5nZSc6XG4gICAgICAgICAgbXVsdGlDb21tYW5kcy5wdXNoKCd6cmFuZ2UnKTtcbiAgICAgICAgICBpZiAoYXNjKSB7XG4gICAgICAgICAgICBtdWx0aS56cmFuZ2Uoa2V5LCBzdGFydCwgZW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXVsdGkuenJldnJhbmdlKGtleSwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG11bHRpLmV4ZWMoKS50aGVuKHJlc3BvbnNlcyA9PiB7XG4gICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICByZXNwb25zZXMuZm9yRWFjaCgocmVzcG9uc2UsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlWzFdIHx8IFtdO1xuXG4gICAgICAgIGlmIChhc2MgJiYgbXVsdGlDb21tYW5kc1tpbmRleF0gPT09ICdscmFuZ2UnKSB7XG4gICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlc3VsdC5yZXZlcnNlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRKb2JzID0gZnVuY3Rpb24odHlwZXMsIHN0YXJ0LCBlbmQsIGFzYywgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmdldFJhbmdlcyh0eXBlcywgc3RhcnQsIGVuZCwgYXNjKS50aGVuKGpvYklkcyA9PiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoam9iSWRzLm1hcChqb2JJZCA9PiB0aGlzLmdldEpvYkZyb21JZChqb2JJZCwgb3B0cykpKTtcbiAgICB9KTtcbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUuZ2V0Sm9iTG9ncyA9IGZ1bmN0aW9uKGpvYklkLCBzdGFydCwgZW5kLCBhc2MgPSB0cnVlKSB7XG4gICAgc3RhcnQgPSBfLmlzVW5kZWZpbmVkKHN0YXJ0KSA/IDAgOiBzdGFydDtcbiAgICBlbmQgPSBfLmlzVW5kZWZpbmVkKGVuZCkgPyAtMSA6IGVuZDtcblxuICAgIGNvbnN0IG11bHRpID0gdGhpcy5tdWx0aSgpO1xuXG4gICAgY29uc3QgbG9nc0tleSA9IHRoaXMudG9LZXkoam9iSWQgKyAnOmxvZ3MnKTtcbiAgICBpZiAoYXNjKSB7XG4gICAgICBtdWx0aS5scmFuZ2UobG9nc0tleSwgc3RhcnQsIGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG11bHRpLmxyYW5nZShsb2dzS2V5LCAtKGVuZCArIDEpLCAtKHN0YXJ0ICsgMSkpO1xuICAgIH1cbiAgICBtdWx0aS5sbGVuKGxvZ3NLZXkpO1xuICAgIHJldHVybiBtdWx0aS5leGVjKCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgaWYgKCFhc2MpIHtcbiAgICAgICAgcmVzdWx0WzBdWzFdLnJldmVyc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvZ3M6IHJlc3VsdFswXVsxXSxcbiAgICAgICAgY291bnQ6IHJlc3VsdFsxXVsxXVxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHF1ZXVlIG1ldHJpY3MgcmVsYXRlZCB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGdhdGhlcmVkIG1ldHJpY3MgZm9yIHRoZSBxdWV1ZS5cbiAgICogVGhlIG1ldHJpY3MgYXJlIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIGpvYiBjb3VudHNcbiAgICogcGVyIHVuaXQgb2YgdGltZSAoMSBtaW51dGUpLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnQgLSBTdGFydCBwb2ludCBvZiB0aGUgbWV0cmljcywgd2hlcmUgMFxuICAgKiBpcyB0aGUgbmV3ZXN0IHBvaW50IHRvIGJlIHJldHVybmVkLlxuICAgKiBAcGFyYW0gZW5kIC0gRW5kIHBvaW5mIG9mIHRoZSBtZXRyaWNzLCB3aGVyZSAtMSBpcyB0aGVcbiAgICogb2xkZXN0IHBvaW50IHRvIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcmV0dXJucyAtIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcXVldWUgbWV0cmljcy5cbiAgICovXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gYXN5bmMgZnVuY3Rpb24odHlwZSwgc3RhcnQgPSAwLCBlbmQgPSAtMSkge1xuICAgIGNvbnN0IG1ldHJpY3NLZXkgPSB0aGlzLnRvS2V5KGBtZXRyaWNzOiR7dHlwZX1gKTtcbiAgICBjb25zdCBkYXRhS2V5ID0gYCR7bWV0cmljc0tleX06ZGF0YWA7XG5cbiAgICBjb25zdCBtdWx0aSA9IHRoaXMubXVsdGkoKTtcbiAgICBtdWx0aS5obWdldChtZXRyaWNzS2V5LCAnY291bnQnLCAncHJldlRTJywgJ3ByZXZDb3VudCcpO1xuICAgIG11bHRpLmxyYW5nZShkYXRhS2V5LCBzdGFydCwgZW5kKTtcbiAgICBtdWx0aS5sbGVuKGRhdGFLZXkpO1xuXG4gICAgY29uc3QgW2htZ2V0LCByYW5nZSwgbGVuXSA9IGF3YWl0IG11bHRpLmV4ZWMoKTtcbiAgICBjb25zdCBbZXJyLCBbY291bnQsIHByZXZUUywgcHJldkNvdW50XV0gPSBobWdldDtcbiAgICBjb25zdCBbZXJyMiwgZGF0YV0gPSByYW5nZTtcbiAgICBjb25zdCBbZXJyMywgbnVtUG9pbnRzXSA9IGxlbjtcbiAgICBpZiAoZXJyIHx8IGVycjIpIHtcbiAgICAgIHRocm93IGVyciB8fCBlcnIyIHx8IGVycjM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgY291bnQ6IHBhcnNlSW50KGNvdW50IHx8ICcwJywgMTApLFxuICAgICAgICBwcmV2VFM6IHBhcnNlSW50KHByZXZUUyB8fCAnMCcsIDEwKSxcbiAgICAgICAgcHJldkNvdW50OiBwYXJzZUludChwcmV2Q291bnQgfHwgJzAnLCAxMClcbiAgICAgIH0sXG4gICAgICBkYXRhLFxuICAgICAgY291bnQ6IG51bVBvaW50c1xuICAgIH07XG4gIH07XG59O1xuXG5mdW5jdGlvbiBwYXJzZVR5cGVBcmcoYXJncykge1xuICBjb25zdCB0eXBlcyA9IF8uY2hhaW4oW10pXG4gICAgLmNvbmNhdChhcmdzKVxuICAgIC5qb2luKCcsJylcbiAgICAuc3BsaXQoL1xccyosXFxzKi9nKVxuICAgIC5jb21wYWN0KClcbiAgICAudmFsdWUoKTtcblxuICByZXR1cm4gdHlwZXMubGVuZ3RoXG4gICAgPyB0eXBlc1xuICAgIDogWyd3YWl0aW5nJywgJ2FjdGl2ZScsICdjb21wbGV0ZWQnLCAnZmFpbGVkJywgJ2RlbGF5ZWQnLCAncGF1c2VkJ107XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/getters.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/job.js":
/*!******************************************!*\
  !*** ../../node_modules/bull/lib/job.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../../node_modules/lodash/lodash.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(action-browser)/../../node_modules/bull/lib/utils.js\");\nconst scripts = __webpack_require__(/*! ./scripts */ \"(action-browser)/../../node_modules/bull/lib/scripts.js\");\nconst debuglog = (__webpack_require__(/*! util */ \"util\").debuglog)('bull');\nconst errors = __webpack_require__(/*! ./errors */ \"(action-browser)/../../node_modules/bull/lib/errors.js\");\nconst backoffs = __webpack_require__(/*! ./backoffs */ \"(action-browser)/../../node_modules/bull/lib/backoffs.js\");\n\nconst FINISHED_WATCHDOG = 5000;\nconst DEFAULT_JOB_NAME = '__default__';\n\n/**\ninterface JobOptions\n{\n  priority: Priority;\n  attempts: number;\n  delay: number;\n}\n*/\n\nconst jobFields = [\n  'opts',\n  'name',\n  'id',\n  'progress',\n  'delay',\n  'timestamp',\n  'finishedOn',\n  'processedOn',\n  'retriedOn',\n  'failedReason',\n  'attemptsMade',\n  'stacktrace',\n  'returnvalue'\n];\n\n// queue: Queue, data: {}, opts: JobOptions\nconst Job = function(queue, name, data, opts) {\n  if (typeof name !== 'string') {\n    opts = data;\n    data = name;\n    name = DEFAULT_JOB_NAME;\n  }\n\n  // defaults\n  this.opts = setDefaultOpts(opts);\n\n  this.name = name;\n  this.queue = queue;\n  this.data = data;\n  this._progress = 0;\n  this.delay = this.opts.delay < 0 ? 0 : this.opts.delay;\n  this.timestamp = this.opts.timestamp;\n  this.stacktrace = [];\n  this.returnvalue = null;\n  this.attemptsMade = 0;\n\n  this.toKey = _.bind(queue.toKey, queue);\n  this.debounceId = this.opts.debounce ? this.opts.debounce.id : undefined;\n};\n\nfunction setDefaultOpts(opts) {\n  const _opts = Object.assign({}, opts);\n\n  _opts.attempts = typeof _opts.attempts == 'undefined' ? 1 : _opts.attempts;\n  _opts.delay = typeof _opts.delay == 'undefined' ? 0 : Number(_opts.delay);\n  _opts.timestamp =\n    typeof _opts.timestamp == 'undefined' ? Date.now() : _opts.timestamp;\n\n  _opts.attempts = parseInt(_opts.attempts);\n  _opts.backoff = backoffs.normalize(_opts.backoff);\n\n  return _opts;\n}\n\nJob.DEFAULT_JOB_NAME = DEFAULT_JOB_NAME;\n\nfunction addJob(queue, client, job) {\n  const opts = job.opts;\n\n  const jobData = job.toData();\n  return scripts.addJob(client, queue, jobData, {\n    lifo: opts.lifo,\n    customJobId: opts.jobId,\n    priority: opts.priority,\n    debounce: opts.debounce\n  });\n}\n\nJob.create = function(queue, name, data, opts) {\n  const job = new Job(queue, name, data, opts);\n\n  return queue\n    .isReady()\n    .then(() => {\n      return addJob(queue, queue.client, job);\n    })\n    .then(jobId => {\n      job.id = jobId;\n      debuglog('Job added', jobId);\n      return job;\n    });\n};\n\nJob.createBulk = function(queue, jobs) {\n  jobs = jobs.map(job => new Job(queue, job.name, job.data, job.opts));\n\n  return queue\n    .isReady()\n    .then(() => {\n      const multi = queue.client.multi();\n\n      for (const job of jobs) {\n        addJob(queue, multi, job);\n      }\n\n      return multi.exec();\n    })\n    .then(res => {\n      res.forEach((res, index) => {\n        jobs[index].id = res[1];\n        debuglog('Job added', res[1]);\n      });\n\n      return jobs;\n    });\n};\n\nJob.fromId = async function(queue, jobId, opts) {\n  // jobId can be undefined if moveJob returns undefined\n  if (!jobId) {\n    return Promise.resolve();\n  }\n\n  const jobKey = queue.toKey(jobId);\n  let rawJob;\n\n  if (opts && opts.excludeData) {\n    rawJob = _.zipObject(\n      jobFields,\n      await queue.client.hmget(jobKey, jobFields)\n    );\n  } else {\n    rawJob = await queue.client.hgetall(jobKey);\n  }\n  return _.isEmpty(rawJob) ? null : Job.fromJSON(queue, rawJob, jobId);\n};\n\nJob.remove = async function(queue, pattern) {\n  await queue.isReady();\n  const removed = await scripts.removeWithPattern(queue, pattern);\n  removed.forEach(jobId => queue.emit('removed', jobId));\n};\n\nJob.prototype.progress = function(progress) {\n  if (_.isUndefined(progress)) {\n    return this._progress;\n  }\n  this._progress = progress;\n  return scripts.updateProgress(this, progress);\n};\n\nJob.prototype.update = async function(data) {\n  this.data = data;\n  const code = await scripts.updateData(this, data);\n\n  if (code < 0) {\n    throw scripts.finishedErrors(code, this.id, 'updateData');\n  }\n};\n\nJob.prototype.toJSON = function() {\n  const opts = Object.assign({}, this.opts);\n  return {\n    id: this.id,\n    name: this.name,\n    data: this.data || {},\n    opts: opts,\n    progress: this._progress,\n    delay: this.delay, // Move to opts\n    timestamp: this.timestamp,\n    attemptsMade: this.attemptsMade,\n    failedReason: this.failedReason,\n    stacktrace: this.stacktrace || null,\n    returnvalue: this.returnvalue || null,\n    debounceId: this.debounceId || null,\n    finishedOn: this.finishedOn || null,\n    processedOn: this.processedOn || null\n  };\n};\n\nJob.prototype.toData = function() {\n  const json = this.toJSON();\n\n  json.data = JSON.stringify(json.data);\n  json.opts = JSON.stringify(json.opts);\n  json.stacktrace = JSON.stringify(json.stacktrace);\n  json.failedReason = JSON.stringify(json.failedReason);\n  json.returnvalue = JSON.stringify(json.returnvalue);\n\n  return json;\n};\n\n/**\n  Return a unique key representing a lock for this Job\n*/\nJob.prototype.lockKey = function() {\n  return this.toKey(this.id) + ':lock';\n};\n\n/**\n  Takes a lock for this job so that no other queue worker can process it at the\n  same time.\n*/\nJob.prototype.takeLock = function() {\n  return scripts.takeLock(this.queue, this).then(lock => {\n    return lock || false;\n  });\n};\n\n/**\n  Releases the lock. Only locks owned by the queue instance can be released.\n*/\nJob.prototype.releaseLock = function() {\n  return scripts.releaseLock(this.queue, this.id).then(unlocked => {\n    if (unlocked != 1) {\n      throw new Error('Could not release lock for job ' + this.id);\n    }\n  });\n};\n\n/**\n * Extend the lock for this job.\n *\n * @param duration lock duration in milliseconds\n */\nJob.prototype.extendLock = function(duration) {\n  return scripts.extendLock(this.queue, this.id, duration);\n};\n\n/**\n * Moves a job to the completed queue.\n * Returned job to be used with Queue.prototype.nextJobFromJobData.\n * @param returnValue {string} The jobs success message.\n * @param ignoreLock {boolean} True when wanting to ignore the redis lock on this job.\n * @param notFetch {boolean} True when should not fetch next job from queue.\n * @returns {Promise} Returns the jobData of the next job in the waiting queue.\n */\nJob.prototype.moveToCompleted = function(\n  returnValue,\n  ignoreLock,\n  notFetch = false\n) {\n  return this.queue.isReady().then(() => {\n    this.returnvalue = returnValue || 0;\n\n    returnValue = utils.tryCatch(JSON.stringify, JSON, [returnValue]);\n    if (returnValue === utils.errorObject) {\n      const err = utils.errorObject.value;\n      return Promise.reject(err);\n    }\n    this.finishedOn = Date.now();\n\n    return scripts.moveToCompleted(\n      this,\n      returnValue,\n      this.opts.removeOnComplete,\n      ignoreLock,\n      notFetch\n    );\n  });\n};\n\nJob.prototype.discard = function() {\n  this._discarded = true;\n};\n\n/**\n * Moves a job to the failed queue.\n * @param err {string} The jobs error message.\n * @param ignoreLock {boolean} True when wanting to ignore the redis lock on this job.\n * @returns void\n */\nJob.prototype.moveToFailed = async function(err, ignoreLock) {\n  err = err || { message: 'Unknown reason' };\n\n  this.failedReason = err.message;\n\n  await this.queue.isReady();\n\n  let command;\n  const multi = this.queue.client.multi();\n  this._saveAttempt(multi, err);\n\n  // Check if an automatic retry should be performed\n  let moveToFailed = false;\n  if (this.attemptsMade < this.opts.attempts && !this._discarded) {\n    // Check if backoff is needed\n    const delay = await backoffs.calculate(\n      this.opts.backoff,\n      this.attemptsMade,\n      this.queue.settings.backoffStrategies,\n      err,\n      _.get(this, 'opts.backoff.options', null)\n    );\n\n    if (delay === -1) {\n      // If delay is -1, we should no continue retrying\n      moveToFailed = true;\n    } else if (delay) {\n      // If so, move to delayed (need to unlock job in this case!)\n      const args = scripts.moveToDelayedArgs(\n        this.queue,\n        this.id,\n        Date.now() + delay,\n        ignoreLock\n      );\n      multi.moveToDelayed(args);\n      command = 'delayed';\n    } else {\n      // If not, retry immediately\n      multi.retryJob(scripts.retryJobArgs(this, ignoreLock));\n      command = 'retry';\n    }\n  } else {\n    // If not, move to failed\n    moveToFailed = true;\n  }\n\n  if (moveToFailed) {\n    this.finishedOn = Date.now();\n    const args = scripts.moveToFailedArgs(\n      this,\n      err.message,\n      this.opts.removeOnFail,\n      ignoreLock\n    );\n    multi.moveToFinished(args);\n    command = 'failed';\n  }\n  const results = await multi.exec();\n  const code = _.last(results)[1];\n  if (code < 0) {\n    throw scripts.finishedErrors(code, this.id, command, 'active');\n  }\n};\n\nJob.prototype.moveToDelayed = function(timestamp, ignoreLock) {\n  return scripts.moveToDelayed(this.queue, this.id, timestamp, ignoreLock);\n};\n\nJob.prototype.promote = function() {\n  const queue = this.queue;\n  const jobId = this.id;\n  return queue.isReady().then(() =>\n    scripts.promote(queue, jobId).then(result => {\n      if (result === -1) {\n        throw new Error('Job ' + jobId + ' is not in a delayed state');\n      }\n    })\n  );\n};\n\n/**\n * Attempts to retry the job. Only a job that has failed can be retried.\n *\n * @return {Promise} If resolved and return code is 1, then the queue emits a waiting event\n * otherwise the operation was not a success and throw the corresponding error. If the promise\n * rejects, it indicates that the script failed to execute\n */\nJob.prototype.retry = function() {\n  return this.queue.isReady().then(() => {\n    this.failedReason = null;\n    this.finishedOn = null;\n    this.processedOn = null;\n    this.retriedOn = Date.now();\n\n    return scripts.reprocessJob(this, { state: 'failed' }).then(result => {\n      if (result === 1) {\n        return;\n      } else if (result === 0) {\n        throw new Error(errors.Messages.RETRY_JOB_NOT_EXIST);\n      } else if (result === -1) {\n        throw new Error(errors.Messages.RETRY_JOB_IS_LOCKED);\n      } else if (result === -2) {\n        throw new Error(errors.Messages.RETRY_JOB_NOT_FAILED);\n      }\n    });\n  });\n};\n\n/**\n * Logs one row of log data.\n *\n * @params logRow: string String with log data to be logged.\n *\n */\nJob.prototype.log = function(logRow) {\n  return scripts.addLog(this.queue, this.id, logRow);\n};\n\nJob.prototype.isCompleted = function() {\n  return this._isDone('completed');\n};\n\nJob.prototype.isFailed = function() {\n  return this._isDone('failed');\n};\n\nJob.prototype.isDelayed = function() {\n  return this._isDone('delayed');\n};\n\nJob.prototype.isActive = function() {\n  return this._isInList('active');\n};\n\nJob.prototype.isWaiting = function() {\n  return this._isInList('wait');\n};\n\nJob.prototype.isPaused = function() {\n  return this._isInList('paused');\n};\n\nJob.prototype.isStuck = function() {\n  return this.getState().then(state => {\n    return state === 'stuck';\n  });\n};\n\nJob.prototype.isDiscarded = function() {\n  return this._discarded;\n};\n\nJob.prototype.getState = function() {\n  const fns = [\n    { fn: 'isCompleted', state: 'completed' },\n    { fn: 'isFailed', state: 'failed' },\n    { fn: 'isDelayed', state: 'delayed' },\n    { fn: 'isActive', state: 'active' },\n    { fn: 'isWaiting', state: 'waiting' },\n    { fn: 'isPaused', state: 'paused' }\n  ];\n\n  return fns\n    .reduce((result, fn) => {\n      return result.then(state => {\n        if (state) {\n          return state;\n        }\n        return this[fn.fn]().then(result => {\n          return result ? fn.state : null;\n        });\n      });\n    }, Promise.resolve())\n    .then(result => {\n      return result ? result : 'stuck';\n    });\n};\n\nJob.prototype.remove = function() {\n  const queue = this.queue;\n  const job = this;\n\n  return queue.isReady().then(() => {\n    return scripts.remove(queue, job.id).then(removed => {\n      if (removed) {\n        queue.emit('removed', job);\n      } else {\n        throw new Error('Could not remove job ' + job.id);\n      }\n    });\n  });\n};\n\n/**\n * Returns a promise the resolves when the job has finished. (completed or failed).\n */\nJob.prototype.finished = async function() {\n  await Promise.all([\n    this.queue._registerEvent('global:completed'),\n    this.queue._registerEvent('global:failed')\n  ]);\n\n  await this.queue.isReady();\n\n  const status = await scripts.isFinished(this);\n  const finished = status > 0;\n  if (finished) {\n    const job = await Job.fromId(this.queue, this.id);\n    if (status == 2) {\n      throw new Error(job.failedReason);\n    } else {\n      return job.returnvalue;\n    }\n  } else {\n    return new Promise((resolve, reject) => {\n      const onCompleted = (jobId, resultValue) => {\n        if (String(jobId) === String(this.id)) {\n          let result = void 0;\n          try {\n            if (typeof resultValue === 'string') {\n              result = JSON.parse(resultValue);\n            }\n          } catch (err) {\n            //swallow exception because the resultValue got corrupted somehow.\n            debuglog('corrupted resultValue: ' + resultValue, err);\n          }\n          resolve(result);\n          removeListeners();\n        }\n      };\n\n      const onFailed = (jobId, failedReason) => {\n        if (String(jobId) === String(this.id)) {\n          reject(new Error(failedReason));\n          removeListeners();\n        }\n      };\n\n      this.queue.on('global:completed', onCompleted);\n      this.queue.on('global:failed', onFailed);\n\n      const removeListeners = () => {\n        clearInterval(interval);\n        this.queue.removeListener('global:completed', onCompleted);\n        this.queue.removeListener('global:failed', onFailed);\n      };\n\n      //\n      // Watchdog\n      //\n      const interval = setInterval(() => {\n        if (this._isQueueClosing()) {\n          removeListeners();\n          // TODO(manast) maybe we would need a more graceful way to get out of this interval.\n          reject(\n            new Error('cannot check if job is finished in a closing queue.')\n          );\n        } else {\n          scripts.isFinished(this).then(status => {\n            const finished = status > 0;\n            if (finished) {\n              Job.fromId(this.queue, this.id).then(job => {\n                removeListeners();\n                if (status == 2) {\n                  reject(new Error(job.failedReason));\n                } else {\n                  resolve(job.returnvalue);\n                }\n              });\n            }\n          });\n        }\n      }, FINISHED_WATCHDOG);\n    });\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Private methods\n// -----------------------------------------------------------------------------\nJob.prototype._isQueueClosing = function() {\n  return this.queue.closing;\n};\n\nJob.prototype._isDone = function(list) {\n  return this.queue.client\n    .zscore(this.queue.toKey(list), this.id)\n    .then(score => {\n      return score !== null;\n    });\n};\n\nJob.prototype._isInList = function(list) {\n  return scripts.isJobInList(\n    this.queue.client,\n    this.queue.toKey(list),\n    this.id\n  );\n};\n\nJob.prototype._saveAttempt = function(multi, err) {\n  this.attemptsMade++;\n\n  this.stacktrace = this.stacktrace || [];\n\n  if (err && err.stack) {\n    this.stacktrace.push(err.stack);\n    if (this.opts.stackTraceLimit) {\n      this.stacktrace = this.stacktrace.slice(-this.opts.stackTraceLimit);\n    }\n  }\n\n  const args = scripts.saveStacktraceArgs(\n    this,\n    JSON.stringify(this.stacktrace),\n    err && err.message,\n  );\n\n  multi.saveStacktrace(args);\n};\n\nJob.fromJSON = function(queue, json, jobId) {\n  const opts = JSON.parse(json.opts || '{}');\n  const data = opts.preventParsingData\n    ? json.data\n    : JSON.parse(json.data || '{}');\n\n  const job = new Job(queue, json.name || Job.DEFAULT_JOB_NAME, data, opts);\n\n  job.id = json.id || jobId;\n\n  try {\n    job._progress = JSON.parse(json.progress || 0);\n  } catch (err) {\n    console.error(\n      `Error parsing progress ${json.progress} with ${err.message}`\n    );\n  }\n\n  job.delay = parseInt(json.delay);\n  job.timestamp = parseInt(json.timestamp);\n  if (json.finishedOn) {\n    job.finishedOn = parseInt(json.finishedOn);\n  }\n\n  if (json.processedOn) {\n    job.processedOn = parseInt(json.processedOn);\n  }\n\n  if (json.retriedOn) {\n    job.retriedOn = parseInt(json.retriedOn);\n  }\n\n  job.failedReason = json.failedReason;\n  job.attemptsMade = parseInt(json.attemptsMade || 0);\n\n  job.stacktrace = getTraces(json.stacktrace);\n\n  if (typeof json.returnvalue === 'string') {\n    job.returnvalue = getReturnValue(json.returnvalue);\n  }\n\n  if (json.deid) {\n    job.debounceId = json.deid;\n  }\n\n  return job;\n};\n\nfunction getTraces(stacktrace) {\n  const _traces = utils.tryCatch(JSON.parse, JSON, [stacktrace]);\n\n  if (_traces === utils.errorObject || !(_traces instanceof Array)) {\n    return [];\n  } else {\n    return _traces;\n  }\n}\n\nfunction getReturnValue(_value) {\n  const value = utils.tryCatch(JSON.parse, JSON, [_value]);\n  if (value !== utils.errorObject) {\n    return value;\n  } else {\n    debuglog('corrupted returnvalue: ' + _value, value);\n  }\n}\n\nmodule.exports = Job;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvam9iLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFVBQVUsbUJBQU8sQ0FBQyxvRUFBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsc0VBQVM7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsaUJBQWlCLGtEQUF3QjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsNEVBQVk7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQixzQkFBc0IsU0FBUztBQUMvQixvQkFBb0IsU0FBUztBQUM3QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sdUNBQXVDO0FBQzdDLE1BQU0saUNBQWlDO0FBQ3ZDLE1BQU0sbUNBQW1DO0FBQ3pDLE1BQU0saUNBQWlDO0FBQ3ZDLE1BQU0sbUNBQW1DO0FBQ3pDLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdDQUFnQyxlQUFlLE9BQU8sWUFBWTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvam9iLmpzPzRlMmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHNjcmlwdHMgPSByZXF1aXJlKCcuL3NjcmlwdHMnKTtcbmNvbnN0IGRlYnVnbG9nID0gcmVxdWlyZSgndXRpbCcpLmRlYnVnbG9nKCdidWxsJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgYmFja29mZnMgPSByZXF1aXJlKCcuL2JhY2tvZmZzJyk7XG5cbmNvbnN0IEZJTklTSEVEX1dBVENIRE9HID0gNTAwMDtcbmNvbnN0IERFRkFVTFRfSk9CX05BTUUgPSAnX19kZWZhdWx0X18nO1xuXG4vKipcbmludGVyZmFjZSBKb2JPcHRpb25zXG57XG4gIHByaW9yaXR5OiBQcmlvcml0eTtcbiAgYXR0ZW1wdHM6IG51bWJlcjtcbiAgZGVsYXk6IG51bWJlcjtcbn1cbiovXG5cbmNvbnN0IGpvYkZpZWxkcyA9IFtcbiAgJ29wdHMnLFxuICAnbmFtZScsXG4gICdpZCcsXG4gICdwcm9ncmVzcycsXG4gICdkZWxheScsXG4gICd0aW1lc3RhbXAnLFxuICAnZmluaXNoZWRPbicsXG4gICdwcm9jZXNzZWRPbicsXG4gICdyZXRyaWVkT24nLFxuICAnZmFpbGVkUmVhc29uJyxcbiAgJ2F0dGVtcHRzTWFkZScsXG4gICdzdGFja3RyYWNlJyxcbiAgJ3JldHVybnZhbHVlJ1xuXTtcblxuLy8gcXVldWU6IFF1ZXVlLCBkYXRhOiB7fSwgb3B0czogSm9iT3B0aW9uc1xuY29uc3QgSm9iID0gZnVuY3Rpb24ocXVldWUsIG5hbWUsIGRhdGEsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIG9wdHMgPSBkYXRhO1xuICAgIGRhdGEgPSBuYW1lO1xuICAgIG5hbWUgPSBERUZBVUxUX0pPQl9OQU1FO1xuICB9XG5cbiAgLy8gZGVmYXVsdHNcbiAgdGhpcy5vcHRzID0gc2V0RGVmYXVsdE9wdHMob3B0cyk7XG5cbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5xdWV1ZSA9IHF1ZXVlO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLl9wcm9ncmVzcyA9IDA7XG4gIHRoaXMuZGVsYXkgPSB0aGlzLm9wdHMuZGVsYXkgPCAwID8gMCA6IHRoaXMub3B0cy5kZWxheTtcbiAgdGhpcy50aW1lc3RhbXAgPSB0aGlzLm9wdHMudGltZXN0YW1wO1xuICB0aGlzLnN0YWNrdHJhY2UgPSBbXTtcbiAgdGhpcy5yZXR1cm52YWx1ZSA9IG51bGw7XG4gIHRoaXMuYXR0ZW1wdHNNYWRlID0gMDtcblxuICB0aGlzLnRvS2V5ID0gXy5iaW5kKHF1ZXVlLnRvS2V5LCBxdWV1ZSk7XG4gIHRoaXMuZGVib3VuY2VJZCA9IHRoaXMub3B0cy5kZWJvdW5jZSA/IHRoaXMub3B0cy5kZWJvdW5jZS5pZCA6IHVuZGVmaW5lZDtcbn07XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRPcHRzKG9wdHMpIHtcbiAgY29uc3QgX29wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKTtcblxuICBfb3B0cy5hdHRlbXB0cyA9IHR5cGVvZiBfb3B0cy5hdHRlbXB0cyA9PSAndW5kZWZpbmVkJyA/IDEgOiBfb3B0cy5hdHRlbXB0cztcbiAgX29wdHMuZGVsYXkgPSB0eXBlb2YgX29wdHMuZGVsYXkgPT0gJ3VuZGVmaW5lZCcgPyAwIDogTnVtYmVyKF9vcHRzLmRlbGF5KTtcbiAgX29wdHMudGltZXN0YW1wID1cbiAgICB0eXBlb2YgX29wdHMudGltZXN0YW1wID09ICd1bmRlZmluZWQnID8gRGF0ZS5ub3coKSA6IF9vcHRzLnRpbWVzdGFtcDtcblxuICBfb3B0cy5hdHRlbXB0cyA9IHBhcnNlSW50KF9vcHRzLmF0dGVtcHRzKTtcbiAgX29wdHMuYmFja29mZiA9IGJhY2tvZmZzLm5vcm1hbGl6ZShfb3B0cy5iYWNrb2ZmKTtcblxuICByZXR1cm4gX29wdHM7XG59XG5cbkpvYi5ERUZBVUxUX0pPQl9OQU1FID0gREVGQVVMVF9KT0JfTkFNRTtcblxuZnVuY3Rpb24gYWRkSm9iKHF1ZXVlLCBjbGllbnQsIGpvYikge1xuICBjb25zdCBvcHRzID0gam9iLm9wdHM7XG5cbiAgY29uc3Qgam9iRGF0YSA9IGpvYi50b0RhdGEoKTtcbiAgcmV0dXJuIHNjcmlwdHMuYWRkSm9iKGNsaWVudCwgcXVldWUsIGpvYkRhdGEsIHtcbiAgICBsaWZvOiBvcHRzLmxpZm8sXG4gICAgY3VzdG9tSm9iSWQ6IG9wdHMuam9iSWQsXG4gICAgcHJpb3JpdHk6IG9wdHMucHJpb3JpdHksXG4gICAgZGVib3VuY2U6IG9wdHMuZGVib3VuY2VcbiAgfSk7XG59XG5cbkpvYi5jcmVhdGUgPSBmdW5jdGlvbihxdWV1ZSwgbmFtZSwgZGF0YSwgb3B0cykge1xuICBjb25zdCBqb2IgPSBuZXcgSm9iKHF1ZXVlLCBuYW1lLCBkYXRhLCBvcHRzKTtcblxuICByZXR1cm4gcXVldWVcbiAgICAuaXNSZWFkeSgpXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIGFkZEpvYihxdWV1ZSwgcXVldWUuY2xpZW50LCBqb2IpO1xuICAgIH0pXG4gICAgLnRoZW4oam9iSWQgPT4ge1xuICAgICAgam9iLmlkID0gam9iSWQ7XG4gICAgICBkZWJ1Z2xvZygnSm9iIGFkZGVkJywgam9iSWQpO1xuICAgICAgcmV0dXJuIGpvYjtcbiAgICB9KTtcbn07XG5cbkpvYi5jcmVhdGVCdWxrID0gZnVuY3Rpb24ocXVldWUsIGpvYnMpIHtcbiAgam9icyA9IGpvYnMubWFwKGpvYiA9PiBuZXcgSm9iKHF1ZXVlLCBqb2IubmFtZSwgam9iLmRhdGEsIGpvYi5vcHRzKSk7XG5cbiAgcmV0dXJuIHF1ZXVlXG4gICAgLmlzUmVhZHkoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IG11bHRpID0gcXVldWUuY2xpZW50Lm11bHRpKCk7XG5cbiAgICAgIGZvciAoY29uc3Qgam9iIG9mIGpvYnMpIHtcbiAgICAgICAgYWRkSm9iKHF1ZXVlLCBtdWx0aSwgam9iKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG11bHRpLmV4ZWMoKTtcbiAgICB9KVxuICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICByZXMuZm9yRWFjaCgocmVzLCBpbmRleCkgPT4ge1xuICAgICAgICBqb2JzW2luZGV4XS5pZCA9IHJlc1sxXTtcbiAgICAgICAgZGVidWdsb2coJ0pvYiBhZGRlZCcsIHJlc1sxXSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGpvYnM7XG4gICAgfSk7XG59O1xuXG5Kb2IuZnJvbUlkID0gYXN5bmMgZnVuY3Rpb24ocXVldWUsIGpvYklkLCBvcHRzKSB7XG4gIC8vIGpvYklkIGNhbiBiZSB1bmRlZmluZWQgaWYgbW92ZUpvYiByZXR1cm5zIHVuZGVmaW5lZFxuICBpZiAoIWpvYklkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgY29uc3Qgam9iS2V5ID0gcXVldWUudG9LZXkoam9iSWQpO1xuICBsZXQgcmF3Sm9iO1xuXG4gIGlmIChvcHRzICYmIG9wdHMuZXhjbHVkZURhdGEpIHtcbiAgICByYXdKb2IgPSBfLnppcE9iamVjdChcbiAgICAgIGpvYkZpZWxkcyxcbiAgICAgIGF3YWl0IHF1ZXVlLmNsaWVudC5obWdldChqb2JLZXksIGpvYkZpZWxkcylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJhd0pvYiA9IGF3YWl0IHF1ZXVlLmNsaWVudC5oZ2V0YWxsKGpvYktleSk7XG4gIH1cbiAgcmV0dXJuIF8uaXNFbXB0eShyYXdKb2IpID8gbnVsbCA6IEpvYi5mcm9tSlNPTihxdWV1ZSwgcmF3Sm9iLCBqb2JJZCk7XG59O1xuXG5Kb2IucmVtb3ZlID0gYXN5bmMgZnVuY3Rpb24ocXVldWUsIHBhdHRlcm4pIHtcbiAgYXdhaXQgcXVldWUuaXNSZWFkeSgpO1xuICBjb25zdCByZW1vdmVkID0gYXdhaXQgc2NyaXB0cy5yZW1vdmVXaXRoUGF0dGVybihxdWV1ZSwgcGF0dGVybik7XG4gIHJlbW92ZWQuZm9yRWFjaChqb2JJZCA9PiBxdWV1ZS5lbWl0KCdyZW1vdmVkJywgam9iSWQpKTtcbn07XG5cbkpvYi5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbihwcm9ncmVzcykge1xuICBpZiAoXy5pc1VuZGVmaW5lZChwcm9ncmVzcykpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3Jlc3M7XG4gIH1cbiAgdGhpcy5fcHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgcmV0dXJuIHNjcmlwdHMudXBkYXRlUHJvZ3Jlc3ModGhpcywgcHJvZ3Jlc3MpO1xufTtcblxuSm9iLnByb3RvdHlwZS51cGRhdGUgPSBhc3luYyBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIGNvbnN0IGNvZGUgPSBhd2FpdCBzY3JpcHRzLnVwZGF0ZURhdGEodGhpcywgZGF0YSk7XG5cbiAgaWYgKGNvZGUgPCAwKSB7XG4gICAgdGhyb3cgc2NyaXB0cy5maW5pc2hlZEVycm9ycyhjb2RlLCB0aGlzLmlkLCAndXBkYXRlRGF0YScpO1xuICB9XG59O1xuXG5Kb2IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogdGhpcy5pZCxcbiAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgZGF0YTogdGhpcy5kYXRhIHx8IHt9LFxuICAgIG9wdHM6IG9wdHMsXG4gICAgcHJvZ3Jlc3M6IHRoaXMuX3Byb2dyZXNzLFxuICAgIGRlbGF5OiB0aGlzLmRlbGF5LCAvLyBNb3ZlIHRvIG9wdHNcbiAgICB0aW1lc3RhbXA6IHRoaXMudGltZXN0YW1wLFxuICAgIGF0dGVtcHRzTWFkZTogdGhpcy5hdHRlbXB0c01hZGUsXG4gICAgZmFpbGVkUmVhc29uOiB0aGlzLmZhaWxlZFJlYXNvbixcbiAgICBzdGFja3RyYWNlOiB0aGlzLnN0YWNrdHJhY2UgfHwgbnVsbCxcbiAgICByZXR1cm52YWx1ZTogdGhpcy5yZXR1cm52YWx1ZSB8fCBudWxsLFxuICAgIGRlYm91bmNlSWQ6IHRoaXMuZGVib3VuY2VJZCB8fCBudWxsLFxuICAgIGZpbmlzaGVkT246IHRoaXMuZmluaXNoZWRPbiB8fCBudWxsLFxuICAgIHByb2Nlc3NlZE9uOiB0aGlzLnByb2Nlc3NlZE9uIHx8IG51bGxcbiAgfTtcbn07XG5cbkpvYi5wcm90b3R5cGUudG9EYXRhID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGpzb24gPSB0aGlzLnRvSlNPTigpO1xuXG4gIGpzb24uZGF0YSA9IEpTT04uc3RyaW5naWZ5KGpzb24uZGF0YSk7XG4gIGpzb24ub3B0cyA9IEpTT04uc3RyaW5naWZ5KGpzb24ub3B0cyk7XG4gIGpzb24uc3RhY2t0cmFjZSA9IEpTT04uc3RyaW5naWZ5KGpzb24uc3RhY2t0cmFjZSk7XG4gIGpzb24uZmFpbGVkUmVhc29uID0gSlNPTi5zdHJpbmdpZnkoanNvbi5mYWlsZWRSZWFzb24pO1xuICBqc29uLnJldHVybnZhbHVlID0gSlNPTi5zdHJpbmdpZnkoanNvbi5yZXR1cm52YWx1ZSk7XG5cbiAgcmV0dXJuIGpzb247XG59O1xuXG4vKipcbiAgUmV0dXJuIGEgdW5pcXVlIGtleSByZXByZXNlbnRpbmcgYSBsb2NrIGZvciB0aGlzIEpvYlxuKi9cbkpvYi5wcm90b3R5cGUubG9ja0tleSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b0tleSh0aGlzLmlkKSArICc6bG9jayc7XG59O1xuXG4vKipcbiAgVGFrZXMgYSBsb2NrIGZvciB0aGlzIGpvYiBzbyB0aGF0IG5vIG90aGVyIHF1ZXVlIHdvcmtlciBjYW4gcHJvY2VzcyBpdCBhdCB0aGVcbiAgc2FtZSB0aW1lLlxuKi9cbkpvYi5wcm90b3R5cGUudGFrZUxvY2sgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHNjcmlwdHMudGFrZUxvY2sodGhpcy5xdWV1ZSwgdGhpcykudGhlbihsb2NrID0+IHtcbiAgICByZXR1cm4gbG9jayB8fCBmYWxzZTtcbiAgfSk7XG59O1xuXG4vKipcbiAgUmVsZWFzZXMgdGhlIGxvY2suIE9ubHkgbG9ja3Mgb3duZWQgYnkgdGhlIHF1ZXVlIGluc3RhbmNlIGNhbiBiZSByZWxlYXNlZC5cbiovXG5Kb2IucHJvdG90eXBlLnJlbGVhc2VMb2NrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBzY3JpcHRzLnJlbGVhc2VMb2NrKHRoaXMucXVldWUsIHRoaXMuaWQpLnRoZW4odW5sb2NrZWQgPT4ge1xuICAgIGlmICh1bmxvY2tlZCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZWxlYXNlIGxvY2sgZm9yIGpvYiAnICsgdGhpcy5pZCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIHRoZSBsb2NrIGZvciB0aGlzIGpvYi5cbiAqXG4gKiBAcGFyYW0gZHVyYXRpb24gbG9jayBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAqL1xuSm9iLnByb3RvdHlwZS5leHRlbmRMb2NrID0gZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgcmV0dXJuIHNjcmlwdHMuZXh0ZW5kTG9jayh0aGlzLnF1ZXVlLCB0aGlzLmlkLCBkdXJhdGlvbik7XG59O1xuXG4vKipcbiAqIE1vdmVzIGEgam9iIHRvIHRoZSBjb21wbGV0ZWQgcXVldWUuXG4gKiBSZXR1cm5lZCBqb2IgdG8gYmUgdXNlZCB3aXRoIFF1ZXVlLnByb3RvdHlwZS5uZXh0Sm9iRnJvbUpvYkRhdGEuXG4gKiBAcGFyYW0gcmV0dXJuVmFsdWUge3N0cmluZ30gVGhlIGpvYnMgc3VjY2VzcyBtZXNzYWdlLlxuICogQHBhcmFtIGlnbm9yZUxvY2sge2Jvb2xlYW59IFRydWUgd2hlbiB3YW50aW5nIHRvIGlnbm9yZSB0aGUgcmVkaXMgbG9jayBvbiB0aGlzIGpvYi5cbiAqIEBwYXJhbSBub3RGZXRjaCB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIHNob3VsZCBub3QgZmV0Y2ggbmV4dCBqb2IgZnJvbSBxdWV1ZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXR1cm5zIHRoZSBqb2JEYXRhIG9mIHRoZSBuZXh0IGpvYiBpbiB0aGUgd2FpdGluZyBxdWV1ZS5cbiAqL1xuSm9iLnByb3RvdHlwZS5tb3ZlVG9Db21wbGV0ZWQgPSBmdW5jdGlvbihcbiAgcmV0dXJuVmFsdWUsXG4gIGlnbm9yZUxvY2ssXG4gIG5vdEZldGNoID0gZmFsc2Vcbikge1xuICByZXR1cm4gdGhpcy5xdWV1ZS5pc1JlYWR5KCkudGhlbigoKSA9PiB7XG4gICAgdGhpcy5yZXR1cm52YWx1ZSA9IHJldHVyblZhbHVlIHx8IDA7XG5cbiAgICByZXR1cm5WYWx1ZSA9IHV0aWxzLnRyeUNhdGNoKEpTT04uc3RyaW5naWZ5LCBKU09OLCBbcmV0dXJuVmFsdWVdKTtcbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHV0aWxzLmVycm9yT2JqZWN0KSB7XG4gICAgICBjb25zdCBlcnIgPSB1dGlscy5lcnJvck9iamVjdC52YWx1ZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaGVkT24gPSBEYXRlLm5vdygpO1xuXG4gICAgcmV0dXJuIHNjcmlwdHMubW92ZVRvQ29tcGxldGVkKFxuICAgICAgdGhpcyxcbiAgICAgIHJldHVyblZhbHVlLFxuICAgICAgdGhpcy5vcHRzLnJlbW92ZU9uQ29tcGxldGUsXG4gICAgICBpZ25vcmVMb2NrLFxuICAgICAgbm90RmV0Y2hcbiAgICApO1xuICB9KTtcbn07XG5cbkpvYi5wcm90b3R5cGUuZGlzY2FyZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9kaXNjYXJkZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBNb3ZlcyBhIGpvYiB0byB0aGUgZmFpbGVkIHF1ZXVlLlxuICogQHBhcmFtIGVyciB7c3RyaW5nfSBUaGUgam9icyBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIGlnbm9yZUxvY2sge2Jvb2xlYW59IFRydWUgd2hlbiB3YW50aW5nIHRvIGlnbm9yZSB0aGUgcmVkaXMgbG9jayBvbiB0aGlzIGpvYi5cbiAqIEByZXR1cm5zIHZvaWRcbiAqL1xuSm9iLnByb3RvdHlwZS5tb3ZlVG9GYWlsZWQgPSBhc3luYyBmdW5jdGlvbihlcnIsIGlnbm9yZUxvY2spIHtcbiAgZXJyID0gZXJyIHx8IHsgbWVzc2FnZTogJ1Vua25vd24gcmVhc29uJyB9O1xuXG4gIHRoaXMuZmFpbGVkUmVhc29uID0gZXJyLm1lc3NhZ2U7XG5cbiAgYXdhaXQgdGhpcy5xdWV1ZS5pc1JlYWR5KCk7XG5cbiAgbGV0IGNvbW1hbmQ7XG4gIGNvbnN0IG11bHRpID0gdGhpcy5xdWV1ZS5jbGllbnQubXVsdGkoKTtcbiAgdGhpcy5fc2F2ZUF0dGVtcHQobXVsdGksIGVycik7XG5cbiAgLy8gQ2hlY2sgaWYgYW4gYXV0b21hdGljIHJldHJ5IHNob3VsZCBiZSBwZXJmb3JtZWRcbiAgbGV0IG1vdmVUb0ZhaWxlZCA9IGZhbHNlO1xuICBpZiAodGhpcy5hdHRlbXB0c01hZGUgPCB0aGlzLm9wdHMuYXR0ZW1wdHMgJiYgIXRoaXMuX2Rpc2NhcmRlZCkge1xuICAgIC8vIENoZWNrIGlmIGJhY2tvZmYgaXMgbmVlZGVkXG4gICAgY29uc3QgZGVsYXkgPSBhd2FpdCBiYWNrb2Zmcy5jYWxjdWxhdGUoXG4gICAgICB0aGlzLm9wdHMuYmFja29mZixcbiAgICAgIHRoaXMuYXR0ZW1wdHNNYWRlLFxuICAgICAgdGhpcy5xdWV1ZS5zZXR0aW5ncy5iYWNrb2ZmU3RyYXRlZ2llcyxcbiAgICAgIGVycixcbiAgICAgIF8uZ2V0KHRoaXMsICdvcHRzLmJhY2tvZmYub3B0aW9ucycsIG51bGwpXG4gICAgKTtcblxuICAgIGlmIChkZWxheSA9PT0gLTEpIHtcbiAgICAgIC8vIElmIGRlbGF5IGlzIC0xLCB3ZSBzaG91bGQgbm8gY29udGludWUgcmV0cnlpbmdcbiAgICAgIG1vdmVUb0ZhaWxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkZWxheSkge1xuICAgICAgLy8gSWYgc28sIG1vdmUgdG8gZGVsYXllZCAobmVlZCB0byB1bmxvY2sgam9iIGluIHRoaXMgY2FzZSEpXG4gICAgICBjb25zdCBhcmdzID0gc2NyaXB0cy5tb3ZlVG9EZWxheWVkQXJncyhcbiAgICAgICAgdGhpcy5xdWV1ZSxcbiAgICAgICAgdGhpcy5pZCxcbiAgICAgICAgRGF0ZS5ub3coKSArIGRlbGF5LFxuICAgICAgICBpZ25vcmVMb2NrXG4gICAgICApO1xuICAgICAgbXVsdGkubW92ZVRvRGVsYXllZChhcmdzKTtcbiAgICAgIGNvbW1hbmQgPSAnZGVsYXllZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vdCwgcmV0cnkgaW1tZWRpYXRlbHlcbiAgICAgIG11bHRpLnJldHJ5Sm9iKHNjcmlwdHMucmV0cnlKb2JBcmdzKHRoaXMsIGlnbm9yZUxvY2spKTtcbiAgICAgIGNvbW1hbmQgPSAncmV0cnknO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBub3QsIG1vdmUgdG8gZmFpbGVkXG4gICAgbW92ZVRvRmFpbGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChtb3ZlVG9GYWlsZWQpIHtcbiAgICB0aGlzLmZpbmlzaGVkT24gPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGFyZ3MgPSBzY3JpcHRzLm1vdmVUb0ZhaWxlZEFyZ3MoXG4gICAgICB0aGlzLFxuICAgICAgZXJyLm1lc3NhZ2UsXG4gICAgICB0aGlzLm9wdHMucmVtb3ZlT25GYWlsLFxuICAgICAgaWdub3JlTG9ja1xuICAgICk7XG4gICAgbXVsdGkubW92ZVRvRmluaXNoZWQoYXJncyk7XG4gICAgY29tbWFuZCA9ICdmYWlsZWQnO1xuICB9XG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBtdWx0aS5leGVjKCk7XG4gIGNvbnN0IGNvZGUgPSBfLmxhc3QocmVzdWx0cylbMV07XG4gIGlmIChjb2RlIDwgMCkge1xuICAgIHRocm93IHNjcmlwdHMuZmluaXNoZWRFcnJvcnMoY29kZSwgdGhpcy5pZCwgY29tbWFuZCwgJ2FjdGl2ZScpO1xuICB9XG59O1xuXG5Kb2IucHJvdG90eXBlLm1vdmVUb0RlbGF5ZWQgPSBmdW5jdGlvbih0aW1lc3RhbXAsIGlnbm9yZUxvY2spIHtcbiAgcmV0dXJuIHNjcmlwdHMubW92ZVRvRGVsYXllZCh0aGlzLnF1ZXVlLCB0aGlzLmlkLCB0aW1lc3RhbXAsIGlnbm9yZUxvY2spO1xufTtcblxuSm9iLnByb3RvdHlwZS5wcm9tb3RlID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgY29uc3Qgam9iSWQgPSB0aGlzLmlkO1xuICByZXR1cm4gcXVldWUuaXNSZWFkeSgpLnRoZW4oKCkgPT5cbiAgICBzY3JpcHRzLnByb21vdGUocXVldWUsIGpvYklkKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICBpZiAocmVzdWx0ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pvYiAnICsgam9iSWQgKyAnIGlzIG5vdCBpbiBhIGRlbGF5ZWQgc3RhdGUnKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXRyeSB0aGUgam9iLiBPbmx5IGEgam9iIHRoYXQgaGFzIGZhaWxlZCBjYW4gYmUgcmV0cmllZC5cbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBJZiByZXNvbHZlZCBhbmQgcmV0dXJuIGNvZGUgaXMgMSwgdGhlbiB0aGUgcXVldWUgZW1pdHMgYSB3YWl0aW5nIGV2ZW50XG4gKiBvdGhlcndpc2UgdGhlIG9wZXJhdGlvbiB3YXMgbm90IGEgc3VjY2VzcyBhbmQgdGhyb3cgdGhlIGNvcnJlc3BvbmRpbmcgZXJyb3IuIElmIHRoZSBwcm9taXNlXG4gKiByZWplY3RzLCBpdCBpbmRpY2F0ZXMgdGhhdCB0aGUgc2NyaXB0IGZhaWxlZCB0byBleGVjdXRlXG4gKi9cbkpvYi5wcm90b3R5cGUucmV0cnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucXVldWUuaXNSZWFkeSgpLnRoZW4oKCkgPT4ge1xuICAgIHRoaXMuZmFpbGVkUmVhc29uID0gbnVsbDtcbiAgICB0aGlzLmZpbmlzaGVkT24gPSBudWxsO1xuICAgIHRoaXMucHJvY2Vzc2VkT24gPSBudWxsO1xuICAgIHRoaXMucmV0cmllZE9uID0gRGF0ZS5ub3coKTtcblxuICAgIHJldHVybiBzY3JpcHRzLnJlcHJvY2Vzc0pvYih0aGlzLCB7IHN0YXRlOiAnZmFpbGVkJyB9KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICBpZiAocmVzdWx0ID09PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuTWVzc2FnZXMuUkVUUllfSk9CX05PVF9FWElTVCk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5NZXNzYWdlcy5SRVRSWV9KT0JfSVNfTE9DS0VEKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAtMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLk1lc3NhZ2VzLlJFVFJZX0pPQl9OT1RfRkFJTEVEKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIExvZ3Mgb25lIHJvdyBvZiBsb2cgZGF0YS5cbiAqXG4gKiBAcGFyYW1zIGxvZ1Jvdzogc3RyaW5nIFN0cmluZyB3aXRoIGxvZyBkYXRhIHRvIGJlIGxvZ2dlZC5cbiAqXG4gKi9cbkpvYi5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24obG9nUm93KSB7XG4gIHJldHVybiBzY3JpcHRzLmFkZExvZyh0aGlzLnF1ZXVlLCB0aGlzLmlkLCBsb2dSb3cpO1xufTtcblxuSm9iLnByb3RvdHlwZS5pc0NvbXBsZXRlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNEb25lKCdjb21wbGV0ZWQnKTtcbn07XG5cbkpvYi5wcm90b3R5cGUuaXNGYWlsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lzRG9uZSgnZmFpbGVkJyk7XG59O1xuXG5Kb2IucHJvdG90eXBlLmlzRGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNEb25lKCdkZWxheWVkJyk7XG59O1xuXG5Kb2IucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc0luTGlzdCgnYWN0aXZlJyk7XG59O1xuXG5Kb2IucHJvdG90eXBlLmlzV2FpdGluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNJbkxpc3QoJ3dhaXQnKTtcbn07XG5cbkpvYi5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lzSW5MaXN0KCdwYXVzZWQnKTtcbn07XG5cbkpvYi5wcm90b3R5cGUuaXNTdHVjayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpLnRoZW4oc3RhdGUgPT4ge1xuICAgIHJldHVybiBzdGF0ZSA9PT0gJ3N0dWNrJztcbiAgfSk7XG59O1xuXG5Kb2IucHJvdG90eXBlLmlzRGlzY2FyZGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9kaXNjYXJkZWQ7XG59O1xuXG5Kb2IucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGZucyA9IFtcbiAgICB7IGZuOiAnaXNDb21wbGV0ZWQnLCBzdGF0ZTogJ2NvbXBsZXRlZCcgfSxcbiAgICB7IGZuOiAnaXNGYWlsZWQnLCBzdGF0ZTogJ2ZhaWxlZCcgfSxcbiAgICB7IGZuOiAnaXNEZWxheWVkJywgc3RhdGU6ICdkZWxheWVkJyB9LFxuICAgIHsgZm46ICdpc0FjdGl2ZScsIHN0YXRlOiAnYWN0aXZlJyB9LFxuICAgIHsgZm46ICdpc1dhaXRpbmcnLCBzdGF0ZTogJ3dhaXRpbmcnIH0sXG4gICAgeyBmbjogJ2lzUGF1c2VkJywgc3RhdGU6ICdwYXVzZWQnIH1cbiAgXTtcblxuICByZXR1cm4gZm5zXG4gICAgLnJlZHVjZSgocmVzdWx0LCBmbikgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKHN0YXRlID0+IHtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2ZuLmZuXSgpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ID8gZm4uc3RhdGUgOiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIFByb21pc2UucmVzb2x2ZSgpKVxuICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0IDogJ3N0dWNrJztcbiAgICB9KTtcbn07XG5cbkpvYi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgY29uc3Qgam9iID0gdGhpcztcblxuICByZXR1cm4gcXVldWUuaXNSZWFkeSgpLnRoZW4oKCkgPT4ge1xuICAgIHJldHVybiBzY3JpcHRzLnJlbW92ZShxdWV1ZSwgam9iLmlkKS50aGVuKHJlbW92ZWQgPT4ge1xuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgcXVldWUuZW1pdCgncmVtb3ZlZCcsIGpvYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZW1vdmUgam9iICcgKyBqb2IuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhlIHJlc29sdmVzIHdoZW4gdGhlIGpvYiBoYXMgZmluaXNoZWQuIChjb21wbGV0ZWQgb3IgZmFpbGVkKS5cbiAqL1xuSm9iLnByb3RvdHlwZS5maW5pc2hlZCA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgdGhpcy5xdWV1ZS5fcmVnaXN0ZXJFdmVudCgnZ2xvYmFsOmNvbXBsZXRlZCcpLFxuICAgIHRoaXMucXVldWUuX3JlZ2lzdGVyRXZlbnQoJ2dsb2JhbDpmYWlsZWQnKVxuICBdKTtcblxuICBhd2FpdCB0aGlzLnF1ZXVlLmlzUmVhZHkoKTtcblxuICBjb25zdCBzdGF0dXMgPSBhd2FpdCBzY3JpcHRzLmlzRmluaXNoZWQodGhpcyk7XG4gIGNvbnN0IGZpbmlzaGVkID0gc3RhdHVzID4gMDtcbiAgaWYgKGZpbmlzaGVkKSB7XG4gICAgY29uc3Qgam9iID0gYXdhaXQgSm9iLmZyb21JZCh0aGlzLnF1ZXVlLCB0aGlzLmlkKTtcbiAgICBpZiAoc3RhdHVzID09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihqb2IuZmFpbGVkUmVhc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGpvYi5yZXR1cm52YWx1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IG9uQ29tcGxldGVkID0gKGpvYklkLCByZXN1bHRWYWx1ZSkgPT4ge1xuICAgICAgICBpZiAoU3RyaW5nKGpvYklkKSA9PT0gU3RyaW5nKHRoaXMuaWQpKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvL3N3YWxsb3cgZXhjZXB0aW9uIGJlY2F1c2UgdGhlIHJlc3VsdFZhbHVlIGdvdCBjb3JydXB0ZWQgc29tZWhvdy5cbiAgICAgICAgICAgIGRlYnVnbG9nKCdjb3JydXB0ZWQgcmVzdWx0VmFsdWU6ICcgKyByZXN1bHRWYWx1ZSwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvbkZhaWxlZCA9IChqb2JJZCwgZmFpbGVkUmVhc29uKSA9PiB7XG4gICAgICAgIGlmIChTdHJpbmcoam9iSWQpID09PSBTdHJpbmcodGhpcy5pZCkpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGZhaWxlZFJlYXNvbikpO1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnF1ZXVlLm9uKCdnbG9iYWw6Y29tcGxldGVkJywgb25Db21wbGV0ZWQpO1xuICAgICAgdGhpcy5xdWV1ZS5vbignZ2xvYmFsOmZhaWxlZCcsIG9uRmFpbGVkKTtcblxuICAgICAgY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gKCkgPT4ge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5yZW1vdmVMaXN0ZW5lcignZ2xvYmFsOmNvbXBsZXRlZCcsIG9uQ29tcGxldGVkKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5yZW1vdmVMaXN0ZW5lcignZ2xvYmFsOmZhaWxlZCcsIG9uRmFpbGVkKTtcbiAgICAgIH07XG5cbiAgICAgIC8vXG4gICAgICAvLyBXYXRjaGRvZ1xuICAgICAgLy9cbiAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5faXNRdWV1ZUNsb3NpbmcoKSkge1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIC8vIFRPRE8obWFuYXN0KSBtYXliZSB3ZSB3b3VsZCBuZWVkIGEgbW9yZSBncmFjZWZ1bCB3YXkgdG8gZ2V0IG91dCBvZiB0aGlzIGludGVydmFsLlxuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcignY2Fubm90IGNoZWNrIGlmIGpvYiBpcyBmaW5pc2hlZCBpbiBhIGNsb3NpbmcgcXVldWUuJylcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcmlwdHMuaXNGaW5pc2hlZCh0aGlzKS50aGVuKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaW5pc2hlZCA9IHN0YXR1cyA+IDA7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgSm9iLmZyb21JZCh0aGlzLnF1ZXVlLCB0aGlzLmlkKS50aGVuKGpvYiA9PiB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGpvYi5mYWlsZWRSZWFzb24pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShqb2IucmV0dXJudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIEZJTklTSEVEX1dBVENIRE9HKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbkpvYi5wcm90b3R5cGUuX2lzUXVldWVDbG9zaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnF1ZXVlLmNsb3Npbmc7XG59O1xuXG5Kb2IucHJvdG90eXBlLl9pc0RvbmUgPSBmdW5jdGlvbihsaXN0KSB7XG4gIHJldHVybiB0aGlzLnF1ZXVlLmNsaWVudFxuICAgIC56c2NvcmUodGhpcy5xdWV1ZS50b0tleShsaXN0KSwgdGhpcy5pZClcbiAgICAudGhlbihzY29yZSA9PiB7XG4gICAgICByZXR1cm4gc2NvcmUgIT09IG51bGw7XG4gICAgfSk7XG59O1xuXG5Kb2IucHJvdG90eXBlLl9pc0luTGlzdCA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgcmV0dXJuIHNjcmlwdHMuaXNKb2JJbkxpc3QoXG4gICAgdGhpcy5xdWV1ZS5jbGllbnQsXG4gICAgdGhpcy5xdWV1ZS50b0tleShsaXN0KSxcbiAgICB0aGlzLmlkXG4gICk7XG59O1xuXG5Kb2IucHJvdG90eXBlLl9zYXZlQXR0ZW1wdCA9IGZ1bmN0aW9uKG11bHRpLCBlcnIpIHtcbiAgdGhpcy5hdHRlbXB0c01hZGUrKztcblxuICB0aGlzLnN0YWNrdHJhY2UgPSB0aGlzLnN0YWNrdHJhY2UgfHwgW107XG5cbiAgaWYgKGVyciAmJiBlcnIuc3RhY2spIHtcbiAgICB0aGlzLnN0YWNrdHJhY2UucHVzaChlcnIuc3RhY2spO1xuICAgIGlmICh0aGlzLm9wdHMuc3RhY2tUcmFjZUxpbWl0KSB7XG4gICAgICB0aGlzLnN0YWNrdHJhY2UgPSB0aGlzLnN0YWNrdHJhY2Uuc2xpY2UoLXRoaXMub3B0cy5zdGFja1RyYWNlTGltaXQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFyZ3MgPSBzY3JpcHRzLnNhdmVTdGFja3RyYWNlQXJncyhcbiAgICB0aGlzLFxuICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuc3RhY2t0cmFjZSksXG4gICAgZXJyICYmIGVyci5tZXNzYWdlLFxuICApO1xuXG4gIG11bHRpLnNhdmVTdGFja3RyYWNlKGFyZ3MpO1xufTtcblxuSm9iLmZyb21KU09OID0gZnVuY3Rpb24ocXVldWUsIGpzb24sIGpvYklkKSB7XG4gIGNvbnN0IG9wdHMgPSBKU09OLnBhcnNlKGpzb24ub3B0cyB8fCAne30nKTtcbiAgY29uc3QgZGF0YSA9IG9wdHMucHJldmVudFBhcnNpbmdEYXRhXG4gICAgPyBqc29uLmRhdGFcbiAgICA6IEpTT04ucGFyc2UoanNvbi5kYXRhIHx8ICd7fScpO1xuXG4gIGNvbnN0IGpvYiA9IG5ldyBKb2IocXVldWUsIGpzb24ubmFtZSB8fCBKb2IuREVGQVVMVF9KT0JfTkFNRSwgZGF0YSwgb3B0cyk7XG5cbiAgam9iLmlkID0ganNvbi5pZCB8fCBqb2JJZDtcblxuICB0cnkge1xuICAgIGpvYi5fcHJvZ3Jlc3MgPSBKU09OLnBhcnNlKGpzb24ucHJvZ3Jlc3MgfHwgMCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBgRXJyb3IgcGFyc2luZyBwcm9ncmVzcyAke2pzb24ucHJvZ3Jlc3N9IHdpdGggJHtlcnIubWVzc2FnZX1gXG4gICAgKTtcbiAgfVxuXG4gIGpvYi5kZWxheSA9IHBhcnNlSW50KGpzb24uZGVsYXkpO1xuICBqb2IudGltZXN0YW1wID0gcGFyc2VJbnQoanNvbi50aW1lc3RhbXApO1xuICBpZiAoanNvbi5maW5pc2hlZE9uKSB7XG4gICAgam9iLmZpbmlzaGVkT24gPSBwYXJzZUludChqc29uLmZpbmlzaGVkT24pO1xuICB9XG5cbiAgaWYgKGpzb24ucHJvY2Vzc2VkT24pIHtcbiAgICBqb2IucHJvY2Vzc2VkT24gPSBwYXJzZUludChqc29uLnByb2Nlc3NlZE9uKTtcbiAgfVxuXG4gIGlmIChqc29uLnJldHJpZWRPbikge1xuICAgIGpvYi5yZXRyaWVkT24gPSBwYXJzZUludChqc29uLnJldHJpZWRPbik7XG4gIH1cblxuICBqb2IuZmFpbGVkUmVhc29uID0ganNvbi5mYWlsZWRSZWFzb247XG4gIGpvYi5hdHRlbXB0c01hZGUgPSBwYXJzZUludChqc29uLmF0dGVtcHRzTWFkZSB8fCAwKTtcblxuICBqb2Iuc3RhY2t0cmFjZSA9IGdldFRyYWNlcyhqc29uLnN0YWNrdHJhY2UpO1xuXG4gIGlmICh0eXBlb2YganNvbi5yZXR1cm52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBqb2IucmV0dXJudmFsdWUgPSBnZXRSZXR1cm5WYWx1ZShqc29uLnJldHVybnZhbHVlKTtcbiAgfVxuXG4gIGlmIChqc29uLmRlaWQpIHtcbiAgICBqb2IuZGVib3VuY2VJZCA9IGpzb24uZGVpZDtcbiAgfVxuXG4gIHJldHVybiBqb2I7XG59O1xuXG5mdW5jdGlvbiBnZXRUcmFjZXMoc3RhY2t0cmFjZSkge1xuICBjb25zdCBfdHJhY2VzID0gdXRpbHMudHJ5Q2F0Y2goSlNPTi5wYXJzZSwgSlNPTiwgW3N0YWNrdHJhY2VdKTtcblxuICBpZiAoX3RyYWNlcyA9PT0gdXRpbHMuZXJyb3JPYmplY3QgfHwgIShfdHJhY2VzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBfdHJhY2VzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJldHVyblZhbHVlKF92YWx1ZSkge1xuICBjb25zdCB2YWx1ZSA9IHV0aWxzLnRyeUNhdGNoKEpTT04ucGFyc2UsIEpTT04sIFtfdmFsdWVdKTtcbiAgaWYgKHZhbHVlICE9PSB1dGlscy5lcnJvck9iamVjdCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1Z2xvZygnY29ycnVwdGVkIHJldHVybnZhbHVlOiAnICsgX3ZhbHVlLCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBKb2I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/job.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/p-timeout.js":
/*!************************************************!*\
  !*** ../../node_modules/bull/lib/p-timeout.js ***!
  \************************************************/
/***/ ((module) => {

eval("// Extracted from p-timeout https://github.com/sindresorhus/p-timeout\n// as it is not commonjs compatible. This is version 5.0.2\n\n\nclass TimeoutError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'TimeoutError';\n  }\n}\n\nmodule.exports.TimeoutError = TimeoutError;\n\nmodule.exports.pTimeout = function pTimeout(\n  promise,\n  milliseconds,\n  fallback,\n  options\n) {\n  let timer;\n  const cancelablePromise = new Promise((resolve, reject) => {\n    if (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n      throw new TypeError(\n        `Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``\n      );\n    }\n\n    if (milliseconds === Number.POSITIVE_INFINITY) {\n      resolve(promise);\n      return;\n    }\n\n    options = {\n      customTimers: { setTimeout, clearTimeout },\n      ...options\n    };\n\n    timer = options.customTimers.setTimeout.call(\n      undefined,\n      () => {\n        if (typeof fallback === 'function') {\n          try {\n            resolve(fallback());\n          } catch (error) {\n            reject(error);\n          }\n\n          return;\n        }\n\n        const message =\n          typeof fallback === 'string'\n            ? fallback\n            : `Promise timed out after ${milliseconds} milliseconds`;\n        const timeoutError =\n          fallback instanceof Error ? fallback : new TimeoutError(message);\n\n        if (typeof promise.cancel === 'function') {\n          promise.cancel();\n        }\n\n        reject(timeoutError);\n      },\n      milliseconds\n    );\n\n    (async () => {\n      try {\n        resolve(await promise);\n      } catch (error) {\n        reject(error);\n      } finally {\n        options.customTimers.clearTimeout.call(undefined, timer);\n      }\n    })();\n  });\n\n  cancelablePromise['clear'] = () => {\n    clearTimeout(timer);\n    timer = undefined;\n  };\n\n  return cancelablePromise;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcC10aW1lb3V0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGFBQWE7QUFDakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9wLXRpbWVvdXQuanM/ZDA1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFeHRyYWN0ZWQgZnJvbSBwLXRpbWVvdXQgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLXRpbWVvdXRcbi8vIGFzIGl0IGlzIG5vdCBjb21tb25qcyBjb21wYXRpYmxlLiBUaGlzIGlzIHZlcnNpb24gNS4wLjJcbid1c2Ugc3RyaWN0JztcblxuY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cy5wVGltZW91dCA9IGZ1bmN0aW9uIHBUaW1lb3V0KFxuICBwcm9taXNlLFxuICBtaWxsaXNlY29uZHMsXG4gIGZhbGxiYWNrLFxuICBvcHRpb25zXG4pIHtcbiAgbGV0IHRpbWVyO1xuICBjb25zdCBjYW5jZWxhYmxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAodHlwZW9mIG1pbGxpc2Vjb25kcyAhPT0gJ251bWJlcicgfHwgTWF0aC5zaWduKG1pbGxpc2Vjb25kcykgIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBcXGBtaWxsaXNlY29uZHNcXGAgdG8gYmUgYSBwb3NpdGl2ZSBudW1iZXIsIGdvdCBcXGAke21pbGxpc2Vjb25kc31cXGBgXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChtaWxsaXNlY29uZHMgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgcmVzb2x2ZShwcm9taXNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgY3VzdG9tVGltZXJzOiB7IHNldFRpbWVvdXQsIGNsZWFyVGltZW91dCB9LFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICB0aW1lciA9IG9wdGlvbnMuY3VzdG9tVGltZXJzLnNldFRpbWVvdXQuY2FsbChcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgICgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNvbHZlKGZhbGxiYWNrKCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgIHR5cGVvZiBmYWxsYmFjayA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gZmFsbGJhY2tcbiAgICAgICAgICAgIDogYFByb21pc2UgdGltZWQgb3V0IGFmdGVyICR7bWlsbGlzZWNvbmRzfSBtaWxsaXNlY29uZHNgO1xuICAgICAgICBjb25zdCB0aW1lb3V0RXJyb3IgPVxuICAgICAgICAgIGZhbGxiYWNrIGluc3RhbmNlb2YgRXJyb3IgPyBmYWxsYmFjayA6IG5ldyBUaW1lb3V0RXJyb3IobWVzc2FnZSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9taXNlLmNhbmNlbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWplY3QodGltZW91dEVycm9yKTtcbiAgICAgIH0sXG4gICAgICBtaWxsaXNlY29uZHNcbiAgICApO1xuXG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmUoYXdhaXQgcHJvbWlzZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgb3B0aW9ucy5jdXN0b21UaW1lcnMuY2xlYXJUaW1lb3V0LmNhbGwodW5kZWZpbmVkLCB0aW1lcik7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfSk7XG5cbiAgY2FuY2VsYWJsZVByb21pc2VbJ2NsZWFyJ10gPSAoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHVuZGVmaW5lZDtcbiAgfTtcblxuICByZXR1cm4gY2FuY2VsYWJsZVByb21pc2U7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/p-timeout.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/process/child-pool.js":
/*!*********************************************************!*\
  !*** ../../node_modules/bull/lib/process/child-pool.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst fork = (__webpack_require__(/*! child_process */ \"child_process\").fork);\nconst path = __webpack_require__(/*! path */ \"path\");\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../../node_modules/lodash/lodash.js\");\nconst getPort = __webpack_require__(/*! get-port */ \"(action-browser)/../../node_modules/get-port/index.js\");\nconst { killAsync } = __webpack_require__(/*! ./utils */ \"(action-browser)/../../node_modules/bull/lib/process/utils.js\");\n\nconst CHILD_KILL_TIMEOUT = 30000;\n\nconst ChildPool = function ChildPool() {\n  if (!(this instanceof ChildPool)) {\n    return new ChildPool();\n  }\n\n  this.retained = {};\n  this.free = {};\n};\n\nconst convertExecArgv = function(execArgv) {\n  const standard = [];\n  const promises = [];\n\n  _.forEach(execArgv, arg => {\n    if (arg.indexOf('--inspect') === -1) {\n      standard.push(arg);\n    } else {\n      const argName = arg.split('=')[0];\n      promises.push(\n        getPort().then(port => {\n          return `${argName}=${port}`;\n        })\n      );\n    }\n  });\n\n  return Promise.all(promises).then(convertedArgs => {\n    return standard.concat(convertedArgs);\n  });\n};\n\nChildPool.prototype.retain = function(processFile) {\n  const _this = this;\n  let child = _this.getFree(processFile).pop();\n\n  if (child) {\n    _this.retained[child.pid] = child;\n    return Promise.resolve(child);\n  }\n\n  return convertExecArgv(process.execArgv).then(execArgv => {\n    child = fork(path.join(__dirname, './master.js'), {\n      execArgv\n    });\n    child.processFile = processFile;\n\n    _this.retained[child.pid] = child;\n\n    child.on('exit', _this.remove.bind(_this, child));\n\n    return initChild(child, child.processFile)\n      .then(() => {\n        return child;\n      })\n      .catch(err => {\n        this.remove(child);\n        throw err;\n      });\n  });\n};\n\nChildPool.prototype.release = function(child) {\n  delete this.retained[child.pid];\n  this.getFree(child.processFile).push(child);\n};\n\nChildPool.prototype.remove = function(child) {\n  delete this.retained[child.pid];\n\n  const free = this.getFree(child.processFile);\n\n  const childIndex = free.indexOf(child);\n  if (childIndex > -1) {\n    free.splice(childIndex, 1);\n  }\n};\n\nChildPool.prototype.kill = function(child, signal) {\n  this.remove(child);\n  return killAsync(child, signal || 'SIGKILL', CHILD_KILL_TIMEOUT);\n};\n\nChildPool.prototype.clean = function() {\n  const children = _.values(this.retained).concat(this.getAllFree());\n  this.retained = {};\n  this.free = {};\n\n  const allKillPromises = [];\n  children.forEach(child => {\n    allKillPromises.push(this.kill(child, 'SIGTERM'));\n  });\n  return Promise.all(allKillPromises).then(() => {});\n};\n\nChildPool.prototype.getFree = function(id) {\n  return (this.free[id] = this.free[id] || []);\n};\n\nChildPool.prototype.getAllFree = function() {\n  return _.flatten(_.values(this.free));\n};\n\nasync function initChild(child, processFile) {\n  const onComplete = new Promise((resolve, reject) => {\n    const onMessageHandler = msg => {\n      if (msg.cmd === 'init-complete') {\n        resolve();\n      } else if (msg.cmd === 'error') {\n        reject(msg.error);\n      }\n      child.off('message', onMessageHandler);\n    };\n    child.on('message', onMessageHandler);\n  });\n\n  await new Promise(resolve =>\n    child.send({ cmd: 'init', value: processFile }, resolve)\n  );\n  await onComplete;\n}\nfunction ChildPoolSingleton(isSharedChildPool = false) {\n  if (isSharedChildPool === false) {\n    return new ChildPool();\n  } else if (\n    !(this instanceof ChildPool) &&\n    ChildPoolSingleton.instance === undefined\n  ) {\n    ChildPoolSingleton.instance = new ChildPool();\n  }\n\n  return ChildPoolSingleton.instance;\n}\n\nmodule.exports = ChildPoolSingleton;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcHJvY2Vzcy9jaGlsZC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsZ0VBQTZCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixVQUFVLG1CQUFPLENBQUMsb0VBQVE7QUFDMUIsZ0JBQWdCLG1CQUFPLENBQUMsdUVBQVU7QUFDbEMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyw4RUFBUzs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsR0FBRyxLQUFLO0FBQ3BDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsaUJBQWlCLGlDQUFpQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9wcm9jZXNzL2NoaWxkLXBvb2wuanM/NzE1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGZvcmsgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZm9yaztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBnZXRQb3J0ID0gcmVxdWlyZSgnZ2V0LXBvcnQnKTtcbmNvbnN0IHsga2lsbEFzeW5jIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmNvbnN0IENISUxEX0tJTExfVElNRU9VVCA9IDMwMDAwO1xuXG5jb25zdCBDaGlsZFBvb2wgPSBmdW5jdGlvbiBDaGlsZFBvb2woKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDaGlsZFBvb2wpKSB7XG4gICAgcmV0dXJuIG5ldyBDaGlsZFBvb2woKTtcbiAgfVxuXG4gIHRoaXMucmV0YWluZWQgPSB7fTtcbiAgdGhpcy5mcmVlID0ge307XG59O1xuXG5jb25zdCBjb252ZXJ0RXhlY0FyZ3YgPSBmdW5jdGlvbihleGVjQXJndikge1xuICBjb25zdCBzdGFuZGFyZCA9IFtdO1xuICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gIF8uZm9yRWFjaChleGVjQXJndiwgYXJnID0+IHtcbiAgICBpZiAoYXJnLmluZGV4T2YoJy0taW5zcGVjdCcpID09PSAtMSkge1xuICAgICAgc3RhbmRhcmQucHVzaChhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhcmdOYW1lID0gYXJnLnNwbGl0KCc9JylbMF07XG4gICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICBnZXRQb3J0KCkudGhlbihwb3J0ID0+IHtcbiAgICAgICAgICByZXR1cm4gYCR7YXJnTmFtZX09JHtwb3J0fWA7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGNvbnZlcnRlZEFyZ3MgPT4ge1xuICAgIHJldHVybiBzdGFuZGFyZC5jb25jYXQoY29udmVydGVkQXJncyk7XG4gIH0pO1xufTtcblxuQ2hpbGRQb29sLnByb3RvdHlwZS5yZXRhaW4gPSBmdW5jdGlvbihwcm9jZXNzRmlsZSkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGxldCBjaGlsZCA9IF90aGlzLmdldEZyZWUocHJvY2Vzc0ZpbGUpLnBvcCgpO1xuXG4gIGlmIChjaGlsZCkge1xuICAgIF90aGlzLnJldGFpbmVkW2NoaWxkLnBpZF0gPSBjaGlsZDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0RXhlY0FyZ3YocHJvY2Vzcy5leGVjQXJndikudGhlbihleGVjQXJndiA9PiB7XG4gICAgY2hpbGQgPSBmb3JrKHBhdGguam9pbihfX2Rpcm5hbWUsICcuL21hc3Rlci5qcycpLCB7XG4gICAgICBleGVjQXJndlxuICAgIH0pO1xuICAgIGNoaWxkLnByb2Nlc3NGaWxlID0gcHJvY2Vzc0ZpbGU7XG5cbiAgICBfdGhpcy5yZXRhaW5lZFtjaGlsZC5waWRdID0gY2hpbGQ7XG5cbiAgICBjaGlsZC5vbignZXhpdCcsIF90aGlzLnJlbW92ZS5iaW5kKF90aGlzLCBjaGlsZCkpO1xuXG4gICAgcmV0dXJuIGluaXRDaGlsZChjaGlsZCwgY2hpbGQucHJvY2Vzc0ZpbGUpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmUoY2hpbGQpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgfSk7XG59O1xuXG5DaGlsZFBvb2wucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbihjaGlsZCkge1xuICBkZWxldGUgdGhpcy5yZXRhaW5lZFtjaGlsZC5waWRdO1xuICB0aGlzLmdldEZyZWUoY2hpbGQucHJvY2Vzc0ZpbGUpLnB1c2goY2hpbGQpO1xufTtcblxuQ2hpbGRQb29sLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihjaGlsZCkge1xuICBkZWxldGUgdGhpcy5yZXRhaW5lZFtjaGlsZC5waWRdO1xuXG4gIGNvbnN0IGZyZWUgPSB0aGlzLmdldEZyZWUoY2hpbGQucHJvY2Vzc0ZpbGUpO1xuXG4gIGNvbnN0IGNoaWxkSW5kZXggPSBmcmVlLmluZGV4T2YoY2hpbGQpO1xuICBpZiAoY2hpbGRJbmRleCA+IC0xKSB7XG4gICAgZnJlZS5zcGxpY2UoY2hpbGRJbmRleCwgMSk7XG4gIH1cbn07XG5cbkNoaWxkUG9vbC5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKGNoaWxkLCBzaWduYWwpIHtcbiAgdGhpcy5yZW1vdmUoY2hpbGQpO1xuICByZXR1cm4ga2lsbEFzeW5jKGNoaWxkLCBzaWduYWwgfHwgJ1NJR0tJTEwnLCBDSElMRF9LSUxMX1RJTUVPVVQpO1xufTtcblxuQ2hpbGRQb29sLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBjaGlsZHJlbiA9IF8udmFsdWVzKHRoaXMucmV0YWluZWQpLmNvbmNhdCh0aGlzLmdldEFsbEZyZWUoKSk7XG4gIHRoaXMucmV0YWluZWQgPSB7fTtcbiAgdGhpcy5mcmVlID0ge307XG5cbiAgY29uc3QgYWxsS2lsbFByb21pc2VzID0gW107XG4gIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIGFsbEtpbGxQcm9taXNlcy5wdXNoKHRoaXMua2lsbChjaGlsZCwgJ1NJR1RFUk0nKSk7XG4gIH0pO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoYWxsS2lsbFByb21pc2VzKS50aGVuKCgpID0+IHt9KTtcbn07XG5cbkNoaWxkUG9vbC5wcm90b3R5cGUuZ2V0RnJlZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiAodGhpcy5mcmVlW2lkXSA9IHRoaXMuZnJlZVtpZF0gfHwgW10pO1xufTtcblxuQ2hpbGRQb29sLnByb3RvdHlwZS5nZXRBbGxGcmVlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfLmZsYXR0ZW4oXy52YWx1ZXModGhpcy5mcmVlKSk7XG59O1xuXG5hc3luYyBmdW5jdGlvbiBpbml0Q2hpbGQoY2hpbGQsIHByb2Nlc3NGaWxlKSB7XG4gIGNvbnN0IG9uQ29tcGxldGUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgb25NZXNzYWdlSGFuZGxlciA9IG1zZyA9PiB7XG4gICAgICBpZiAobXNnLmNtZCA9PT0gJ2luaXQtY29tcGxldGUnKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAobXNnLmNtZCA9PT0gJ2Vycm9yJykge1xuICAgICAgICByZWplY3QobXNnLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLm9mZignbWVzc2FnZScsIG9uTWVzc2FnZUhhbmRsZXIpO1xuICAgIH07XG4gICAgY2hpbGQub24oJ21lc3NhZ2UnLCBvbk1lc3NhZ2VIYW5kbGVyKTtcbiAgfSk7XG5cbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PlxuICAgIGNoaWxkLnNlbmQoeyBjbWQ6ICdpbml0JywgdmFsdWU6IHByb2Nlc3NGaWxlIH0sIHJlc29sdmUpXG4gICk7XG4gIGF3YWl0IG9uQ29tcGxldGU7XG59XG5mdW5jdGlvbiBDaGlsZFBvb2xTaW5nbGV0b24oaXNTaGFyZWRDaGlsZFBvb2wgPSBmYWxzZSkge1xuICBpZiAoaXNTaGFyZWRDaGlsZFBvb2wgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG5ldyBDaGlsZFBvb2woKTtcbiAgfSBlbHNlIGlmIChcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBDaGlsZFBvb2wpICYmXG4gICAgQ2hpbGRQb29sU2luZ2xldG9uLmluc3RhbmNlID09PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgQ2hpbGRQb29sU2luZ2xldG9uLmluc3RhbmNlID0gbmV3IENoaWxkUG9vbCgpO1xuICB9XG5cbiAgcmV0dXJuIENoaWxkUG9vbFNpbmdsZXRvbi5pbnN0YW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaGlsZFBvb2xTaW5nbGV0b247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/process/child-pool.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/process/sandbox.js":
/*!******************************************************!*\
  !*** ../../node_modules/bull/lib/process/sandbox.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { asyncSend } = __webpack_require__(/*! ./utils */ \"(action-browser)/../../node_modules/bull/lib/process/utils.js\");\n\nmodule.exports = function(processFile, childPool) {\n  return function process(job) {\n    return childPool.retain(processFile).then(async child => {\n      let msgHandler;\n      let exitHandler;\n\n      await asyncSend(child, {\n        cmd: 'start',\n        job: job\n      });\n\n      const done = new Promise((resolve, reject) => {\n        msgHandler = function(msg) {\n          switch (msg.cmd) {\n            case 'completed':\n              resolve(msg.value);\n              break;\n            case 'failed':\n            case 'error': {\n              const err = new Error();\n              Object.assign(err, msg.value);\n              reject(err);\n              break;\n            }\n            case 'progress':\n              job.progress(msg.value);\n              break;\n            case 'update':\n              job.update(msg.value);\n              break;\n            case 'discard':\n              job.discard();\n              break;\n            case 'log':\n              job.log(msg.value);\n              break;\n          }\n        };\n\n        exitHandler = (exitCode, signal) => {\n          reject(\n            new Error(\n              'Unexpected exit code: ' + exitCode + ' signal: ' + signal\n            )\n          );\n        };\n\n        child.on('message', msgHandler);\n        child.on('exit', exitHandler);\n      });\n\n      return done.finally(() => {\n        child.removeListener('message', msgHandler);\n        child.removeListener('exit', exitHandler);\n\n        if (child.exitCode !== null || /SIG.*/.test(child.signalCode)) {\n          childPool.remove(child);\n        } else {\n          childPool.release(child);\n        }\n      });\n    });\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcHJvY2Vzcy9zYW5kYm94LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsOEVBQVM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcHJvY2Vzcy9zYW5kYm94LmpzPzU4NzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGFzeW5jU2VuZCB9ID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb2Nlc3NGaWxlLCBjaGlsZFBvb2wpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb2Nlc3Moam9iKSB7XG4gICAgcmV0dXJuIGNoaWxkUG9vbC5yZXRhaW4ocHJvY2Vzc0ZpbGUpLnRoZW4oYXN5bmMgY2hpbGQgPT4ge1xuICAgICAgbGV0IG1zZ0hhbmRsZXI7XG4gICAgICBsZXQgZXhpdEhhbmRsZXI7XG5cbiAgICAgIGF3YWl0IGFzeW5jU2VuZChjaGlsZCwge1xuICAgICAgICBjbWQ6ICdzdGFydCcsXG4gICAgICAgIGpvYjogam9iXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZG9uZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbXNnSGFuZGxlciA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICAgIHN3aXRjaCAobXNnLmNtZCkge1xuICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgICAgICAgcmVzb2x2ZShtc2cudmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6IHtcbiAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZXJyLCBtc2cudmFsdWUpO1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdwcm9ncmVzcyc6XG4gICAgICAgICAgICAgIGpvYi5wcm9ncmVzcyhtc2cudmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgICAgIGpvYi51cGRhdGUobXNnLnZhbHVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkaXNjYXJkJzpcbiAgICAgICAgICAgICAgam9iLmRpc2NhcmQoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsb2cnOlxuICAgICAgICAgICAgICBqb2IubG9nKG1zZy52YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBleGl0SGFuZGxlciA9IChleGl0Q29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnVW5leHBlY3RlZCBleGl0IGNvZGU6ICcgKyBleGl0Q29kZSArICcgc2lnbmFsOiAnICsgc2lnbmFsXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjaGlsZC5vbignbWVzc2FnZScsIG1zZ0hhbmRsZXIpO1xuICAgICAgICBjaGlsZC5vbignZXhpdCcsIGV4aXRIYW5kbGVyKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZG9uZS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgY2hpbGQucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBtc2dIYW5kbGVyKTtcbiAgICAgICAgY2hpbGQucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBleGl0SGFuZGxlcik7XG5cbiAgICAgICAgaWYgKGNoaWxkLmV4aXRDb2RlICE9PSBudWxsIHx8IC9TSUcuKi8udGVzdChjaGlsZC5zaWduYWxDb2RlKSkge1xuICAgICAgICAgIGNoaWxkUG9vbC5yZW1vdmUoY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkUG9vbC5yZWxlYXNlKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/process/sandbox.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/process/utils.js":
/*!****************************************************!*\
  !*** ../../node_modules/bull/lib/process/utils.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\n\nfunction hasProcessExited(child) {\n  return !!(child.exitCode !== null || child.signalCode);\n}\n\nfunction onExitOnce(child) {\n  return new Promise(resolve => {\n    child.once('exit', () => resolve());\n  });\n}\n\n/**\n * Sends a kill signal to a child resolving when the child has exited,\n * resorting to SIGKILL if the given timeout is reached\n *\n * @param {ChildProcess} child\n * @param {'SIGTERM' | 'SIGKILL'} [signal] initial signal to use\n * @param {number} [timeoutMs] time to wait until sending SIGKILL\n *\n * @returns {Promise<void>} the killed child\n */\nfunction killAsync(child, signal, timeoutMs) {\n  if (hasProcessExited(child)) {\n    return Promise.resolve(child);\n  }\n\n  // catch any new on exit\n  let onExit = onExitOnce(child);\n\n  child.kill(signal || 'SIGKILL');\n\n  if (timeoutMs === 0 || isFinite(timeoutMs)) {\n    const timeout = setTimeout(() => {\n      if (!hasProcessExited(child)) {\n        child.kill('SIGKILL');\n      }\n    }, timeoutMs);\n\n    onExit = onExit.then(() => {\n      clearTimeout(timeout);\n    });\n  }\n  return onExit;\n}\n\n/*\n asyncSend\n Same as process.send but waits until the send is complete\n the async version is used below because otherwise\n the termination handler may exit before the parent\n process has recived the messages it requires\n */\n\nconst asyncSend = (proc, msg) => {\n  return new Promise((resolve, reject) => {\n    proc.send(msg, err => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n};\n\nmodule.exports = {\n  killAsync,\n  asyncSend\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcHJvY2Vzcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcHJvY2Vzcy91dGlscy5qcz82NjUwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaGFzUHJvY2Vzc0V4aXRlZChjaGlsZCkge1xuICByZXR1cm4gISEoY2hpbGQuZXhpdENvZGUgIT09IG51bGwgfHwgY2hpbGQuc2lnbmFsQ29kZSk7XG59XG5cbmZ1bmN0aW9uIG9uRXhpdE9uY2UoY2hpbGQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNoaWxkLm9uY2UoJ2V4aXQnLCAoKSA9PiByZXNvbHZlKCkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZW5kcyBhIGtpbGwgc2lnbmFsIHRvIGEgY2hpbGQgcmVzb2x2aW5nIHdoZW4gdGhlIGNoaWxkIGhhcyBleGl0ZWQsXG4gKiByZXNvcnRpbmcgdG8gU0lHS0lMTCBpZiB0aGUgZ2l2ZW4gdGltZW91dCBpcyByZWFjaGVkXG4gKlxuICogQHBhcmFtIHtDaGlsZFByb2Nlc3N9IGNoaWxkXG4gKiBAcGFyYW0geydTSUdURVJNJyB8ICdTSUdLSUxMJ30gW3NpZ25hbF0gaW5pdGlhbCBzaWduYWwgdG8gdXNlXG4gKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXRNc10gdGltZSB0byB3YWl0IHVudGlsIHNlbmRpbmcgU0lHS0lMTFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSB0aGUga2lsbGVkIGNoaWxkXG4gKi9cbmZ1bmN0aW9uIGtpbGxBc3luYyhjaGlsZCwgc2lnbmFsLCB0aW1lb3V0TXMpIHtcbiAgaWYgKGhhc1Byb2Nlc3NFeGl0ZWQoY2hpbGQpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjaGlsZCk7XG4gIH1cblxuICAvLyBjYXRjaCBhbnkgbmV3IG9uIGV4aXRcbiAgbGV0IG9uRXhpdCA9IG9uRXhpdE9uY2UoY2hpbGQpO1xuXG4gIGNoaWxkLmtpbGwoc2lnbmFsIHx8ICdTSUdLSUxMJyk7XG5cbiAgaWYgKHRpbWVvdXRNcyA9PT0gMCB8fCBpc0Zpbml0ZSh0aW1lb3V0TXMpKSB7XG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFoYXNQcm9jZXNzRXhpdGVkKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5raWxsKCdTSUdLSUxMJyk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dE1zKTtcblxuICAgIG9uRXhpdCA9IG9uRXhpdC50aGVuKCgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb25FeGl0O1xufVxuXG4vKlxuIGFzeW5jU2VuZFxuIFNhbWUgYXMgcHJvY2Vzcy5zZW5kIGJ1dCB3YWl0cyB1bnRpbCB0aGUgc2VuZCBpcyBjb21wbGV0ZVxuIHRoZSBhc3luYyB2ZXJzaW9uIGlzIHVzZWQgYmVsb3cgYmVjYXVzZSBvdGhlcndpc2VcbiB0aGUgdGVybWluYXRpb24gaGFuZGxlciBtYXkgZXhpdCBiZWZvcmUgdGhlIHBhcmVudFxuIHByb2Nlc3MgaGFzIHJlY2l2ZWQgdGhlIG1lc3NhZ2VzIGl0IHJlcXVpcmVzXG4gKi9cblxuY29uc3QgYXN5bmNTZW5kID0gKHByb2MsIG1zZykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHByb2Muc2VuZChtc2csIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBraWxsQXN5bmMsXG4gIGFzeW5jU2VuZFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/process/utils.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/queue.js":
/*!********************************************!*\
  !*** ../../node_modules/bull/lib/queue.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\nconst Redis = __webpack_require__(/*! ioredis */ \"(action-browser)/../../node_modules/ioredis/built/index.js\");\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\n\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../../node_modules/lodash/lodash.js\");\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst Job = __webpack_require__(/*! ./job */ \"(action-browser)/../../node_modules/bull/lib/job.js\");\nconst scripts = __webpack_require__(/*! ./scripts */ \"(action-browser)/../../node_modules/bull/lib/scripts.js\");\nconst errors = __webpack_require__(/*! ./errors */ \"(action-browser)/../../node_modules/bull/lib/errors.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(action-browser)/../../node_modules/bull/lib/utils.js\");\n\nconst TimerManager = __webpack_require__(/*! ./timer-manager */ \"(action-browser)/../../node_modules/bull/lib/timer-manager.js\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst { pTimeout } = __webpack_require__(/*! ./p-timeout */ \"(action-browser)/../../node_modules/bull/lib/p-timeout.js\");\nconst semver = __webpack_require__(/*! semver */ \"(action-browser)/../../node_modules/semver/index.js\");\nconst debuglog = (__webpack_require__(/*! util */ \"util\").debuglog)('bull');\nconst uuid = __webpack_require__(/*! uuid */ \"(action-browser)/../../node_modules/uuid/dist/esm-node/index.js\");\n\nconst commands = __webpack_require__(/*! ./scripts/ */ \"(action-browser)/../../node_modules/bull/lib/scripts/index.js\");\n\n/**\n  Gets or creates a new Queue with the given name.\n\n  The Queue keeps 6 data structures:\n    - wait (list)\n    - active (list)\n    - delayed (zset)\n    - priority (zset)\n    - completed (zset)\n    - failed (zset)\n\n        --> priorities      -- > completed\n       /     |            /\n    job -> wait -> active\n       \\     ^            \\\n        v    |             -- > failed\n        delayed\n*/\n\n/**\n  Delayed jobs are jobs that cannot be executed until a certain time in\n  ms has passed since they were added to the queue.\n  The mechanism is simple, a delayedTimestamp variable holds the next\n  known timestamp that is on the delayed set (or MAX_TIMEOUT_MS if none).\n\n  When the current job has finalized the variable is checked, if\n  no delayed job has to be executed yet a setTimeout is set so that a\n  delayed job is processed after timing out.\n*/\nconst MINIMUM_REDIS_VERSION = '2.8.18';\n\n/*\n  interface QueueOptions {\n    prefix?: string = 'bull',\n    limiter?: RateLimiter,\n    redis : RedisOpts, // ioredis defaults,\n    createClient?: (type: enum('client', 'subscriber'), redisOpts?: RedisOpts) => redisClient,\n    defaultJobOptions?: JobOptions,\n\n    // Advanced settings\n    settings?: QueueSettings {\n      lockDuration?: number = 30000,\n      lockRenewTime?: number = lockDuration / 2,\n      stalledInterval?: number = 30000,\n      maxStalledCount?: number = 1, // The maximum number of times a job can be recovered from the 'stalled' state\n      guardInterval?: number = 5000,\n      retryProcessDelay?: number = 5000,\n      drainDelay?: number = 5\n      isSharedChildPool?: boolean = false\n    }\n  }\n\n  interface RateLimiter {\n    max: number,      // Number of jobs\n    duration: number, // per duration milliseconds\n  }\n*/\n\n// Queue(name: string, url?, opts?)\nconst Queue = function Queue(name, url, opts) {\n  if (!(this instanceof Queue)) {\n    return new Queue(name, url, opts);\n  }\n\n  if (_.isString(url)) {\n    const clonedOpts = _.cloneDeep(opts || {});\n    opts = {\n      ...clonedOpts,\n      redis: {\n        ...redisOptsFromUrl(url),\n        ...clonedOpts.redis\n      }\n    };\n  } else {\n    opts = _.cloneDeep(url || {});\n  }\n\n  if (!_.isObject(opts)) {\n    throw TypeError('Options must be a valid object');\n  }\n\n  if (opts.limiter) {\n    if (opts.limiter.max && opts.limiter.duration) {\n      this.limiter = opts.limiter;\n    } else {\n      throw new TypeError('Limiter requires `max` and `duration` options');\n    }\n  }\n\n  if (opts.defaultJobOptions) {\n    this.defaultJobOptions = opts.defaultJobOptions;\n  }\n\n  this.name = name;\n  this.token = uuid.v4();\n\n  opts.redis = {\n    enableReadyCheck: false,\n    ...(_.isString(opts.redis)\n      ? { ...redisOptsFromUrl(opts.redis) }\n      : opts.redis)\n  };\n\n  _.defaults(opts.redis, {\n    port: 6379,\n    host: '127.0.0.1',\n    db: opts.redis.db || opts.redis.DB,\n    retryStrategy: function(times) {\n      return Math.min(Math.exp(times), 20000);\n    }\n  });\n\n  this.keyPrefix = opts.redis.keyPrefix || opts.prefix || 'bull';\n\n  //\n  // We cannot use ioredis keyPrefix feature since we\n  // create keys dynamically in lua scripts.\n  //\n  delete opts.redis.keyPrefix;\n\n  this.clients = [];\n\n  const loadCommands = (providedScripts, client) => {\n    const finalScripts = providedScripts || scripts;\n    for (const property in finalScripts) {\n      // Only define the command if not already defined\n      if (!client[finalScripts[property].name]) {\n        client.defineCommand(finalScripts[property].name, {\n          numberOfKeys: finalScripts[property].keys,\n          lua: finalScripts[property].content\n        });\n      }\n    }\n  };\n\n  const lazyClient = redisClientGetter(this, opts, (type, client) => {\n    // bubble up Redis error events\n    const handler = this.emit.bind(this, 'error');\n    client.on('error', handler);\n    this.once('close', () => client.removeListener('error', handler));\n\n    if (type === 'client') {\n      this._initializing = (async () => loadCommands(commands, client))().then(\n        () => {\n          debuglog(name + ' queue ready');\n        },\n        err => {\n          this.emit('error', new Error('Error initializing Lua scripts'));\n          throw err;\n        }\n      );\n\n      this._initializing.catch((/*err*/) => {});\n    }\n  });\n\n  Object.defineProperties(this, {\n    //\n    // Queue client (used to add jobs, pause queues, etc);\n    //\n    client: {\n      get: lazyClient('client')\n    },\n    //\n    // Event subscriber client (receive messages from other instance of the queue)\n    //\n    eclient: {\n      get: lazyClient('subscriber')\n    },\n    bclient: {\n      get: lazyClient('bclient')\n    }\n  });\n\n  if (opts.skipVersionCheck !== true) {\n    getRedisVersion(this.client)\n      .then(version => {\n        if (semver.lt(version, MINIMUM_REDIS_VERSION)) {\n          this.emit(\n            'error',\n            new Error(\n              'Redis version needs to be greater than ' +\n                MINIMUM_REDIS_VERSION +\n                '. Current: ' +\n                version\n            )\n          );\n        }\n      })\n      .catch((/*err*/) => {\n        // Ignore this error.\n      });\n  }\n\n  this.handlers = {};\n  this.delayTimer;\n  this.processing = [];\n  this.retrieving = 0;\n  this.drained = true;\n\n  this.settings = _.defaults(opts.settings, {\n    lockDuration: 30000,\n    stalledInterval: 30000,\n    maxStalledCount: 1,\n    guardInterval: 5000,\n    retryProcessDelay: 5000,\n    drainDelay: 5,\n    backoffStrategies: {},\n    isSharedChildPool: false\n  });\n\n  this.metrics = opts.metrics;\n\n  this.settings.lockRenewTime =\n    this.settings.lockRenewTime || this.settings.lockDuration / 2;\n\n  this.on('error', () => {\n    // Dummy handler to avoid process to exit with an unhandled exception.\n  });\n\n  // keeps track of active timers. used by close() to\n  // ensure that disconnect() is deferred until all\n  // scheduled redis commands have been executed\n  this.timers = new TimerManager();\n\n  // Bind these methods to avoid constant rebinding and/or creating closures\n  // in processJobs etc.\n  this.moveUnlockedJobsToWait = this.moveUnlockedJobsToWait.bind(this);\n  this.processJob = this.processJob.bind(this);\n  this.getJobFromId = Job.fromId.bind(null, this);\n\n  const keys = {};\n  _.each(\n    [\n      '',\n      'active',\n      'wait',\n      'waiting',\n      'paused',\n      'resumed',\n      'meta-paused',\n      'active',\n      'id',\n      'delayed',\n      'priority',\n      'stalled-check',\n      'completed',\n      'failed',\n      'stalled',\n      'repeat',\n      'limiter',\n      'drained',\n      'duplicated',\n      'progress',\n      'de' // debounce key\n    ],\n    key => {\n      keys[key] = this.toKey(key);\n    }\n  );\n  this.keys = keys;\n};\n\nfunction redisClientGetter(queue, options, initCallback) {\n  const createClient = _.isFunction(options.createClient)\n    ? options.createClient\n    : function(type, config) {\n        if (['bclient', 'subscriber'].includes(type)) {\n          return new Redis({ ...config, maxRetriesPerRequest: null });\n        } else {\n          return new Redis(config);\n        }\n      };\n\n  const connections = {};\n\n  return function(type) {\n    return function() {\n      // Memoized connection\n      if (connections[type] != null) {\n        return connections[type];\n      }\n      const clientOptions = _.assign({}, options.redis);\n\n      const client = (connections[type] = createClient(type, clientOptions));\n\n      const opts = client.options.redisOptions || client.options;\n\n      if (\n        ['bclient', 'subscriber'].includes(type) &&\n        (opts.enableReadyCheck || opts.maxRetriesPerRequest)\n      ) {\n        throw new Error(errors.Messages.MISSING_REDIS_OPTS);\n      }\n\n      // Since connections are lazily initialized, we can't check queue.client\n      // without initializing a connection. So expose a boolean we can safely\n      // query.\n      queue[type + 'Initialized'] = true;\n\n      if (!options.createClient) {\n        queue.clients.push(client);\n      }\n      return initCallback(type, client), client;\n    };\n  };\n}\n\nfunction redisOptsFromUrl(urlString) {\n  let redisOpts = {};\n  try {\n    const redisUrl = url.parse(urlString, true, true);\n    redisOpts.port = parseInt(redisUrl.port || '6379', 10);\n    redisOpts.host = redisUrl.hostname;\n    redisOpts.db = redisUrl.pathname ? redisUrl.pathname.split('/')[1] : 0;\n    if (redisUrl.auth) {\n      const columnIndex = redisUrl.auth.indexOf(':');\n      redisOpts.password = redisUrl.auth.slice(columnIndex + 1);\n      if (columnIndex > 0) {\n        redisOpts.username = redisUrl.auth.slice(0, columnIndex);\n      }\n    }\n\n    if (redisUrl.query) {\n      redisOpts = { ...redisOpts, ...redisUrl.query };\n    }\n  } catch (e) {\n    throw new Error(e.message);\n  }\n  return redisOpts;\n}\n\nutil.inherits(Queue, EventEmitter);\n\n//\n// Extend Queue with \"aspects\"\n//\n__webpack_require__(/*! ./getters */ \"(action-browser)/../../node_modules/bull/lib/getters.js\")(Queue);\n__webpack_require__(/*! ./worker */ \"(action-browser)/../../node_modules/bull/lib/worker.js\")(Queue);\n__webpack_require__(/*! ./repeatable */ \"(action-browser)/../../node_modules/bull/lib/repeatable.js\")(Queue);\n\n// --\nQueue.prototype.off = Queue.prototype.removeListener;\n\nconst _on = Queue.prototype.on;\n\nQueue.prototype.on = function(eventName) {\n  this._registerEvent(eventName);\n  return _on.apply(this, arguments);\n};\n\nconst _once = Queue.prototype.once;\n\nQueue.prototype.once = function(eventName) {\n  this._registerEvent(eventName);\n  return _once.apply(this, arguments);\n};\n\nQueue.prototype._initProcess = function() {\n  if (!this._initializingProcess) {\n    //\n    // Only setup listeners if .on/.addEventListener called, or process function defined.\n    //\n    this.delayedTimestamp = Number.MAX_VALUE;\n    this._initializingProcess = this.isReady()\n      .then(() => {\n        return this._registerEvent('delayed');\n      })\n      .then(() => {\n        return this.updateDelayTimer();\n      });\n\n    this.errorRetryTimer = {};\n  }\n\n  return this._initializingProcess;\n};\n\nQueue.prototype._setupQueueEventListeners = function() {\n  /*\n    if(eventName !== 'cleaned' && eventName !== 'error'){\n      args[0] = Job.fromJSON(this, args[0]);\n    }\n  */\n\n  const activeKey = this.keys.active;\n  const stalledKey = this.keys.stalled;\n  const progressKey = this.keys.progress;\n  const delayedKey = this.keys.delayed;\n  const pausedKey = this.keys.paused;\n  const resumedKey = this.keys.resumed;\n  const waitingKey = this.keys.waiting;\n  const completedKey = this.keys.completed;\n  const failedKey = this.keys.failed;\n  const drainedKey = this.keys.drained;\n  const duplicatedKey = this.keys.duplicated;\n  const debouncedKey = this.keys.de + 'bounced';\n\n  const pmessageHandler = (pattern, channel, message) => {\n    const keyAndToken = channel.split('@');\n    const key = keyAndToken[0];\n    const token = keyAndToken[1];\n    switch (key) {\n      case activeKey:\n        utils.emitSafe(this, 'global:active', message, 'waiting');\n        break;\n      case waitingKey:\n        if (this.token === token) {\n          utils.emitSafe(this, 'waiting', message, null);\n        }\n        token && utils.emitSafe(this, 'global:waiting', message, null);\n        break;\n      case stalledKey:\n        if (this.token === token) {\n          utils.emitSafe(this, 'stalled', message);\n        }\n        utils.emitSafe(this, 'global:stalled', message);\n        break;\n      case duplicatedKey:\n        if (this.token === token) {\n          utils.emitSafe(this, 'duplicated', message);\n        }\n        utils.emitSafe(this, 'global:duplicated', message);\n        break;\n      case debouncedKey:\n        if (this.token === token) {\n          utils.emitSafe(this, 'debounced', message);\n        }\n        utils.emitSafe(this, 'global:debounced', message);\n        break;\n    }\n  };\n\n  const messageHandler = (channel, message) => {\n    const key = channel.split('@')[0];\n    switch (key) {\n      case progressKey: {\n        // New way to send progress message data\n        try {\n          const { progress, jobId } = JSON.parse(message);\n          utils.emitSafe(this, 'global:progress', jobId, progress);\n        } catch (err) {\n          // If we fail we should try to parse the data using the deprecated method\n          const commaPos = message.indexOf(',');\n          const jobId = message.substring(0, commaPos);\n          const progress = message.substring(commaPos + 1);\n          utils.emitSafe(this, 'global:progress', jobId, JSON.parse(progress));\n        }\n        break;\n      }\n      case delayedKey: {\n        const newDelayedTimestamp = _.ceil(message);\n        if (newDelayedTimestamp < this.delayedTimestamp) {\n          // The new delayed timestamp is before the currently newest known delayed timestamp\n          // Assume this is the new delayed timestamp and call `updateDelayTimer()` to process any delayed jobs\n          // This will also update the `delayedTimestamp`\n          this.delayedTimestamp = newDelayedTimestamp;\n\n          this.updateDelayTimer();\n        }\n        break;\n      }\n      case pausedKey:\n      case resumedKey:\n        utils.emitSafe(this, 'global:' + message);\n        break;\n      case completedKey: {\n        const data = JSON.parse(message);\n        utils.emitSafe(\n          this,\n          'global:completed',\n          data.jobId,\n          data.val,\n          'active'\n        );\n        break;\n      }\n      case failedKey: {\n        const data = JSON.parse(message);\n        utils.emitSafe(this, 'global:failed', data.jobId, data.val, 'active');\n        break;\n      }\n      case drainedKey:\n        utils.emitSafe(this, 'global:drained');\n        break;\n    }\n  };\n\n  this.eclient.on('pmessage', pmessageHandler);\n  this.eclient.on('message', messageHandler);\n\n  this.once('close', () => {\n    this.eclient.removeListener('pmessage', pmessageHandler);\n    this.eclient.removeListener('message', messageHandler);\n  });\n};\n\nQueue.prototype._registerEvent = function(eventName) {\n  const internalEvents = ['waiting', 'delayed', 'duplicated', 'debounced'];\n\n  if (\n    eventName.startsWith('global:') ||\n    internalEvents.indexOf(eventName) !== -1\n  ) {\n    if (!this.registeredEvents) {\n      this._setupQueueEventListeners();\n      this.registeredEvents = this.registeredEvents || {};\n    }\n\n    const _eventName = eventName.replace('global:', '');\n\n    if (!this.registeredEvents[_eventName]) {\n      return utils\n        .isRedisReady(this.eclient)\n        .then(() => {\n          const channel = this.toKey(_eventName);\n          if (['active', 'waiting', 'stalled', 'duplicated', 'debounced'].indexOf(_eventName) !== -1) {\n            return (this.registeredEvents[_eventName] = this.eclient.psubscribe(\n              channel + '*'\n            ));\n          } else {\n            return (this.registeredEvents[_eventName] = this.eclient.subscribe(\n              channel\n            ));\n          }\n        })\n        .then(() => {\n          utils.emitSafe(this, 'registered:' + eventName);\n        });\n    } else {\n      return this.registeredEvents[_eventName];\n    }\n  }\n  return Promise.resolve();\n};\n\nQueue.ErrorMessages = errors.Messages;\n\nQueue.prototype.isReady = async function() {\n  await this._initializing;\n  return this;\n};\n\nasync function redisClientDisconnect(client) {\n  if (client.status !== 'end') {\n    let _resolve, _reject;\n    return new Promise((resolve, reject) => {\n      _resolve = resolve;\n      _reject = reject;\n      client.once('end', _resolve);\n\n      pTimeout(\n        client.quit().catch(err => {\n          if (err.message !== 'Connection is closed.') {\n            throw err;\n          }\n        }),\n        500\n      )\n        .catch(() => {\n          // Ignore timeout error\n        })\n        .finally(() => {\n          client.once('error', _reject);\n\n          client.disconnect();\n          if (['connecting', 'reconnecting'].includes(client.status)) {\n            resolve();\n          }\n        });\n    }).finally(() => {\n      client.removeListener('end', _resolve);\n      client.removeListener('error', _reject);\n    });\n  }\n}\n\nQueue.prototype.disconnect = async function() {\n  await Promise.all(\n    this.clients.map(client =>\n      client.blocked ? client.disconnect() : redisClientDisconnect(client)\n    )\n  );\n};\n\nQueue.prototype.removeJobs = function(pattern) {\n  return Job.remove(this, pattern);\n};\n\nQueue.prototype.close = function(doNotWaitJobs) {\n  let isReady = true;\n  if (this.closing) {\n    return this.closing;\n  }\n\n  return (this.closing = this.isReady()\n    .then(this._initializingProcess)\n    .catch(() => {\n      isReady = false;\n    })\n    .then(() => isReady && this.pause(true, doNotWaitJobs))\n    .catch(() => void 0) // Ignore possible error from pause\n    .finally(() => this._clearTimers())\n    .then(() => {\n      if (!this.childPool) {\n        return;\n      }\n      const cleanPromise = this.childPool.clean().catch(() => {\n        // Ignore this error and try to close anyway.\n      });\n      if (doNotWaitJobs) {\n        return;\n      }\n      return cleanPromise;\n    })\n    .then(\n      async () => this.disconnect(),\n      err => console.error(err)\n    )\n    .finally(() => {\n      this.closed = true;\n      utils.emitSafe(this, 'close');\n    }));\n};\n\nQueue.prototype._clearTimers = function() {\n  _.each(this.errorRetryTimer, timer => {\n    clearTimeout(timer);\n  });\n  clearTimeout(this.delayTimer);\n  clearInterval(this.guardianTimer);\n  clearInterval(this.moveUnlockedJobsToWaitInterval);\n  this.timers.clearAll();\n  return this.timers.whenIdle();\n};\n\n/**\n  Processes a job from the queue. The callback is called for every job that\n  is dequeued.\n\n  @method process\n*/\nQueue.prototype.process = function(name, concurrency, handler) {\n  switch (arguments.length) {\n    case 1:\n      handler = name;\n      concurrency = 1;\n      name = Job.DEFAULT_JOB_NAME;\n      break;\n    case 2: // (string, function) or (string, string) or (number, function) or (number, string)\n      handler = concurrency;\n      if (typeof name === 'string') {\n        concurrency = 1;\n      } else {\n        concurrency = name;\n        name = Job.DEFAULT_JOB_NAME;\n      }\n      break;\n  }\n\n  this.setHandler(name, handler);\n\n  return this._initProcess().then(() => {\n    return this.start(concurrency, name);\n  });\n};\n\nQueue.prototype.start = function(concurrency, name) {\n  return this.run(concurrency, name).catch(err => {\n    utils.emitSafe(this, 'error', err, 'error running queue');\n    throw err;\n  });\n};\n\nQueue.prototype.setHandler = function(name, handler) {\n  if (!handler) {\n    throw new Error('Cannot set an undefined handler');\n  }\n  if (this.handlers[name]) {\n    throw new Error('Cannot define the same handler twice ' + name);\n  }\n\n  this.setWorkerName();\n\n  if (typeof handler === 'string') {\n    const supportedFileTypes = ['.js', '.ts', '.flow', '.cjs'];\n    const processorFile =\n      handler +\n      (supportedFileTypes.includes(path.extname(handler)) ? '' : '.js');\n\n    if (!fs.existsSync(processorFile)) {\n      throw new Error('File ' + processorFile + ' does not exist');\n    }\n    const isSharedChildPool = this.settings.isSharedChildPool;\n    this.childPool =\n      this.childPool || __webpack_require__(/*! ./process/child-pool */ \"(action-browser)/../../node_modules/bull/lib/process/child-pool.js\")(isSharedChildPool);\n\n    const sandbox = __webpack_require__(/*! ./process/sandbox */ \"(action-browser)/../../node_modules/bull/lib/process/sandbox.js\");\n    this.handlers[name] = sandbox(handler, this.childPool).bind(this);\n  } else {\n    handler = handler.bind(this);\n\n    if (handler.length > 1) {\n      this.handlers[name] = promisify(handler);\n    } else {\n      this.handlers[name] = function() {\n        try {\n          return Promise.resolve(handler.apply(null, arguments));\n        } catch (err) {\n          return Promise.reject(err);\n        }\n      };\n    }\n  }\n};\n\n/**\ninterface JobOptions\n{\n  attempts: number;\n\n  repeat: {\n    tz?: string,\n    endDate?: Date | string | number\n  },\n  preventParsingData: boolean;\n}\n*/\n\n/**\n  Adds a job to the queue.\n  @method add\n  @param data: {} Custom data to store for this job. Should be JSON serializable.\n  @param opts: JobOptions Options for this job.\n*/\nQueue.prototype.add = function(name, data, opts) {\n  if (typeof name !== 'string') {\n    opts = data;\n    data = name;\n    name = Job.DEFAULT_JOB_NAME;\n  }\n  opts = _.cloneDeep({ ...this.defaultJobOptions, ...opts });\n\n  opts.jobId = jobIdForGroup(this.limiter, opts, data);\n\n  if (opts.repeat) {\n    return this.isReady().then(() => {\n      return this.nextRepeatableJob(name, data, opts, true);\n    });\n  } else {\n    return Job.create(this, name, data, opts);\n  }\n};\n\n/**\n * Retry all the failed jobs.\n *\n * @param opts.count - number to limit how many jobs will be moved to wait status per iteration\n * @returns\n */\nQueue.prototype.retryJobs = async function(opts = {}) {\n  let cursor = 0;\n  do {\n    cursor = await scripts.retryJobs(this, opts.count);\n  } while (cursor);\n};\n\n  /**\n   * Removes a debounce key.\n   *\n   * @param id - identifier\n   */\n  Queue.prototype.removeDebounceKey = (id) => {\n    return this.client.del(`${this.keys.de}:${id}`);\n  }\n\n/**\n  Adds an array of jobs to the queue.\n  @method add\n  @param jobs: [] The array of jobs to add to the queue. Each job is defined by 3 properties, 'name', 'data' and 'opts'. They follow the same signature as 'Queue.add'.\n*/\nQueue.prototype.addBulk = function(jobs) {\n  const decoratedJobs = jobs.map(job => {\n    const jobId = jobIdForGroup(this.limiter, job.opts, job.data);\n    return {\n      ...job,\n      name: typeof job.name !== 'string' ? Job.DEFAULT_JOB_NAME : job.name,\n      opts: {\n        ...this.defaultJobOptions,\n        ...job.opts,\n        jobId\n      }\n    };\n  });\n  return Job.createBulk(this, decoratedJobs);\n};\n/**\n  Empties the queue.\n\n  Returns a promise that is resolved after the operation has been completed.\n  Note that if some other process is adding jobs at the same time as emptying,\n  the queues may not be really empty after this method has executed completely.\n  Also, if the method does error between emptying the lists and removing all the\n  jobs, there will be zombie jobs left in redis.\n\n  TODO: Use EVAL to make this operation fully atomic.\n*/\nQueue.prototype.empty = function() {\n  const queueKeys = this.keys;\n\n  let multi = this.multi();\n\n  multi.lrange(queueKeys.wait, 0, -1);\n  multi.lrange(queueKeys.paused, 0, -1);\n  multi.keys(this.toKey('*:limited'));\n  multi.del(\n    queueKeys.wait,\n    queueKeys.paused,\n    queueKeys['meta-paused'],\n    queueKeys.delayed,\n    queueKeys.priority,\n    queueKeys.limiter,\n    `${queueKeys.limiter}:index`\n  );\n\n  return multi.exec().then(res => {\n    let [waiting, paused, limited] = res;\n\n    waiting = waiting[1];\n    paused = paused[1];\n    limited = limited[1];\n\n    const jobKeys = paused.concat(waiting).map(this.toKey, this);\n\n    if (jobKeys.length || limited.length) {\n      multi = this.multi();\n\n      for (let i = 0; i < jobKeys.length; i += 10000) {\n        multi.del.apply(multi, jobKeys.slice(i, i + 10000));\n      }\n\n      for (let i = 0; i < limited.length; i += 10000) {\n        multi.del.apply(multi, limited.slice(i, i + 10000));\n      }\n\n      return multi.exec();\n    }\n  });\n};\n\n/**\n  Pauses the processing of this queue, locally if true passed, otherwise globally.\n\n  For global pause, we use an atomic RENAME operation on the wait queue. Since\n  we have blocking calls with BRPOPLPUSH on the wait queue, as long as the queue\n  is renamed to 'paused', no new jobs will be processed (the current ones\n  will run until finalized).\n\n  Adding jobs requires a LUA script to check first if the paused list exist\n  and in that case it will add it there instead of the wait list.\n*/\nQueue.prototype.pause = function(isLocal, doNotWaitActive) {\n  return this.isReady()\n    .then(() => {\n      if (isLocal) {\n        if (!this.paused) {\n          this.paused = new Promise(resolve => {\n            this.resumeLocal = function() {\n              this.paused = null; // Allow pause to be checked externally for paused state.\n              resolve();\n            };\n          });\n        }\n\n        if (!this.bclientInitialized) {\n          // bclient not yet initialized, so no jobs to wait for\n          return;\n        }\n\n        if (doNotWaitActive) {\n          // Force reconnection of blocking connection to abort blocking redis call immediately.\n          return redisClientDisconnect(this.bclient).then(() =>\n            this.bclient.connect()\n          );\n        }\n        return this.whenCurrentJobsFinished();\n      } else {\n        return scripts.pause(this, true);\n      }\n    })\n    .then(() => {\n      return utils.emitSafe(this, 'paused');\n    });\n};\n\nQueue.prototype.resume = function(isLocal /* Optional */) {\n  return this.isReady()\n    .then(() => {\n      if (isLocal) {\n        if (this.resumeLocal) {\n          this.resumeLocal();\n        }\n      } else {\n        return scripts.pause(this, false);\n      }\n    })\n    .then(() => {\n      utils.emitSafe(this, 'resumed');\n    });\n};\n\nQueue.prototype.isPaused = async function(isLocal) {\n  if (isLocal) {\n    return !!this.paused;\n  } else {\n    await this.isReady();\n    const multi = this.multi();\n\n    multi.exists(this.keys['meta-paused']);\n\n    // For forward compatibility with BullMQ.\n    multi.hexists(this.toKey('meta'), 'paused');\n\n    const [[, isPaused], [, isPausedNew]] = await multi.exec();\n\n    return !!(isPaused || isPausedNew);\n  }\n};\n\nQueue.prototype.run = function(concurrency, handlerName) {\n  if (!Number.isInteger(concurrency)) {\n    throw new Error('Cannot set Float as concurrency');\n  }\n  const promises = [];\n\n  return this.isReady()\n    .then(() => {\n      return this.moveUnlockedJobsToWait();\n    })\n    .then(() => {\n      return utils.isRedisReady(this.bclient);\n    })\n    .then(() => {\n      while (concurrency--) {\n        promises.push(\n          new Promise(resolve => {\n            this.processJobs(`${handlerName}:${concurrency}`, resolve);\n          })\n        );\n      }\n\n      this.startMoveUnlockedJobsToWait();\n\n      return Promise.all(promises);\n    });\n};\n\n// ---------------------------------------------------------------------\n// Private methods\n// ---------------------------------------------------------------------\n\n/**\n  This function updates the delay timer, which is a timer that timeouts\n  at the next known delayed job.\n*/\nQueue.prototype.updateDelayTimer = function() {\n  if (this.closing) {\n    return Promise.resolve();\n  }\n\n  return scripts\n    .updateDelaySet(this, Date.now())\n    .then(nextTimestamp => {\n      this.delayedTimestamp = nextTimestamp\n        ? nextTimestamp / 4096\n        : Number.MAX_VALUE;\n\n      // Clear any existing update delay timer\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n      }\n\n      // Delay for the next update of delay set\n      const delay = _.min([\n        this.delayedTimestamp - Date.now(),\n        this.settings.guardInterval\n      ]);\n\n      // Schedule next processing of the delayed jobs\n      if (delay <= 0) {\n        // Next set of jobs are due right now, process them also\n        this.updateDelayTimer();\n      } else {\n        // Update the delay set when the next job is due\n        // or the next guard time\n        this.delayTimer = setTimeout(() => this.updateDelayTimer(), delay);\n      }\n\n      // Silence warnings about promise created but not returned.\n      // This isn't an issue since we emit errors.\n      // See http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it\n      return null;\n    })\n    .catch(err => {\n      utils.emitSafe(this, 'error', err, 'Error updating the delay timer');\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n      }\n\n      this.delayTimer = setTimeout(\n        () => this.updateDelayTimer(),\n        this.settings.guardInterval\n      );\n    });\n};\n\n/**\n * Process jobs that have been added to the active list but are not being\n * processed properly. This can happen due to a process crash in the middle\n * of processing a job, leaving it in 'active' but without a job lock.\n */\nQueue.prototype.moveUnlockedJobsToWait = function() {\n  if (this.closing) {\n    return Promise.resolve();\n  }\n\n  return scripts\n    .moveUnlockedJobsToWait(this)\n    .then(([failed, stalled]) => {\n      const handleFailedJobs = failed.map(jobId => {\n        return this.getJobFromId(jobId).then(job => {\n          utils.emitSafe(\n            this,\n            'failed',\n            job,\n            new Error('job stalled more than allowable limit'),\n            'active'\n          );\n          return null;\n        });\n      });\n      const handleStalledJobs = stalled.map(jobId => {\n        return this.getJobFromId(jobId).then(job => {\n          // Do not emit the event if the job was completed by another worker\n          if (job !== null) {\n            utils.emitSafe(this, 'stalled', job);\n          }\n          return null;\n        });\n      });\n      return Promise.all(handleFailedJobs.concat(handleStalledJobs));\n    })\n    .catch(err => {\n      utils.emitSafe(\n        this,\n        'error',\n        err,\n        'Failed to handle unlocked job in active'\n      );\n    });\n};\n\nQueue.prototype.startMoveUnlockedJobsToWait = function() {\n  clearInterval(this.moveUnlockedJobsToWaitInterval);\n  if (this.settings.stalledInterval > 0 && !this.closing) {\n    this.moveUnlockedJobsToWaitInterval = setInterval(\n      this.moveUnlockedJobsToWait,\n      this.settings.stalledInterval\n    );\n  }\n};\n\n/*\n  Process jobs. Note last argument 'job' is optional.\n*/\nQueue.prototype.processJobs = function(index, resolve, job) {\n  const processJobs = this.processJobs.bind(this, index, resolve);\n  process.nextTick(() => {\n    this._processJobOnNextTick(processJobs, index, resolve, job);\n  });\n};\n\nQueue.prototype._processJobOnNextTick = function(\n  processJobs,\n  index,\n  resolve,\n  job\n) {\n  if (!this.closing) {\n    (this.paused || Promise.resolve())\n      .then(() => {\n        const gettingNextJob = job ? Promise.resolve(job) : this.getNextJob();\n\n        return (this.processing[index] = gettingNextJob\n          .then(this.processJob)\n          .then(processJobs, err => {\n            if (!(this.closing && err.message === 'Connection is closed.')) {\n              utils.emitSafe(this, 'error', err, 'Error processing job');\n\n              //\n              // Wait before trying to process again.\n              //\n              clearTimeout(this.errorRetryTimer[index]);\n              this.errorRetryTimer[index] = setTimeout(() => {\n                processJobs();\n              }, this.settings.retryProcessDelay);\n            }\n            return null;\n          }));\n      })\n      .catch(err => {\n        utils.emitSafe(this, 'error', err, 'Error processing job');\n      });\n  } else {\n    resolve(this.closing);\n  }\n};\n\nQueue.prototype.processJob = function(job, notFetch = false) {\n  let lockRenewId;\n  let timerStopped = false;\n\n  if (!job) {\n    return Promise.resolve();\n  }\n\n  //\n  // There are two cases to take into consideration regarding locks.\n  // 1) The lock renewer fails to renew a lock, this should make this job\n  // unable to complete, since some other worker is also working on it.\n  // 2) The lock renewer is called more seldom than the check for stalled\n  // jobs, so we can assume the job has been stalled and is already being processed\n  // by another worker. See #308\n  //\n  const lockExtender = () => {\n    lockRenewId = this.timers.set(\n      'lockExtender',\n      this.settings.lockRenewTime,\n      () => {\n        scripts\n          .extendLock(this, job.id, this.settings.lockDuration)\n          .then(lock => {\n            if (lock && !timerStopped) {\n              lockExtender();\n            }\n          })\n          .catch(err => {\n            utils.emitSafe(this, 'lock-extension-failed', job, err);\n          });\n      }\n    );\n  };\n\n  const timeoutMs = job.opts.timeout;\n\n  const stopTimer = () => {\n    timerStopped = true;\n    this.timers.clear(lockRenewId);\n  };\n\n  const handleCompleted = result => {\n    return job.moveToCompleted(result, undefined, notFetch).then(jobData => {\n      utils.emitSafe(this, 'completed', job, result, 'active');\n      return jobData ? this.nextJobFromJobData(jobData[0], jobData[1]) : null;\n    });\n  };\n\n  const handleFailed = err => {\n    const error = err;\n\n    return job.moveToFailed(err).then(jobData => {\n      utils.emitSafe(this, 'failed', job, error, 'active');\n      return jobData ? this.nextJobFromJobData(jobData[0], jobData[1]) : null;\n    });\n  };\n\n  lockExtender();\n  const handler = this.handlers[job.name] || this.handlers['*'];\n\n  if (!handler) {\n    return handleFailed(\n      new Error('Missing process handler for job type ' + job.name)\n    );\n  } else {\n    let jobPromise = handler(job);\n\n    if (timeoutMs) {\n      jobPromise = pTimeout(jobPromise, timeoutMs);\n    }\n\n    // Local event with jobPromise so that we can cancel job.\n    utils.emitSafe(this, 'active', job, jobPromise, 'waiting');\n\n    return jobPromise\n      .then(handleCompleted)\n      .catch(handleFailed)\n      .finally(() => {\n        stopTimer();\n      });\n  }\n};\n\nQueue.prototype.multi = function() {\n  return this.client.multi();\n};\n\n/**\n  Returns a promise that resolves to the next job in queue.\n*/\nQueue.prototype.getNextJob = async function() {\n  if (this.closing) {\n    return Promise.resolve();\n  }\n\n  if (this.drained) {\n    //\n    // Waiting for new jobs to arrive\n    //\n    try {\n      this.bclient.blocked = true;\n      const jobId = await this.bclient.brpoplpush(\n        this.keys.wait,\n        this.keys.active,\n        this.settings.drainDelay\n      );\n      this.bclient.blocked = false;\n\n      if (jobId) {\n        return this.moveToActive(jobId);\n      }\n    } catch (err) {\n      // Swallow error if locally paused since we did force a disconnection\n      if (!(this.paused && err.message === 'Connection is closed.')) {\n        throw err;\n      }\n    }\n  } else {\n    return this.moveToActive();\n  }\n};\n\nQueue.prototype.moveToActive = async function(jobId) {\n  // For manual retrieving jobs we need to wait for the queue to be ready.\n  await this.isReady();\n\n  return scripts.moveToActive(this, jobId).then(([jobData, jobId]) => {\n    return this.nextJobFromJobData(jobData, jobId);\n  });\n};\n\nQueue.prototype.nextJobFromJobData = function(jobData, jobId) {\n  if (jobData) {\n    this.drained = false;\n    const job = Job.fromJSON(this, jobData, jobId);\n    if (job.opts.repeat) {\n      return this.nextRepeatableJob(job.name, job.data, job.opts).then(() => {\n        return job;\n      });\n    }\n    return job;\n  } else {\n    this.drained = true;\n    utils.emitSafe(this, 'drained');\n    return null;\n  }\n};\n\nQueue.prototype.retryJob = function(job) {\n  return job.retry();\n};\n\nQueue.prototype.toKey = function(queueType) {\n  return [this.keyPrefix, this.name, queueType].join(':');\n};\n\n/*@function clean\n *\n * Cleans jobs from a queue. Similar to remove but keeps jobs within a certain\n * grace period.\n *\n * @param {int} grace - The grace period\n * @param {string} [type=completed] - The type of job to clean. Possible values are completed, wait, active, paused, delayed, failed. Defaults to completed.\n * @param {int} The max number of jobs to clean\n */\nQueue.prototype.clean = function(grace, type, limit) {\n  return this.isReady().then(() => {\n    if (grace === undefined || grace === null) {\n      throw new Error('You must define a grace period.');\n    }\n\n    if (!type) {\n      type = 'completed';\n    }\n\n    if (\n      _.indexOf(\n        ['completed', 'wait', 'active', 'paused', 'delayed', 'failed'],\n        type\n      ) === -1\n    ) {\n      throw new Error('Cannot clean unknown queue type ' + type);\n    }\n\n    return scripts\n      .cleanJobsInSet(this, type, Date.now() - grace, limit)\n      .then(jobs => {\n        utils.emitSafe(this, 'cleaned', jobs, type);\n        return jobs;\n      })\n      .catch(err => {\n        utils.emitSafe(this, 'error', err);\n        throw err;\n      });\n  });\n};\n\n/* @method obliterate\n *\n * Completely destroys the queue and all of its contents irreversibly.\n * This method will the *pause* the queue and requires that there are no\n * active jobs. It is possible to bypass this requirement, i.e. not\n * having active jobs using the \"force\" option.\n *\n * Note: This operation requires to iterate on all the jobs stored in the queue\n * and can be slow for very large queues.\n *\n * @param { { force: boolean, count: number }} opts. Use force = true to force obliteration even\n * with active jobs in the queue.  Use count with the maximun number of deleted keys per iteration,\n * 1000 is the default.\n */\nQueue.prototype.obliterate = async function(opts) {\n  await this.pause();\n\n  let cursor = 0;\n  do {\n    cursor = await scripts.obliterate(this, {\n      force: false,\n      count: 1000,\n      ...opts\n    });\n  } while (cursor);\n};\n\n/**\n * Returns a promise that resolves when active jobs are finished\n *\n * @returns {Promise}\n */\nQueue.prototype.whenCurrentJobsFinished = function() {\n  if (!this.bclientInitialized) {\n    // bclient not yet initialized, so no jobs to wait for\n    return Promise.resolve();\n  }\n\n  //\n  // Force reconnection of blocking connection to abort blocking redis call immediately.\n  //\n  const forcedReconnection = redisClientDisconnect(this.bclient).then(() => {\n    return this.bclient.connect();\n  });\n\n  return Promise.all(Object.values(this.processing)).then(\n    () => forcedReconnection\n  );\n};\n\n//\n// Private local functions\n//\n\nfunction getRedisVersion(client) {\n  return client.info().then(doc => {\n    const prefix = 'redis_version:';\n    const lines = doc.split('\\r\\n');\n    for (let i = 0; i < lines.length; i++) {\n      if (lines[i].indexOf(prefix) === 0) {\n        return lines[i].substr(prefix.length);\n      }\n    }\n  });\n}\n\nfunction jobIdForGroup(limiter, opts, data) {\n  const jobId = opts && opts.jobId;\n  const groupKey = _.get(limiter, 'groupKey');\n  if (groupKey) {\n    return `${jobId || uuid.v4()}:${_.get(data, groupKey)}`;\n  }\n  return jobId;\n}\n\nmodule.exports = Queue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcXVldWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLDJFQUFTO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLHNCQUFROztBQUVyQyxVQUFVLG1CQUFPLENBQUMsb0VBQVE7O0FBRTFCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxrRUFBTztBQUMzQixnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQyxlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsY0FBYyxtQkFBTyxDQUFDLHNFQUFTOztBQUUvQixxQkFBcUIsbUJBQU8sQ0FBQyxzRkFBaUI7QUFDOUMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwQyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLDhFQUFhO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyxtRUFBUTtBQUMvQixpQkFBaUIsa0RBQXdCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyw2RUFBTTs7QUFFM0IsaUJBQWlCLG1CQUFPLENBQUMsaUZBQVk7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QztBQUNwRSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQU8sQ0FBQywwRUFBVztBQUNuQixtQkFBTyxDQUFDLHdFQUFVO0FBQ2xCLG1CQUFPLENBQUMsZ0ZBQWM7O0FBRXRCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsZ0dBQXNCOztBQUV0RCxvQkFBb0IsbUJBQU8sQ0FBQywwRkFBbUI7QUFDL0M7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0NBQW9DOztBQUUzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhLEdBQUcsR0FBRztBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGtCQUFrQjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTs7QUFFQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVksR0FBRyxZQUFZO0FBQzNELFdBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQ0FBaUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CLEdBQUcsc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcXVldWUuanM/NTA2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFJlZGlzID0gcmVxdWlyZSgnaW9yZWRpcycpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IEpvYiA9IHJlcXVpcmUoJy4vam9iJyk7XG5jb25zdCBzY3JpcHRzID0gcmVxdWlyZSgnLi9zY3JpcHRzJyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmNvbnN0IFRpbWVyTWFuYWdlciA9IHJlcXVpcmUoJy4vdGltZXItbWFuYWdlcicpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHsgcFRpbWVvdXQgfSA9IHJlcXVpcmUoJy4vcC10aW1lb3V0Jyk7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcbmNvbnN0IGRlYnVnbG9nID0gcmVxdWlyZSgndXRpbCcpLmRlYnVnbG9nKCdidWxsJyk7XG5jb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xuXG5jb25zdCBjb21tYW5kcyA9IHJlcXVpcmUoJy4vc2NyaXB0cy8nKTtcblxuLyoqXG4gIEdldHMgb3IgY3JlYXRlcyBhIG5ldyBRdWV1ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuXG4gIFRoZSBRdWV1ZSBrZWVwcyA2IGRhdGEgc3RydWN0dXJlczpcbiAgICAtIHdhaXQgKGxpc3QpXG4gICAgLSBhY3RpdmUgKGxpc3QpXG4gICAgLSBkZWxheWVkICh6c2V0KVxuICAgIC0gcHJpb3JpdHkgKHpzZXQpXG4gICAgLSBjb21wbGV0ZWQgKHpzZXQpXG4gICAgLSBmYWlsZWQgKHpzZXQpXG5cbiAgICAgICAgLS0+IHByaW9yaXRpZXMgICAgICAtLSA+IGNvbXBsZXRlZFxuICAgICAgIC8gICAgIHwgICAgICAgICAgICAvXG4gICAgam9iIC0+IHdhaXQgLT4gYWN0aXZlXG4gICAgICAgXFwgICAgIF4gICAgICAgICAgICBcXFxuICAgICAgICB2ICAgIHwgICAgICAgICAgICAgLS0gPiBmYWlsZWRcbiAgICAgICAgZGVsYXllZFxuKi9cblxuLyoqXG4gIERlbGF5ZWQgam9icyBhcmUgam9icyB0aGF0IGNhbm5vdCBiZSBleGVjdXRlZCB1bnRpbCBhIGNlcnRhaW4gdGltZSBpblxuICBtcyBoYXMgcGFzc2VkIHNpbmNlIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgcXVldWUuXG4gIFRoZSBtZWNoYW5pc20gaXMgc2ltcGxlLCBhIGRlbGF5ZWRUaW1lc3RhbXAgdmFyaWFibGUgaG9sZHMgdGhlIG5leHRcbiAga25vd24gdGltZXN0YW1wIHRoYXQgaXMgb24gdGhlIGRlbGF5ZWQgc2V0IChvciBNQVhfVElNRU9VVF9NUyBpZiBub25lKS5cblxuICBXaGVuIHRoZSBjdXJyZW50IGpvYiBoYXMgZmluYWxpemVkIHRoZSB2YXJpYWJsZSBpcyBjaGVja2VkLCBpZlxuICBubyBkZWxheWVkIGpvYiBoYXMgdG8gYmUgZXhlY3V0ZWQgeWV0IGEgc2V0VGltZW91dCBpcyBzZXQgc28gdGhhdCBhXG4gIGRlbGF5ZWQgam9iIGlzIHByb2Nlc3NlZCBhZnRlciB0aW1pbmcgb3V0LlxuKi9cbmNvbnN0IE1JTklNVU1fUkVESVNfVkVSU0lPTiA9ICcyLjguMTgnO1xuXG4vKlxuICBpbnRlcmZhY2UgUXVldWVPcHRpb25zIHtcbiAgICBwcmVmaXg/OiBzdHJpbmcgPSAnYnVsbCcsXG4gICAgbGltaXRlcj86IFJhdGVMaW1pdGVyLFxuICAgIHJlZGlzIDogUmVkaXNPcHRzLCAvLyBpb3JlZGlzIGRlZmF1bHRzLFxuICAgIGNyZWF0ZUNsaWVudD86ICh0eXBlOiBlbnVtKCdjbGllbnQnLCAnc3Vic2NyaWJlcicpLCByZWRpc09wdHM/OiBSZWRpc09wdHMpID0+IHJlZGlzQ2xpZW50LFxuICAgIGRlZmF1bHRKb2JPcHRpb25zPzogSm9iT3B0aW9ucyxcblxuICAgIC8vIEFkdmFuY2VkIHNldHRpbmdzXG4gICAgc2V0dGluZ3M/OiBRdWV1ZVNldHRpbmdzIHtcbiAgICAgIGxvY2tEdXJhdGlvbj86IG51bWJlciA9IDMwMDAwLFxuICAgICAgbG9ja1JlbmV3VGltZT86IG51bWJlciA9IGxvY2tEdXJhdGlvbiAvIDIsXG4gICAgICBzdGFsbGVkSW50ZXJ2YWw/OiBudW1iZXIgPSAzMDAwMCxcbiAgICAgIG1heFN0YWxsZWRDb3VudD86IG51bWJlciA9IDEsIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyBhIGpvYiBjYW4gYmUgcmVjb3ZlcmVkIGZyb20gdGhlICdzdGFsbGVkJyBzdGF0ZVxuICAgICAgZ3VhcmRJbnRlcnZhbD86IG51bWJlciA9IDUwMDAsXG4gICAgICByZXRyeVByb2Nlc3NEZWxheT86IG51bWJlciA9IDUwMDAsXG4gICAgICBkcmFpbkRlbGF5PzogbnVtYmVyID0gNVxuICAgICAgaXNTaGFyZWRDaGlsZFBvb2w/OiBib29sZWFuID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpbnRlcmZhY2UgUmF0ZUxpbWl0ZXIge1xuICAgIG1heDogbnVtYmVyLCAgICAgIC8vIE51bWJlciBvZiBqb2JzXG4gICAgZHVyYXRpb246IG51bWJlciwgLy8gcGVyIGR1cmF0aW9uIG1pbGxpc2Vjb25kc1xuICB9XG4qL1xuXG4vLyBRdWV1ZShuYW1lOiBzdHJpbmcsIHVybD8sIG9wdHM/KVxuY29uc3QgUXVldWUgPSBmdW5jdGlvbiBRdWV1ZShuYW1lLCB1cmwsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFF1ZXVlKSkge1xuICAgIHJldHVybiBuZXcgUXVldWUobmFtZSwgdXJsLCBvcHRzKTtcbiAgfVxuXG4gIGlmIChfLmlzU3RyaW5nKHVybCkpIHtcbiAgICBjb25zdCBjbG9uZWRPcHRzID0gXy5jbG9uZURlZXAob3B0cyB8fCB7fSk7XG4gICAgb3B0cyA9IHtcbiAgICAgIC4uLmNsb25lZE9wdHMsXG4gICAgICByZWRpczoge1xuICAgICAgICAuLi5yZWRpc09wdHNGcm9tVXJsKHVybCksXG4gICAgICAgIC4uLmNsb25lZE9wdHMucmVkaXNcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG9wdHMgPSBfLmNsb25lRGVlcCh1cmwgfHwge30pO1xuICB9XG5cbiAgaWYgKCFfLmlzT2JqZWN0KG9wdHMpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdPcHRpb25zIG11c3QgYmUgYSB2YWxpZCBvYmplY3QnKTtcbiAgfVxuXG4gIGlmIChvcHRzLmxpbWl0ZXIpIHtcbiAgICBpZiAob3B0cy5saW1pdGVyLm1heCAmJiBvcHRzLmxpbWl0ZXIuZHVyYXRpb24pIHtcbiAgICAgIHRoaXMubGltaXRlciA9IG9wdHMubGltaXRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGltaXRlciByZXF1aXJlcyBgbWF4YCBhbmQgYGR1cmF0aW9uYCBvcHRpb25zJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuZGVmYXVsdEpvYk9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZmF1bHRKb2JPcHRpb25zID0gb3B0cy5kZWZhdWx0Sm9iT3B0aW9ucztcbiAgfVxuXG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMudG9rZW4gPSB1dWlkLnY0KCk7XG5cbiAgb3B0cy5yZWRpcyA9IHtcbiAgICBlbmFibGVSZWFkeUNoZWNrOiBmYWxzZSxcbiAgICAuLi4oXy5pc1N0cmluZyhvcHRzLnJlZGlzKVxuICAgICAgPyB7IC4uLnJlZGlzT3B0c0Zyb21Vcmwob3B0cy5yZWRpcykgfVxuICAgICAgOiBvcHRzLnJlZGlzKVxuICB9O1xuXG4gIF8uZGVmYXVsdHMob3B0cy5yZWRpcywge1xuICAgIHBvcnQ6IDYzNzksXG4gICAgaG9zdDogJzEyNy4wLjAuMScsXG4gICAgZGI6IG9wdHMucmVkaXMuZGIgfHwgb3B0cy5yZWRpcy5EQixcbiAgICByZXRyeVN0cmF0ZWd5OiBmdW5jdGlvbih0aW1lcykge1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGguZXhwKHRpbWVzKSwgMjAwMDApO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5rZXlQcmVmaXggPSBvcHRzLnJlZGlzLmtleVByZWZpeCB8fCBvcHRzLnByZWZpeCB8fCAnYnVsbCc7XG5cbiAgLy9cbiAgLy8gV2UgY2Fubm90IHVzZSBpb3JlZGlzIGtleVByZWZpeCBmZWF0dXJlIHNpbmNlIHdlXG4gIC8vIGNyZWF0ZSBrZXlzIGR5bmFtaWNhbGx5IGluIGx1YSBzY3JpcHRzLlxuICAvL1xuICBkZWxldGUgb3B0cy5yZWRpcy5rZXlQcmVmaXg7XG5cbiAgdGhpcy5jbGllbnRzID0gW107XG5cbiAgY29uc3QgbG9hZENvbW1hbmRzID0gKHByb3ZpZGVkU2NyaXB0cywgY2xpZW50KSA9PiB7XG4gICAgY29uc3QgZmluYWxTY3JpcHRzID0gcHJvdmlkZWRTY3JpcHRzIHx8IHNjcmlwdHM7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBmaW5hbFNjcmlwdHMpIHtcbiAgICAgIC8vIE9ubHkgZGVmaW5lIHRoZSBjb21tYW5kIGlmIG5vdCBhbHJlYWR5IGRlZmluZWRcbiAgICAgIGlmICghY2xpZW50W2ZpbmFsU2NyaXB0c1twcm9wZXJ0eV0ubmFtZV0pIHtcbiAgICAgICAgY2xpZW50LmRlZmluZUNvbW1hbmQoZmluYWxTY3JpcHRzW3Byb3BlcnR5XS5uYW1lLCB7XG4gICAgICAgICAgbnVtYmVyT2ZLZXlzOiBmaW5hbFNjcmlwdHNbcHJvcGVydHldLmtleXMsXG4gICAgICAgICAgbHVhOiBmaW5hbFNjcmlwdHNbcHJvcGVydHldLmNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGxhenlDbGllbnQgPSByZWRpc0NsaWVudEdldHRlcih0aGlzLCBvcHRzLCAodHlwZSwgY2xpZW50KSA9PiB7XG4gICAgLy8gYnViYmxlIHVwIFJlZGlzIGVycm9yIGV2ZW50c1xuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnZXJyb3InKTtcbiAgICBjbGllbnQub24oJ2Vycm9yJywgaGFuZGxlcik7XG4gICAgdGhpcy5vbmNlKCdjbG9zZScsICgpID0+IGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVyKSk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2NsaWVudCcpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxpemluZyA9IChhc3luYyAoKSA9PiBsb2FkQ29tbWFuZHMoY29tbWFuZHMsIGNsaWVudCkpKCkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGRlYnVnbG9nKG5hbWUgKyAnIHF1ZXVlIHJlYWR5Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIEx1YSBzY3JpcHRzJykpO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgdGhpcy5faW5pdGlhbGl6aW5nLmNhdGNoKCgvKmVyciovKSA9PiB7fSk7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgLy9cbiAgICAvLyBRdWV1ZSBjbGllbnQgKHVzZWQgdG8gYWRkIGpvYnMsIHBhdXNlIHF1ZXVlcywgZXRjKTtcbiAgICAvL1xuICAgIGNsaWVudDoge1xuICAgICAgZ2V0OiBsYXp5Q2xpZW50KCdjbGllbnQnKVxuICAgIH0sXG4gICAgLy9cbiAgICAvLyBFdmVudCBzdWJzY3JpYmVyIGNsaWVudCAocmVjZWl2ZSBtZXNzYWdlcyBmcm9tIG90aGVyIGluc3RhbmNlIG9mIHRoZSBxdWV1ZSlcbiAgICAvL1xuICAgIGVjbGllbnQ6IHtcbiAgICAgIGdldDogbGF6eUNsaWVudCgnc3Vic2NyaWJlcicpXG4gICAgfSxcbiAgICBiY2xpZW50OiB7XG4gICAgICBnZXQ6IGxhenlDbGllbnQoJ2JjbGllbnQnKVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKG9wdHMuc2tpcFZlcnNpb25DaGVjayAhPT0gdHJ1ZSkge1xuICAgIGdldFJlZGlzVmVyc2lvbih0aGlzLmNsaWVudClcbiAgICAgIC50aGVuKHZlcnNpb24gPT4ge1xuICAgICAgICBpZiAoc2VtdmVyLmx0KHZlcnNpb24sIE1JTklNVU1fUkVESVNfVkVSU0lPTikpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnUmVkaXMgdmVyc2lvbiBuZWVkcyB0byBiZSBncmVhdGVyIHRoYW4gJyArXG4gICAgICAgICAgICAgICAgTUlOSU1VTV9SRURJU19WRVJTSU9OICtcbiAgICAgICAgICAgICAgICAnLiBDdXJyZW50OiAnICtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoLyplcnIqLykgPT4ge1xuICAgICAgICAvLyBJZ25vcmUgdGhpcyBlcnJvci5cbiAgICAgIH0pO1xuICB9XG5cbiAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICB0aGlzLmRlbGF5VGltZXI7XG4gIHRoaXMucHJvY2Vzc2luZyA9IFtdO1xuICB0aGlzLnJldHJpZXZpbmcgPSAwO1xuICB0aGlzLmRyYWluZWQgPSB0cnVlO1xuXG4gIHRoaXMuc2V0dGluZ3MgPSBfLmRlZmF1bHRzKG9wdHMuc2V0dGluZ3MsIHtcbiAgICBsb2NrRHVyYXRpb246IDMwMDAwLFxuICAgIHN0YWxsZWRJbnRlcnZhbDogMzAwMDAsXG4gICAgbWF4U3RhbGxlZENvdW50OiAxLFxuICAgIGd1YXJkSW50ZXJ2YWw6IDUwMDAsXG4gICAgcmV0cnlQcm9jZXNzRGVsYXk6IDUwMDAsXG4gICAgZHJhaW5EZWxheTogNSxcbiAgICBiYWNrb2ZmU3RyYXRlZ2llczoge30sXG4gICAgaXNTaGFyZWRDaGlsZFBvb2w6IGZhbHNlXG4gIH0pO1xuXG4gIHRoaXMubWV0cmljcyA9IG9wdHMubWV0cmljcztcblxuICB0aGlzLnNldHRpbmdzLmxvY2tSZW5ld1RpbWUgPVxuICAgIHRoaXMuc2V0dGluZ3MubG9ja1JlbmV3VGltZSB8fCB0aGlzLnNldHRpbmdzLmxvY2tEdXJhdGlvbiAvIDI7XG5cbiAgdGhpcy5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgLy8gRHVtbXkgaGFuZGxlciB0byBhdm9pZCBwcm9jZXNzIHRvIGV4aXQgd2l0aCBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICB9KTtcblxuICAvLyBrZWVwcyB0cmFjayBvZiBhY3RpdmUgdGltZXJzLiB1c2VkIGJ5IGNsb3NlKCkgdG9cbiAgLy8gZW5zdXJlIHRoYXQgZGlzY29ubmVjdCgpIGlzIGRlZmVycmVkIHVudGlsIGFsbFxuICAvLyBzY2hlZHVsZWQgcmVkaXMgY29tbWFuZHMgaGF2ZSBiZWVuIGV4ZWN1dGVkXG4gIHRoaXMudGltZXJzID0gbmV3IFRpbWVyTWFuYWdlcigpO1xuXG4gIC8vIEJpbmQgdGhlc2UgbWV0aG9kcyB0byBhdm9pZCBjb25zdGFudCByZWJpbmRpbmcgYW5kL29yIGNyZWF0aW5nIGNsb3N1cmVzXG4gIC8vIGluIHByb2Nlc3NKb2JzIGV0Yy5cbiAgdGhpcy5tb3ZlVW5sb2NrZWRKb2JzVG9XYWl0ID0gdGhpcy5tb3ZlVW5sb2NrZWRKb2JzVG9XYWl0LmJpbmQodGhpcyk7XG4gIHRoaXMucHJvY2Vzc0pvYiA9IHRoaXMucHJvY2Vzc0pvYi5iaW5kKHRoaXMpO1xuICB0aGlzLmdldEpvYkZyb21JZCA9IEpvYi5mcm9tSWQuYmluZChudWxsLCB0aGlzKTtcblxuICBjb25zdCBrZXlzID0ge307XG4gIF8uZWFjaChcbiAgICBbXG4gICAgICAnJyxcbiAgICAgICdhY3RpdmUnLFxuICAgICAgJ3dhaXQnLFxuICAgICAgJ3dhaXRpbmcnLFxuICAgICAgJ3BhdXNlZCcsXG4gICAgICAncmVzdW1lZCcsXG4gICAgICAnbWV0YS1wYXVzZWQnLFxuICAgICAgJ2FjdGl2ZScsXG4gICAgICAnaWQnLFxuICAgICAgJ2RlbGF5ZWQnLFxuICAgICAgJ3ByaW9yaXR5JyxcbiAgICAgICdzdGFsbGVkLWNoZWNrJyxcbiAgICAgICdjb21wbGV0ZWQnLFxuICAgICAgJ2ZhaWxlZCcsXG4gICAgICAnc3RhbGxlZCcsXG4gICAgICAncmVwZWF0JyxcbiAgICAgICdsaW1pdGVyJyxcbiAgICAgICdkcmFpbmVkJyxcbiAgICAgICdkdXBsaWNhdGVkJyxcbiAgICAgICdwcm9ncmVzcycsXG4gICAgICAnZGUnIC8vIGRlYm91bmNlIGtleVxuICAgIF0sXG4gICAga2V5ID0+IHtcbiAgICAgIGtleXNba2V5XSA9IHRoaXMudG9LZXkoa2V5KTtcbiAgICB9XG4gICk7XG4gIHRoaXMua2V5cyA9IGtleXM7XG59O1xuXG5mdW5jdGlvbiByZWRpc0NsaWVudEdldHRlcihxdWV1ZSwgb3B0aW9ucywgaW5pdENhbGxiYWNrKSB7XG4gIGNvbnN0IGNyZWF0ZUNsaWVudCA9IF8uaXNGdW5jdGlvbihvcHRpb25zLmNyZWF0ZUNsaWVudClcbiAgICA/IG9wdGlvbnMuY3JlYXRlQ2xpZW50XG4gICAgOiBmdW5jdGlvbih0eXBlLCBjb25maWcpIHtcbiAgICAgICAgaWYgKFsnYmNsaWVudCcsICdzdWJzY3JpYmVyJ10uaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZGlzKHsgLi4uY29uZmlnLCBtYXhSZXRyaWVzUGVyUmVxdWVzdDogbnVsbCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZGlzKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgY29uc3QgY29ubmVjdGlvbnMgPSB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIE1lbW9pemVkIGNvbm5lY3Rpb25cbiAgICAgIGlmIChjb25uZWN0aW9uc1t0eXBlXSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uc1t0eXBlXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNsaWVudE9wdGlvbnMgPSBfLmFzc2lnbih7fSwgb3B0aW9ucy5yZWRpcyk7XG5cbiAgICAgIGNvbnN0IGNsaWVudCA9IChjb25uZWN0aW9uc1t0eXBlXSA9IGNyZWF0ZUNsaWVudCh0eXBlLCBjbGllbnRPcHRpb25zKSk7XG5cbiAgICAgIGNvbnN0IG9wdHMgPSBjbGllbnQub3B0aW9ucy5yZWRpc09wdGlvbnMgfHwgY2xpZW50Lm9wdGlvbnM7XG5cbiAgICAgIGlmIChcbiAgICAgICAgWydiY2xpZW50JywgJ3N1YnNjcmliZXInXS5pbmNsdWRlcyh0eXBlKSAmJlxuICAgICAgICAob3B0cy5lbmFibGVSZWFkeUNoZWNrIHx8IG9wdHMubWF4UmV0cmllc1BlclJlcXVlc3QpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5NZXNzYWdlcy5NSVNTSU5HX1JFRElTX09QVFMpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW5jZSBjb25uZWN0aW9ucyBhcmUgbGF6aWx5IGluaXRpYWxpemVkLCB3ZSBjYW4ndCBjaGVjayBxdWV1ZS5jbGllbnRcbiAgICAgIC8vIHdpdGhvdXQgaW5pdGlhbGl6aW5nIGEgY29ubmVjdGlvbi4gU28gZXhwb3NlIGEgYm9vbGVhbiB3ZSBjYW4gc2FmZWx5XG4gICAgICAvLyBxdWVyeS5cbiAgICAgIHF1ZXVlW3R5cGUgKyAnSW5pdGlhbGl6ZWQnXSA9IHRydWU7XG5cbiAgICAgIGlmICghb3B0aW9ucy5jcmVhdGVDbGllbnQpIHtcbiAgICAgICAgcXVldWUuY2xpZW50cy5wdXNoKGNsaWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5pdENhbGxiYWNrKHR5cGUsIGNsaWVudCksIGNsaWVudDtcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWRpc09wdHNGcm9tVXJsKHVybFN0cmluZykge1xuICBsZXQgcmVkaXNPcHRzID0ge307XG4gIHRyeSB7XG4gICAgY29uc3QgcmVkaXNVcmwgPSB1cmwucGFyc2UodXJsU3RyaW5nLCB0cnVlLCB0cnVlKTtcbiAgICByZWRpc09wdHMucG9ydCA9IHBhcnNlSW50KHJlZGlzVXJsLnBvcnQgfHwgJzYzNzknLCAxMCk7XG4gICAgcmVkaXNPcHRzLmhvc3QgPSByZWRpc1VybC5ob3N0bmFtZTtcbiAgICByZWRpc09wdHMuZGIgPSByZWRpc1VybC5wYXRobmFtZSA/IHJlZGlzVXJsLnBhdGhuYW1lLnNwbGl0KCcvJylbMV0gOiAwO1xuICAgIGlmIChyZWRpc1VybC5hdXRoKSB7XG4gICAgICBjb25zdCBjb2x1bW5JbmRleCA9IHJlZGlzVXJsLmF1dGguaW5kZXhPZignOicpO1xuICAgICAgcmVkaXNPcHRzLnBhc3N3b3JkID0gcmVkaXNVcmwuYXV0aC5zbGljZShjb2x1bW5JbmRleCArIDEpO1xuICAgICAgaWYgKGNvbHVtbkluZGV4ID4gMCkge1xuICAgICAgICByZWRpc09wdHMudXNlcm5hbWUgPSByZWRpc1VybC5hdXRoLnNsaWNlKDAsIGNvbHVtbkluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVkaXNVcmwucXVlcnkpIHtcbiAgICAgIHJlZGlzT3B0cyA9IHsgLi4ucmVkaXNPcHRzLCAuLi5yZWRpc1VybC5xdWVyeSB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiByZWRpc09wdHM7XG59XG5cbnV0aWwuaW5oZXJpdHMoUXVldWUsIEV2ZW50RW1pdHRlcik7XG5cbi8vXG4vLyBFeHRlbmQgUXVldWUgd2l0aCBcImFzcGVjdHNcIlxuLy9cbnJlcXVpcmUoJy4vZ2V0dGVycycpKFF1ZXVlKTtcbnJlcXVpcmUoJy4vd29ya2VyJykoUXVldWUpO1xucmVxdWlyZSgnLi9yZXBlYXRhYmxlJykoUXVldWUpO1xuXG4vLyAtLVxuUXVldWUucHJvdG90eXBlLm9mZiA9IFF1ZXVlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuY29uc3QgX29uID0gUXVldWUucHJvdG90eXBlLm9uO1xuXG5RdWV1ZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgdGhpcy5fcmVnaXN0ZXJFdmVudChldmVudE5hbWUpO1xuICByZXR1cm4gX29uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5jb25zdCBfb25jZSA9IFF1ZXVlLnByb3RvdHlwZS5vbmNlO1xuXG5RdWV1ZS5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICB0aGlzLl9yZWdpc3RlckV2ZW50KGV2ZW50TmFtZSk7XG4gIHJldHVybiBfb25jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9pbml0UHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX2luaXRpYWxpemluZ1Byb2Nlc3MpIHtcbiAgICAvL1xuICAgIC8vIE9ubHkgc2V0dXAgbGlzdGVuZXJzIGlmIC5vbi8uYWRkRXZlbnRMaXN0ZW5lciBjYWxsZWQsIG9yIHByb2Nlc3MgZnVuY3Rpb24gZGVmaW5lZC5cbiAgICAvL1xuICAgIHRoaXMuZGVsYXllZFRpbWVzdGFtcCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdGhpcy5faW5pdGlhbGl6aW5nUHJvY2VzcyA9IHRoaXMuaXNSZWFkeSgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RlckV2ZW50KCdkZWxheWVkJyk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVEZWxheVRpbWVyKCk7XG4gICAgICB9KTtcblxuICAgIHRoaXMuZXJyb3JSZXRyeVRpbWVyID0ge307XG4gIH1cblxuICByZXR1cm4gdGhpcy5faW5pdGlhbGl6aW5nUHJvY2Vzcztcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fc2V0dXBRdWV1ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gIC8qXG4gICAgaWYoZXZlbnROYW1lICE9PSAnY2xlYW5lZCcgJiYgZXZlbnROYW1lICE9PSAnZXJyb3InKXtcbiAgICAgIGFyZ3NbMF0gPSBKb2IuZnJvbUpTT04odGhpcywgYXJnc1swXSk7XG4gICAgfVxuICAqL1xuXG4gIGNvbnN0IGFjdGl2ZUtleSA9IHRoaXMua2V5cy5hY3RpdmU7XG4gIGNvbnN0IHN0YWxsZWRLZXkgPSB0aGlzLmtleXMuc3RhbGxlZDtcbiAgY29uc3QgcHJvZ3Jlc3NLZXkgPSB0aGlzLmtleXMucHJvZ3Jlc3M7XG4gIGNvbnN0IGRlbGF5ZWRLZXkgPSB0aGlzLmtleXMuZGVsYXllZDtcbiAgY29uc3QgcGF1c2VkS2V5ID0gdGhpcy5rZXlzLnBhdXNlZDtcbiAgY29uc3QgcmVzdW1lZEtleSA9IHRoaXMua2V5cy5yZXN1bWVkO1xuICBjb25zdCB3YWl0aW5nS2V5ID0gdGhpcy5rZXlzLndhaXRpbmc7XG4gIGNvbnN0IGNvbXBsZXRlZEtleSA9IHRoaXMua2V5cy5jb21wbGV0ZWQ7XG4gIGNvbnN0IGZhaWxlZEtleSA9IHRoaXMua2V5cy5mYWlsZWQ7XG4gIGNvbnN0IGRyYWluZWRLZXkgPSB0aGlzLmtleXMuZHJhaW5lZDtcbiAgY29uc3QgZHVwbGljYXRlZEtleSA9IHRoaXMua2V5cy5kdXBsaWNhdGVkO1xuICBjb25zdCBkZWJvdW5jZWRLZXkgPSB0aGlzLmtleXMuZGUgKyAnYm91bmNlZCc7XG5cbiAgY29uc3QgcG1lc3NhZ2VIYW5kbGVyID0gKHBhdHRlcm4sIGNoYW5uZWwsIG1lc3NhZ2UpID0+IHtcbiAgICBjb25zdCBrZXlBbmRUb2tlbiA9IGNoYW5uZWwuc3BsaXQoJ0AnKTtcbiAgICBjb25zdCBrZXkgPSBrZXlBbmRUb2tlblswXTtcbiAgICBjb25zdCB0b2tlbiA9IGtleUFuZFRva2VuWzFdO1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIGFjdGl2ZUtleTpcbiAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2dsb2JhbDphY3RpdmUnLCBtZXNzYWdlLCAnd2FpdGluZycpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugd2FpdGluZ0tleTpcbiAgICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRva2VuKSB7XG4gICAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ3dhaXRpbmcnLCBtZXNzYWdlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiAmJiB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZ2xvYmFsOndhaXRpbmcnLCBtZXNzYWdlLCBudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHN0YWxsZWRLZXk6XG4gICAgICAgIGlmICh0aGlzLnRva2VuID09PSB0b2tlbikge1xuICAgICAgICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdzdGFsbGVkJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2dsb2JhbDpzdGFsbGVkJywgbWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBkdXBsaWNhdGVkS2V5OlxuICAgICAgICBpZiAodGhpcy50b2tlbiA9PT0gdG9rZW4pIHtcbiAgICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZHVwbGljYXRlZCcsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdnbG9iYWw6ZHVwbGljYXRlZCcsIG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZGVib3VuY2VkS2V5OlxuICAgICAgICBpZiAodGhpcy50b2tlbiA9PT0gdG9rZW4pIHtcbiAgICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZGVib3VuY2VkJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2dsb2JhbDpkZWJvdW5jZWQnLCBtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gKGNoYW5uZWwsIG1lc3NhZ2UpID0+IHtcbiAgICBjb25zdCBrZXkgPSBjaGFubmVsLnNwbGl0KCdAJylbMF07XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgcHJvZ3Jlc3NLZXk6IHtcbiAgICAgICAgLy8gTmV3IHdheSB0byBzZW5kIHByb2dyZXNzIG1lc3NhZ2UgZGF0YVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgcHJvZ3Jlc3MsIGpvYklkIH0gPSBKU09OLnBhcnNlKG1lc3NhZ2UpO1xuICAgICAgICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdnbG9iYWw6cHJvZ3Jlc3MnLCBqb2JJZCwgcHJvZ3Jlc3MpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBmYWlsIHdlIHNob3VsZCB0cnkgdG8gcGFyc2UgdGhlIGRhdGEgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgbWV0aG9kXG4gICAgICAgICAgY29uc3QgY29tbWFQb3MgPSBtZXNzYWdlLmluZGV4T2YoJywnKTtcbiAgICAgICAgICBjb25zdCBqb2JJZCA9IG1lc3NhZ2Uuc3Vic3RyaW5nKDAsIGNvbW1hUG9zKTtcbiAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IG1lc3NhZ2Uuc3Vic3RyaW5nKGNvbW1hUG9zICsgMSk7XG4gICAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2dsb2JhbDpwcm9ncmVzcycsIGpvYklkLCBKU09OLnBhcnNlKHByb2dyZXNzKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGRlbGF5ZWRLZXk6IHtcbiAgICAgICAgY29uc3QgbmV3RGVsYXllZFRpbWVzdGFtcCA9IF8uY2VpbChtZXNzYWdlKTtcbiAgICAgICAgaWYgKG5ld0RlbGF5ZWRUaW1lc3RhbXAgPCB0aGlzLmRlbGF5ZWRUaW1lc3RhbXApIHtcbiAgICAgICAgICAvLyBUaGUgbmV3IGRlbGF5ZWQgdGltZXN0YW1wIGlzIGJlZm9yZSB0aGUgY3VycmVudGx5IG5ld2VzdCBrbm93biBkZWxheWVkIHRpbWVzdGFtcFxuICAgICAgICAgIC8vIEFzc3VtZSB0aGlzIGlzIHRoZSBuZXcgZGVsYXllZCB0aW1lc3RhbXAgYW5kIGNhbGwgYHVwZGF0ZURlbGF5VGltZXIoKWAgdG8gcHJvY2VzcyBhbnkgZGVsYXllZCBqb2JzXG4gICAgICAgICAgLy8gVGhpcyB3aWxsIGFsc28gdXBkYXRlIHRoZSBgZGVsYXllZFRpbWVzdGFtcGBcbiAgICAgICAgICB0aGlzLmRlbGF5ZWRUaW1lc3RhbXAgPSBuZXdEZWxheWVkVGltZXN0YW1wO1xuXG4gICAgICAgICAgdGhpcy51cGRhdGVEZWxheVRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIHBhdXNlZEtleTpcbiAgICAgIGNhc2UgcmVzdW1lZEtleTpcbiAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2dsb2JhbDonICsgbWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBjb21wbGV0ZWRLZXk6IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG4gICAgICAgIHV0aWxzLmVtaXRTYWZlKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgJ2dsb2JhbDpjb21wbGV0ZWQnLFxuICAgICAgICAgIGRhdGEuam9iSWQsXG4gICAgICAgICAgZGF0YS52YWwsXG4gICAgICAgICAgJ2FjdGl2ZSdcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGZhaWxlZEtleToge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2dsb2JhbDpmYWlsZWQnLCBkYXRhLmpvYklkLCBkYXRhLnZhbCwgJ2FjdGl2ZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgZHJhaW5lZEtleTpcbiAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2dsb2JhbDpkcmFpbmVkJyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmVjbGllbnQub24oJ3BtZXNzYWdlJywgcG1lc3NhZ2VIYW5kbGVyKTtcbiAgdGhpcy5lY2xpZW50Lm9uKCdtZXNzYWdlJywgbWVzc2FnZUhhbmRsZXIpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgdGhpcy5lY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdwbWVzc2FnZScsIHBtZXNzYWdlSGFuZGxlcik7XG4gICAgdGhpcy5lY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgbWVzc2FnZUhhbmRsZXIpO1xuICB9KTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fcmVnaXN0ZXJFdmVudCA9IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICBjb25zdCBpbnRlcm5hbEV2ZW50cyA9IFsnd2FpdGluZycsICdkZWxheWVkJywgJ2R1cGxpY2F0ZWQnLCAnZGVib3VuY2VkJ107XG5cbiAgaWYgKFxuICAgIGV2ZW50TmFtZS5zdGFydHNXaXRoKCdnbG9iYWw6JykgfHxcbiAgICBpbnRlcm5hbEV2ZW50cy5pbmRleE9mKGV2ZW50TmFtZSkgIT09IC0xXG4gICkge1xuICAgIGlmICghdGhpcy5yZWdpc3RlcmVkRXZlbnRzKSB7XG4gICAgICB0aGlzLl9zZXR1cFF1ZXVlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IHRoaXMucmVnaXN0ZXJlZEV2ZW50cyB8fCB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBfZXZlbnROYW1lID0gZXZlbnROYW1lLnJlcGxhY2UoJ2dsb2JhbDonLCAnJyk7XG5cbiAgICBpZiAoIXRoaXMucmVnaXN0ZXJlZEV2ZW50c1tfZXZlbnROYW1lXSkge1xuICAgICAgcmV0dXJuIHV0aWxzXG4gICAgICAgIC5pc1JlZGlzUmVhZHkodGhpcy5lY2xpZW50KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMudG9LZXkoX2V2ZW50TmFtZSk7XG4gICAgICAgICAgaWYgKFsnYWN0aXZlJywgJ3dhaXRpbmcnLCAnc3RhbGxlZCcsICdkdXBsaWNhdGVkJywgJ2RlYm91bmNlZCddLmluZGV4T2YoX2V2ZW50TmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucmVnaXN0ZXJlZEV2ZW50c1tfZXZlbnROYW1lXSA9IHRoaXMuZWNsaWVudC5wc3Vic2NyaWJlKFxuICAgICAgICAgICAgICBjaGFubmVsICsgJyonXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnJlZ2lzdGVyZWRFdmVudHNbX2V2ZW50TmFtZV0gPSB0aGlzLmVjbGllbnQuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICBjaGFubmVsXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAncmVnaXN0ZXJlZDonICsgZXZlbnROYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyZWRFdmVudHNbX2V2ZW50TmFtZV07XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn07XG5cblF1ZXVlLkVycm9yTWVzc2FnZXMgPSBlcnJvcnMuTWVzc2FnZXM7XG5cblF1ZXVlLnByb3RvdHlwZS5pc1JlYWR5ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGF3YWl0IHRoaXMuX2luaXRpYWxpemluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5hc3luYyBmdW5jdGlvbiByZWRpc0NsaWVudERpc2Nvbm5lY3QoY2xpZW50KSB7XG4gIGlmIChjbGllbnQuc3RhdHVzICE9PSAnZW5kJykge1xuICAgIGxldCBfcmVzb2x2ZSwgX3JlamVjdDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgX3JlamVjdCA9IHJlamVjdDtcbiAgICAgIGNsaWVudC5vbmNlKCdlbmQnLCBfcmVzb2x2ZSk7XG5cbiAgICAgIHBUaW1lb3V0KFxuICAgICAgICBjbGllbnQucXVpdCgpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVyci5tZXNzYWdlICE9PSAnQ29ubmVjdGlvbiBpcyBjbG9zZWQuJykge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIDUwMFxuICAgICAgKVxuICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8vIElnbm9yZSB0aW1lb3V0IGVycm9yXG4gICAgICAgIH0pXG4gICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICBjbGllbnQub25jZSgnZXJyb3InLCBfcmVqZWN0KTtcblxuICAgICAgICAgIGNsaWVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgaWYgKFsnY29ubmVjdGluZycsICdyZWNvbm5lY3RpbmcnXS5pbmNsdWRlcyhjbGllbnQuc3RhdHVzKSkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIF9yZXNvbHZlKTtcbiAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBfcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxufVxuXG5RdWV1ZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB0aGlzLmNsaWVudHMubWFwKGNsaWVudCA9PlxuICAgICAgY2xpZW50LmJsb2NrZWQgPyBjbGllbnQuZGlzY29ubmVjdCgpIDogcmVkaXNDbGllbnREaXNjb25uZWN0KGNsaWVudClcbiAgICApXG4gICk7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUucmVtb3ZlSm9icyA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgcmV0dXJuIEpvYi5yZW1vdmUodGhpcywgcGF0dGVybik7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihkb05vdFdhaXRKb2JzKSB7XG4gIGxldCBpc1JlYWR5ID0gdHJ1ZTtcbiAgaWYgKHRoaXMuY2xvc2luZykge1xuICAgIHJldHVybiB0aGlzLmNsb3Npbmc7XG4gIH1cblxuICByZXR1cm4gKHRoaXMuY2xvc2luZyA9IHRoaXMuaXNSZWFkeSgpXG4gICAgLnRoZW4odGhpcy5faW5pdGlhbGl6aW5nUHJvY2VzcylcbiAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgaXNSZWFkeSA9IGZhbHNlO1xuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4gaXNSZWFkeSAmJiB0aGlzLnBhdXNlKHRydWUsIGRvTm90V2FpdEpvYnMpKVxuICAgIC5jYXRjaCgoKSA9PiB2b2lkIDApIC8vIElnbm9yZSBwb3NzaWJsZSBlcnJvciBmcm9tIHBhdXNlXG4gICAgLmZpbmFsbHkoKCkgPT4gdGhpcy5fY2xlYXJUaW1lcnMoKSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuY2hpbGRQb29sKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNsZWFuUHJvbWlzZSA9IHRoaXMuY2hpbGRQb29sLmNsZWFuKCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAvLyBJZ25vcmUgdGhpcyBlcnJvciBhbmQgdHJ5IHRvIGNsb3NlIGFueXdheS5cbiAgICAgIH0pO1xuICAgICAgaWYgKGRvTm90V2FpdEpvYnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsZWFuUHJvbWlzZTtcbiAgICB9KVxuICAgIC50aGVuKFxuICAgICAgYXN5bmMgKCkgPT4gdGhpcy5kaXNjb25uZWN0KCksXG4gICAgICBlcnIgPT4gY29uc29sZS5lcnJvcihlcnIpXG4gICAgKVxuICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdjbG9zZScpO1xuICAgIH0pKTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fY2xlYXJUaW1lcnMgPSBmdW5jdGlvbigpIHtcbiAgXy5lYWNoKHRoaXMuZXJyb3JSZXRyeVRpbWVyLCB0aW1lciA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgfSk7XG4gIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZXIpO1xuICBjbGVhckludGVydmFsKHRoaXMuZ3VhcmRpYW5UaW1lcik7XG4gIGNsZWFySW50ZXJ2YWwodGhpcy5tb3ZlVW5sb2NrZWRKb2JzVG9XYWl0SW50ZXJ2YWwpO1xuICB0aGlzLnRpbWVycy5jbGVhckFsbCgpO1xuICByZXR1cm4gdGhpcy50aW1lcnMud2hlbklkbGUoKTtcbn07XG5cbi8qKlxuICBQcm9jZXNzZXMgYSBqb2IgZnJvbSB0aGUgcXVldWUuIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgZm9yIGV2ZXJ5IGpvYiB0aGF0XG4gIGlzIGRlcXVldWVkLlxuXG4gIEBtZXRob2QgcHJvY2Vzc1xuKi9cblF1ZXVlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24obmFtZSwgY29uY3VycmVuY3ksIGhhbmRsZXIpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgaGFuZGxlciA9IG5hbWU7XG4gICAgICBjb25jdXJyZW5jeSA9IDE7XG4gICAgICBuYW1lID0gSm9iLkRFRkFVTFRfSk9CX05BTUU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6IC8vIChzdHJpbmcsIGZ1bmN0aW9uKSBvciAoc3RyaW5nLCBzdHJpbmcpIG9yIChudW1iZXIsIGZ1bmN0aW9uKSBvciAobnVtYmVyLCBzdHJpbmcpXG4gICAgICBoYW5kbGVyID0gY29uY3VycmVuY3k7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmN1cnJlbmN5ID0gbmFtZTtcbiAgICAgICAgbmFtZSA9IEpvYi5ERUZBVUxUX0pPQl9OQU1FO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICB0aGlzLnNldEhhbmRsZXIobmFtZSwgaGFuZGxlcik7XG5cbiAgcmV0dXJuIHRoaXMuX2luaXRQcm9jZXNzKCkudGhlbigoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQoY29uY3VycmVuY3ksIG5hbWUpO1xuICB9KTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGNvbmN1cnJlbmN5LCBuYW1lKSB7XG4gIHJldHVybiB0aGlzLnJ1bihjb25jdXJyZW5jeSwgbmFtZSkuY2F0Y2goZXJyID0+IHtcbiAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZXJyb3InLCBlcnIsICdlcnJvciBydW5uaW5nIHF1ZXVlJyk7XG4gICAgdGhyb3cgZXJyO1xuICB9KTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5zZXRIYW5kbGVyID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgYW4gdW5kZWZpbmVkIGhhbmRsZXInKTtcbiAgfVxuICBpZiAodGhpcy5oYW5kbGVyc1tuYW1lXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlZmluZSB0aGUgc2FtZSBoYW5kbGVyIHR3aWNlICcgKyBuYW1lKTtcbiAgfVxuXG4gIHRoaXMuc2V0V29ya2VyTmFtZSgpO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBzdXBwb3J0ZWRGaWxlVHlwZXMgPSBbJy5qcycsICcudHMnLCAnLmZsb3cnLCAnLmNqcyddO1xuICAgIGNvbnN0IHByb2Nlc3NvckZpbGUgPVxuICAgICAgaGFuZGxlciArXG4gICAgICAoc3VwcG9ydGVkRmlsZVR5cGVzLmluY2x1ZGVzKHBhdGguZXh0bmFtZShoYW5kbGVyKSkgPyAnJyA6ICcuanMnKTtcblxuICAgIGlmICghZnMuZXhpc3RzU3luYyhwcm9jZXNzb3JGaWxlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWxlICcgKyBwcm9jZXNzb3JGaWxlICsgJyBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICBjb25zdCBpc1NoYXJlZENoaWxkUG9vbCA9IHRoaXMuc2V0dGluZ3MuaXNTaGFyZWRDaGlsZFBvb2w7XG4gICAgdGhpcy5jaGlsZFBvb2wgPVxuICAgICAgdGhpcy5jaGlsZFBvb2wgfHwgcmVxdWlyZSgnLi9wcm9jZXNzL2NoaWxkLXBvb2wnKShpc1NoYXJlZENoaWxkUG9vbCk7XG5cbiAgICBjb25zdCBzYW5kYm94ID0gcmVxdWlyZSgnLi9wcm9jZXNzL3NhbmRib3gnKTtcbiAgICB0aGlzLmhhbmRsZXJzW25hbWVdID0gc2FuZGJveChoYW5kbGVyLCB0aGlzLmNoaWxkUG9vbCkuYmluZCh0aGlzKTtcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKGhhbmRsZXIubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5oYW5kbGVyc1tuYW1lXSA9IHByb21pc2lmeShoYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVyc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuXG4vKipcbmludGVyZmFjZSBKb2JPcHRpb25zXG57XG4gIGF0dGVtcHRzOiBudW1iZXI7XG5cbiAgcmVwZWF0OiB7XG4gICAgdHo/OiBzdHJpbmcsXG4gICAgZW5kRGF0ZT86IERhdGUgfCBzdHJpbmcgfCBudW1iZXJcbiAgfSxcbiAgcHJldmVudFBhcnNpbmdEYXRhOiBib29sZWFuO1xufVxuKi9cblxuLyoqXG4gIEFkZHMgYSBqb2IgdG8gdGhlIHF1ZXVlLlxuICBAbWV0aG9kIGFkZFxuICBAcGFyYW0gZGF0YToge30gQ3VzdG9tIGRhdGEgdG8gc3RvcmUgZm9yIHRoaXMgam9iLiBTaG91bGQgYmUgSlNPTiBzZXJpYWxpemFibGUuXG4gIEBwYXJhbSBvcHRzOiBKb2JPcHRpb25zIE9wdGlvbnMgZm9yIHRoaXMgam9iLlxuKi9cblF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBvcHRzID0gZGF0YTtcbiAgICBkYXRhID0gbmFtZTtcbiAgICBuYW1lID0gSm9iLkRFRkFVTFRfSk9CX05BTUU7XG4gIH1cbiAgb3B0cyA9IF8uY2xvbmVEZWVwKHsgLi4udGhpcy5kZWZhdWx0Sm9iT3B0aW9ucywgLi4ub3B0cyB9KTtcblxuICBvcHRzLmpvYklkID0gam9iSWRGb3JHcm91cCh0aGlzLmxpbWl0ZXIsIG9wdHMsIGRhdGEpO1xuXG4gIGlmIChvcHRzLnJlcGVhdCkge1xuICAgIHJldHVybiB0aGlzLmlzUmVhZHkoKS50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLm5leHRSZXBlYXRhYmxlSm9iKG5hbWUsIGRhdGEsIG9wdHMsIHRydWUpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBKb2IuY3JlYXRlKHRoaXMsIG5hbWUsIGRhdGEsIG9wdHMpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJ5IGFsbCB0aGUgZmFpbGVkIGpvYnMuXG4gKlxuICogQHBhcmFtIG9wdHMuY291bnQgLSBudW1iZXIgdG8gbGltaXQgaG93IG1hbnkgam9icyB3aWxsIGJlIG1vdmVkIHRvIHdhaXQgc3RhdHVzIHBlciBpdGVyYXRpb25cbiAqIEByZXR1cm5zXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5yZXRyeUpvYnMgPSBhc3luYyBmdW5jdGlvbihvcHRzID0ge30pIHtcbiAgbGV0IGN1cnNvciA9IDA7XG4gIGRvIHtcbiAgICBjdXJzb3IgPSBhd2FpdCBzY3JpcHRzLnJldHJ5Sm9icyh0aGlzLCBvcHRzLmNvdW50KTtcbiAgfSB3aGlsZSAoY3Vyc29yKTtcbn07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBkZWJvdW5jZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIGlkZW50aWZpZXJcbiAgICovXG4gIFF1ZXVlLnByb3RvdHlwZS5yZW1vdmVEZWJvdW5jZUtleSA9IChpZCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5kZWwoYCR7dGhpcy5rZXlzLmRlfToke2lkfWApO1xuICB9XG5cbi8qKlxuICBBZGRzIGFuIGFycmF5IG9mIGpvYnMgdG8gdGhlIHF1ZXVlLlxuICBAbWV0aG9kIGFkZFxuICBAcGFyYW0gam9iczogW10gVGhlIGFycmF5IG9mIGpvYnMgdG8gYWRkIHRvIHRoZSBxdWV1ZS4gRWFjaCBqb2IgaXMgZGVmaW5lZCBieSAzIHByb3BlcnRpZXMsICduYW1lJywgJ2RhdGEnIGFuZCAnb3B0cycuIFRoZXkgZm9sbG93IHRoZSBzYW1lIHNpZ25hdHVyZSBhcyAnUXVldWUuYWRkJy5cbiovXG5RdWV1ZS5wcm90b3R5cGUuYWRkQnVsayA9IGZ1bmN0aW9uKGpvYnMpIHtcbiAgY29uc3QgZGVjb3JhdGVkSm9icyA9IGpvYnMubWFwKGpvYiA9PiB7XG4gICAgY29uc3Qgam9iSWQgPSBqb2JJZEZvckdyb3VwKHRoaXMubGltaXRlciwgam9iLm9wdHMsIGpvYi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uam9iLFxuICAgICAgbmFtZTogdHlwZW9mIGpvYi5uYW1lICE9PSAnc3RyaW5nJyA/IEpvYi5ERUZBVUxUX0pPQl9OQU1FIDogam9iLm5hbWUsXG4gICAgICBvcHRzOiB7XG4gICAgICAgIC4uLnRoaXMuZGVmYXVsdEpvYk9wdGlvbnMsXG4gICAgICAgIC4uLmpvYi5vcHRzLFxuICAgICAgICBqb2JJZFxuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gSm9iLmNyZWF0ZUJ1bGsodGhpcywgZGVjb3JhdGVkSm9icyk7XG59O1xuLyoqXG4gIEVtcHRpZXMgdGhlIHF1ZXVlLlxuXG4gIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gIE5vdGUgdGhhdCBpZiBzb21lIG90aGVyIHByb2Nlc3MgaXMgYWRkaW5nIGpvYnMgYXQgdGhlIHNhbWUgdGltZSBhcyBlbXB0eWluZyxcbiAgdGhlIHF1ZXVlcyBtYXkgbm90IGJlIHJlYWxseSBlbXB0eSBhZnRlciB0aGlzIG1ldGhvZCBoYXMgZXhlY3V0ZWQgY29tcGxldGVseS5cbiAgQWxzbywgaWYgdGhlIG1ldGhvZCBkb2VzIGVycm9yIGJldHdlZW4gZW1wdHlpbmcgdGhlIGxpc3RzIGFuZCByZW1vdmluZyBhbGwgdGhlXG4gIGpvYnMsIHRoZXJlIHdpbGwgYmUgem9tYmllIGpvYnMgbGVmdCBpbiByZWRpcy5cblxuICBUT0RPOiBVc2UgRVZBTCB0byBtYWtlIHRoaXMgb3BlcmF0aW9uIGZ1bGx5IGF0b21pYy5cbiovXG5RdWV1ZS5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgcXVldWVLZXlzID0gdGhpcy5rZXlzO1xuXG4gIGxldCBtdWx0aSA9IHRoaXMubXVsdGkoKTtcblxuICBtdWx0aS5scmFuZ2UocXVldWVLZXlzLndhaXQsIDAsIC0xKTtcbiAgbXVsdGkubHJhbmdlKHF1ZXVlS2V5cy5wYXVzZWQsIDAsIC0xKTtcbiAgbXVsdGkua2V5cyh0aGlzLnRvS2V5KCcqOmxpbWl0ZWQnKSk7XG4gIG11bHRpLmRlbChcbiAgICBxdWV1ZUtleXMud2FpdCxcbiAgICBxdWV1ZUtleXMucGF1c2VkLFxuICAgIHF1ZXVlS2V5c1snbWV0YS1wYXVzZWQnXSxcbiAgICBxdWV1ZUtleXMuZGVsYXllZCxcbiAgICBxdWV1ZUtleXMucHJpb3JpdHksXG4gICAgcXVldWVLZXlzLmxpbWl0ZXIsXG4gICAgYCR7cXVldWVLZXlzLmxpbWl0ZXJ9OmluZGV4YFxuICApO1xuXG4gIHJldHVybiBtdWx0aS5leGVjKCkudGhlbihyZXMgPT4ge1xuICAgIGxldCBbd2FpdGluZywgcGF1c2VkLCBsaW1pdGVkXSA9IHJlcztcblxuICAgIHdhaXRpbmcgPSB3YWl0aW5nWzFdO1xuICAgIHBhdXNlZCA9IHBhdXNlZFsxXTtcbiAgICBsaW1pdGVkID0gbGltaXRlZFsxXTtcblxuICAgIGNvbnN0IGpvYktleXMgPSBwYXVzZWQuY29uY2F0KHdhaXRpbmcpLm1hcCh0aGlzLnRvS2V5LCB0aGlzKTtcblxuICAgIGlmIChqb2JLZXlzLmxlbmd0aCB8fCBsaW1pdGVkLmxlbmd0aCkge1xuICAgICAgbXVsdGkgPSB0aGlzLm11bHRpKCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgam9iS2V5cy5sZW5ndGg7IGkgKz0gMTAwMDApIHtcbiAgICAgICAgbXVsdGkuZGVsLmFwcGx5KG11bHRpLCBqb2JLZXlzLnNsaWNlKGksIGkgKyAxMDAwMCkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0ZWQubGVuZ3RoOyBpICs9IDEwMDAwKSB7XG4gICAgICAgIG11bHRpLmRlbC5hcHBseShtdWx0aSwgbGltaXRlZC5zbGljZShpLCBpICsgMTAwMDApKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG11bHRpLmV4ZWMoKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gIFBhdXNlcyB0aGUgcHJvY2Vzc2luZyBvZiB0aGlzIHF1ZXVlLCBsb2NhbGx5IGlmIHRydWUgcGFzc2VkLCBvdGhlcndpc2UgZ2xvYmFsbHkuXG5cbiAgRm9yIGdsb2JhbCBwYXVzZSwgd2UgdXNlIGFuIGF0b21pYyBSRU5BTUUgb3BlcmF0aW9uIG9uIHRoZSB3YWl0IHF1ZXVlLiBTaW5jZVxuICB3ZSBoYXZlIGJsb2NraW5nIGNhbGxzIHdpdGggQlJQT1BMUFVTSCBvbiB0aGUgd2FpdCBxdWV1ZSwgYXMgbG9uZyBhcyB0aGUgcXVldWVcbiAgaXMgcmVuYW1lZCB0byAncGF1c2VkJywgbm8gbmV3IGpvYnMgd2lsbCBiZSBwcm9jZXNzZWQgKHRoZSBjdXJyZW50IG9uZXNcbiAgd2lsbCBydW4gdW50aWwgZmluYWxpemVkKS5cblxuICBBZGRpbmcgam9icyByZXF1aXJlcyBhIExVQSBzY3JpcHQgdG8gY2hlY2sgZmlyc3QgaWYgdGhlIHBhdXNlZCBsaXN0IGV4aXN0XG4gIGFuZCBpbiB0aGF0IGNhc2UgaXQgd2lsbCBhZGQgaXQgdGhlcmUgaW5zdGVhZCBvZiB0aGUgd2FpdCBsaXN0LlxuKi9cblF1ZXVlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKGlzTG9jYWwsIGRvTm90V2FpdEFjdGl2ZSkge1xuICByZXR1cm4gdGhpcy5pc1JlYWR5KClcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy5wYXVzZWQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzdW1lTG9jYWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhpcy5wYXVzZWQgPSBudWxsOyAvLyBBbGxvdyBwYXVzZSB0byBiZSBjaGVja2VkIGV4dGVybmFsbHkgZm9yIHBhdXNlZCBzdGF0ZS5cbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5iY2xpZW50SW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAvLyBiY2xpZW50IG5vdCB5ZXQgaW5pdGlhbGl6ZWQsIHNvIG5vIGpvYnMgdG8gd2FpdCBmb3JcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9Ob3RXYWl0QWN0aXZlKSB7XG4gICAgICAgICAgLy8gRm9yY2UgcmVjb25uZWN0aW9uIG9mIGJsb2NraW5nIGNvbm5lY3Rpb24gdG8gYWJvcnQgYmxvY2tpbmcgcmVkaXMgY2FsbCBpbW1lZGlhdGVseS5cbiAgICAgICAgICByZXR1cm4gcmVkaXNDbGllbnREaXNjb25uZWN0KHRoaXMuYmNsaWVudCkudGhlbigoKSA9PlxuICAgICAgICAgICAgdGhpcy5iY2xpZW50LmNvbm5lY3QoKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2hlbkN1cnJlbnRKb2JzRmluaXNoZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzY3JpcHRzLnBhdXNlKHRoaXMsIHRydWUpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdwYXVzZWQnKTtcbiAgICB9KTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbihpc0xvY2FsIC8qIE9wdGlvbmFsICovKSB7XG4gIHJldHVybiB0aGlzLmlzUmVhZHkoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VtZUxvY2FsKSB7XG4gICAgICAgICAgdGhpcy5yZXN1bWVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NyaXB0cy5wYXVzZSh0aGlzLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAncmVzdW1lZCcpO1xuICAgIH0pO1xufTtcblxuUXVldWUucHJvdG90eXBlLmlzUGF1c2VkID0gYXN5bmMgZnVuY3Rpb24oaXNMb2NhbCkge1xuICBpZiAoaXNMb2NhbCkge1xuICAgIHJldHVybiAhIXRoaXMucGF1c2VkO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IHRoaXMuaXNSZWFkeSgpO1xuICAgIGNvbnN0IG11bHRpID0gdGhpcy5tdWx0aSgpO1xuXG4gICAgbXVsdGkuZXhpc3RzKHRoaXMua2V5c1snbWV0YS1wYXVzZWQnXSk7XG5cbiAgICAvLyBGb3IgZm9yd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggQnVsbE1RLlxuICAgIG11bHRpLmhleGlzdHModGhpcy50b0tleSgnbWV0YScpLCAncGF1c2VkJyk7XG5cbiAgICBjb25zdCBbWywgaXNQYXVzZWRdLCBbLCBpc1BhdXNlZE5ld11dID0gYXdhaXQgbXVsdGkuZXhlYygpO1xuXG4gICAgcmV0dXJuICEhKGlzUGF1c2VkIHx8IGlzUGF1c2VkTmV3KTtcbiAgfVxufTtcblxuUXVldWUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKGNvbmN1cnJlbmN5LCBoYW5kbGVyTmFtZSkge1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29uY3VycmVuY3kpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IEZsb2F0IGFzIGNvbmN1cnJlbmN5Jyk7XG4gIH1cbiAgY29uc3QgcHJvbWlzZXMgPSBbXTtcblxuICByZXR1cm4gdGhpcy5pc1JlYWR5KClcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5tb3ZlVW5sb2NrZWRKb2JzVG9XYWl0KCk7XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gdXRpbHMuaXNSZWRpc1JlYWR5KHRoaXMuYmNsaWVudCk7XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICB3aGlsZSAoY29uY3VycmVuY3ktLSkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzSm9icyhgJHtoYW5kbGVyTmFtZX06JHtjb25jdXJyZW5jeX1gLCByZXNvbHZlKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXJ0TW92ZVVubG9ja2VkSm9ic1RvV2FpdCgpO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH0pO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAgVGhpcyBmdW5jdGlvbiB1cGRhdGVzIHRoZSBkZWxheSB0aW1lciwgd2hpY2ggaXMgYSB0aW1lciB0aGF0IHRpbWVvdXRzXG4gIGF0IHRoZSBuZXh0IGtub3duIGRlbGF5ZWQgam9iLlxuKi9cblF1ZXVlLnByb3RvdHlwZS51cGRhdGVEZWxheVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNsb3NpbmcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICByZXR1cm4gc2NyaXB0c1xuICAgIC51cGRhdGVEZWxheVNldCh0aGlzLCBEYXRlLm5vdygpKVxuICAgIC50aGVuKG5leHRUaW1lc3RhbXAgPT4ge1xuICAgICAgdGhpcy5kZWxheWVkVGltZXN0YW1wID0gbmV4dFRpbWVzdGFtcFxuICAgICAgICA/IG5leHRUaW1lc3RhbXAgLyA0MDk2XG4gICAgICAgIDogTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHVwZGF0ZSBkZWxheSB0aW1lclxuICAgICAgaWYgKHRoaXMuZGVsYXlUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVsYXkgZm9yIHRoZSBuZXh0IHVwZGF0ZSBvZiBkZWxheSBzZXRcbiAgICAgIGNvbnN0IGRlbGF5ID0gXy5taW4oW1xuICAgICAgICB0aGlzLmRlbGF5ZWRUaW1lc3RhbXAgLSBEYXRlLm5vdygpLFxuICAgICAgICB0aGlzLnNldHRpbmdzLmd1YXJkSW50ZXJ2YWxcbiAgICAgIF0pO1xuXG4gICAgICAvLyBTY2hlZHVsZSBuZXh0IHByb2Nlc3Npbmcgb2YgdGhlIGRlbGF5ZWQgam9ic1xuICAgICAgaWYgKGRlbGF5IDw9IDApIHtcbiAgICAgICAgLy8gTmV4dCBzZXQgb2Ygam9icyBhcmUgZHVlIHJpZ2h0IG5vdywgcHJvY2VzcyB0aGVtIGFsc29cbiAgICAgICAgdGhpcy51cGRhdGVEZWxheVRpbWVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGRlbGF5IHNldCB3aGVuIHRoZSBuZXh0IGpvYiBpcyBkdWVcbiAgICAgICAgLy8gb3IgdGhlIG5leHQgZ3VhcmQgdGltZVxuICAgICAgICB0aGlzLmRlbGF5VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlRGVsYXlUaW1lcigpLCBkZWxheSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpbGVuY2Ugd2FybmluZ3MgYWJvdXQgcHJvbWlzZSBjcmVhdGVkIGJ1dCBub3QgcmV0dXJuZWQuXG4gICAgICAvLyBUaGlzIGlzbid0IGFuIGlzc3VlIHNpbmNlIHdlIGVtaXQgZXJyb3JzLlxuICAgICAgLy8gU2VlIGh0dHA6Ly9ibHVlYmlyZGpzLmNvbS9kb2NzL3dhcm5pbmctZXhwbGFuYXRpb25zLmh0bWwjd2FybmluZy1hLXByb21pc2Utd2FzLWNyZWF0ZWQtaW4tYS1oYW5kbGVyLWJ1dC13YXMtbm90LXJldHVybmVkLWZyb20taXRcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pXG4gICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZXJyb3InLCBlcnIsICdFcnJvciB1cGRhdGluZyB0aGUgZGVsYXkgdGltZXInKTtcbiAgICAgIGlmICh0aGlzLmRlbGF5VGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVsYXlUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAgICgpID0+IHRoaXMudXBkYXRlRGVsYXlUaW1lcigpLFxuICAgICAgICB0aGlzLnNldHRpbmdzLmd1YXJkSW50ZXJ2YWxcbiAgICAgICk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFByb2Nlc3Mgam9icyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgYWN0aXZlIGxpc3QgYnV0IGFyZSBub3QgYmVpbmdcbiAqIHByb2Nlc3NlZCBwcm9wZXJseS4gVGhpcyBjYW4gaGFwcGVuIGR1ZSB0byBhIHByb2Nlc3MgY3Jhc2ggaW4gdGhlIG1pZGRsZVxuICogb2YgcHJvY2Vzc2luZyBhIGpvYiwgbGVhdmluZyBpdCBpbiAnYWN0aXZlJyBidXQgd2l0aG91dCBhIGpvYiBsb2NrLlxuICovXG5RdWV1ZS5wcm90b3R5cGUubW92ZVVubG9ja2VkSm9ic1RvV2FpdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jbG9zaW5nKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgcmV0dXJuIHNjcmlwdHNcbiAgICAubW92ZVVubG9ja2VkSm9ic1RvV2FpdCh0aGlzKVxuICAgIC50aGVuKChbZmFpbGVkLCBzdGFsbGVkXSkgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlRmFpbGVkSm9icyA9IGZhaWxlZC5tYXAoam9iSWQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRKb2JGcm9tSWQoam9iSWQpLnRoZW4oam9iID0+IHtcbiAgICAgICAgICB1dGlscy5lbWl0U2FmZShcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAnZmFpbGVkJyxcbiAgICAgICAgICAgIGpvYixcbiAgICAgICAgICAgIG5ldyBFcnJvcignam9iIHN0YWxsZWQgbW9yZSB0aGFuIGFsbG93YWJsZSBsaW1pdCcpLFxuICAgICAgICAgICAgJ2FjdGl2ZSdcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgaGFuZGxlU3RhbGxlZEpvYnMgPSBzdGFsbGVkLm1hcChqb2JJZCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpvYkZyb21JZChqb2JJZCkudGhlbihqb2IgPT4ge1xuICAgICAgICAgIC8vIERvIG5vdCBlbWl0IHRoZSBldmVudCBpZiB0aGUgam9iIHdhcyBjb21wbGV0ZWQgYnkgYW5vdGhlciB3b3JrZXJcbiAgICAgICAgICBpZiAoam9iICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnc3RhbGxlZCcsIGpvYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGhhbmRsZUZhaWxlZEpvYnMuY29uY2F0KGhhbmRsZVN0YWxsZWRKb2JzKSk7XG4gICAgfSlcbiAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgIHV0aWxzLmVtaXRTYWZlKFxuICAgICAgICB0aGlzLFxuICAgICAgICAnZXJyb3InLFxuICAgICAgICBlcnIsXG4gICAgICAgICdGYWlsZWQgdG8gaGFuZGxlIHVubG9ja2VkIGpvYiBpbiBhY3RpdmUnXG4gICAgICApO1xuICAgIH0pO1xufTtcblxuUXVldWUucHJvdG90eXBlLnN0YXJ0TW92ZVVubG9ja2VkSm9ic1RvV2FpdCA9IGZ1bmN0aW9uKCkge1xuICBjbGVhckludGVydmFsKHRoaXMubW92ZVVubG9ja2VkSm9ic1RvV2FpdEludGVydmFsKTtcbiAgaWYgKHRoaXMuc2V0dGluZ3Muc3RhbGxlZEludGVydmFsID4gMCAmJiAhdGhpcy5jbG9zaW5nKSB7XG4gICAgdGhpcy5tb3ZlVW5sb2NrZWRKb2JzVG9XYWl0SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgIHRoaXMubW92ZVVubG9ja2VkSm9ic1RvV2FpdCxcbiAgICAgIHRoaXMuc2V0dGluZ3Muc3RhbGxlZEludGVydmFsXG4gICAgKTtcbiAgfVxufTtcblxuLypcbiAgUHJvY2VzcyBqb2JzLiBOb3RlIGxhc3QgYXJndW1lbnQgJ2pvYicgaXMgb3B0aW9uYWwuXG4qL1xuUXVldWUucHJvdG90eXBlLnByb2Nlc3NKb2JzID0gZnVuY3Rpb24oaW5kZXgsIHJlc29sdmUsIGpvYikge1xuICBjb25zdCBwcm9jZXNzSm9icyA9IHRoaXMucHJvY2Vzc0pvYnMuYmluZCh0aGlzLCBpbmRleCwgcmVzb2x2ZSk7XG4gIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgIHRoaXMuX3Byb2Nlc3NKb2JPbk5leHRUaWNrKHByb2Nlc3NKb2JzLCBpbmRleCwgcmVzb2x2ZSwgam9iKTtcbiAgfSk7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3Byb2Nlc3NKb2JPbk5leHRUaWNrID0gZnVuY3Rpb24oXG4gIHByb2Nlc3NKb2JzLFxuICBpbmRleCxcbiAgcmVzb2x2ZSxcbiAgam9iXG4pIHtcbiAgaWYgKCF0aGlzLmNsb3NpbmcpIHtcbiAgICAodGhpcy5wYXVzZWQgfHwgUHJvbWlzZS5yZXNvbHZlKCkpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGdldHRpbmdOZXh0Sm9iID0gam9iID8gUHJvbWlzZS5yZXNvbHZlKGpvYikgOiB0aGlzLmdldE5leHRKb2IoKTtcblxuICAgICAgICByZXR1cm4gKHRoaXMucHJvY2Vzc2luZ1tpbmRleF0gPSBnZXR0aW5nTmV4dEpvYlxuICAgICAgICAgIC50aGVuKHRoaXMucHJvY2Vzc0pvYilcbiAgICAgICAgICAudGhlbihwcm9jZXNzSm9icywgZXJyID0+IHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuY2xvc2luZyAmJiBlcnIubWVzc2FnZSA9PT0gJ0Nvbm5lY3Rpb24gaXMgY2xvc2VkLicpKSB7XG4gICAgICAgICAgICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdlcnJvcicsIGVyciwgJ0Vycm9yIHByb2Nlc3Npbmcgam9iJyk7XG5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gV2FpdCBiZWZvcmUgdHJ5aW5nIHRvIHByb2Nlc3MgYWdhaW4uXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVycm9yUmV0cnlUaW1lcltpbmRleF0pO1xuICAgICAgICAgICAgICB0aGlzLmVycm9yUmV0cnlUaW1lcltpbmRleF0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzSm9icygpO1xuICAgICAgICAgICAgICB9LCB0aGlzLnNldHRpbmdzLnJldHJ5UHJvY2Vzc0RlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0pKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2Vycm9yJywgZXJyLCAnRXJyb3IgcHJvY2Vzc2luZyBqb2InKTtcbiAgICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlc29sdmUodGhpcy5jbG9zaW5nKTtcbiAgfVxufTtcblxuUXVldWUucHJvdG90eXBlLnByb2Nlc3NKb2IgPSBmdW5jdGlvbihqb2IsIG5vdEZldGNoID0gZmFsc2UpIHtcbiAgbGV0IGxvY2tSZW5ld0lkO1xuICBsZXQgdGltZXJTdG9wcGVkID0gZmFsc2U7XG5cbiAgaWYgKCFqb2IpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvL1xuICAvLyBUaGVyZSBhcmUgdHdvIGNhc2VzIHRvIHRha2UgaW50byBjb25zaWRlcmF0aW9uIHJlZ2FyZGluZyBsb2Nrcy5cbiAgLy8gMSkgVGhlIGxvY2sgcmVuZXdlciBmYWlscyB0byByZW5ldyBhIGxvY2ssIHRoaXMgc2hvdWxkIG1ha2UgdGhpcyBqb2JcbiAgLy8gdW5hYmxlIHRvIGNvbXBsZXRlLCBzaW5jZSBzb21lIG90aGVyIHdvcmtlciBpcyBhbHNvIHdvcmtpbmcgb24gaXQuXG4gIC8vIDIpIFRoZSBsb2NrIHJlbmV3ZXIgaXMgY2FsbGVkIG1vcmUgc2VsZG9tIHRoYW4gdGhlIGNoZWNrIGZvciBzdGFsbGVkXG4gIC8vIGpvYnMsIHNvIHdlIGNhbiBhc3N1bWUgdGhlIGpvYiBoYXMgYmVlbiBzdGFsbGVkIGFuZCBpcyBhbHJlYWR5IGJlaW5nIHByb2Nlc3NlZFxuICAvLyBieSBhbm90aGVyIHdvcmtlci4gU2VlICMzMDhcbiAgLy9cbiAgY29uc3QgbG9ja0V4dGVuZGVyID0gKCkgPT4ge1xuICAgIGxvY2tSZW5ld0lkID0gdGhpcy50aW1lcnMuc2V0KFxuICAgICAgJ2xvY2tFeHRlbmRlcicsXG4gICAgICB0aGlzLnNldHRpbmdzLmxvY2tSZW5ld1RpbWUsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHNjcmlwdHNcbiAgICAgICAgICAuZXh0ZW5kTG9jayh0aGlzLCBqb2IuaWQsIHRoaXMuc2V0dGluZ3MubG9ja0R1cmF0aW9uKVxuICAgICAgICAgIC50aGVuKGxvY2sgPT4ge1xuICAgICAgICAgICAgaWYgKGxvY2sgJiYgIXRpbWVyU3RvcHBlZCkge1xuICAgICAgICAgICAgICBsb2NrRXh0ZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2xvY2stZXh0ZW5zaW9uLWZhaWxlZCcsIGpvYiwgZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9O1xuXG4gIGNvbnN0IHRpbWVvdXRNcyA9IGpvYi5vcHRzLnRpbWVvdXQ7XG5cbiAgY29uc3Qgc3RvcFRpbWVyID0gKCkgPT4ge1xuICAgIHRpbWVyU3RvcHBlZCA9IHRydWU7XG4gICAgdGhpcy50aW1lcnMuY2xlYXIobG9ja1JlbmV3SWQpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUNvbXBsZXRlZCA9IHJlc3VsdCA9PiB7XG4gICAgcmV0dXJuIGpvYi5tb3ZlVG9Db21wbGV0ZWQocmVzdWx0LCB1bmRlZmluZWQsIG5vdEZldGNoKS50aGVuKGpvYkRhdGEgPT4ge1xuICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2NvbXBsZXRlZCcsIGpvYiwgcmVzdWx0LCAnYWN0aXZlJyk7XG4gICAgICByZXR1cm4gam9iRGF0YSA/IHRoaXMubmV4dEpvYkZyb21Kb2JEYXRhKGpvYkRhdGFbMF0sIGpvYkRhdGFbMV0pIDogbnVsbDtcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVGYWlsZWQgPSBlcnIgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gZXJyO1xuXG4gICAgcmV0dXJuIGpvYi5tb3ZlVG9GYWlsZWQoZXJyKS50aGVuKGpvYkRhdGEgPT4ge1xuICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2ZhaWxlZCcsIGpvYiwgZXJyb3IsICdhY3RpdmUnKTtcbiAgICAgIHJldHVybiBqb2JEYXRhID8gdGhpcy5uZXh0Sm9iRnJvbUpvYkRhdGEoam9iRGF0YVswXSwgam9iRGF0YVsxXSkgOiBudWxsO1xuICAgIH0pO1xuICB9O1xuXG4gIGxvY2tFeHRlbmRlcigpO1xuICBjb25zdCBoYW5kbGVyID0gdGhpcy5oYW5kbGVyc1tqb2IubmFtZV0gfHwgdGhpcy5oYW5kbGVyc1snKiddO1xuXG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiBoYW5kbGVGYWlsZWQoXG4gICAgICBuZXcgRXJyb3IoJ01pc3NpbmcgcHJvY2VzcyBoYW5kbGVyIGZvciBqb2IgdHlwZSAnICsgam9iLm5hbWUpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgam9iUHJvbWlzZSA9IGhhbmRsZXIoam9iKTtcblxuICAgIGlmICh0aW1lb3V0TXMpIHtcbiAgICAgIGpvYlByb21pc2UgPSBwVGltZW91dChqb2JQcm9taXNlLCB0aW1lb3V0TXMpO1xuICAgIH1cblxuICAgIC8vIExvY2FsIGV2ZW50IHdpdGggam9iUHJvbWlzZSBzbyB0aGF0IHdlIGNhbiBjYW5jZWwgam9iLlxuICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdhY3RpdmUnLCBqb2IsIGpvYlByb21pc2UsICd3YWl0aW5nJyk7XG5cbiAgICByZXR1cm4gam9iUHJvbWlzZVxuICAgICAgLnRoZW4oaGFuZGxlQ29tcGxldGVkKVxuICAgICAgLmNhdGNoKGhhbmRsZUZhaWxlZClcbiAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgc3RvcFRpbWVyKCk7XG4gICAgICB9KTtcbiAgfVxufTtcblxuUXVldWUucHJvdG90eXBlLm11bHRpID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNsaWVudC5tdWx0aSgpO1xufTtcblxuLyoqXG4gIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG5leHQgam9iIGluIHF1ZXVlLlxuKi9cblF1ZXVlLnByb3RvdHlwZS5nZXROZXh0Sm9iID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNsb3NpbmcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICBpZiAodGhpcy5kcmFpbmVkKSB7XG4gICAgLy9cbiAgICAvLyBXYWl0aW5nIGZvciBuZXcgam9icyB0byBhcnJpdmVcbiAgICAvL1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmJjbGllbnQuYmxvY2tlZCA9IHRydWU7XG4gICAgICBjb25zdCBqb2JJZCA9IGF3YWl0IHRoaXMuYmNsaWVudC5icnBvcGxwdXNoKFxuICAgICAgICB0aGlzLmtleXMud2FpdCxcbiAgICAgICAgdGhpcy5rZXlzLmFjdGl2ZSxcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5kcmFpbkRlbGF5XG4gICAgICApO1xuICAgICAgdGhpcy5iY2xpZW50LmJsb2NrZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGpvYklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdmVUb0FjdGl2ZShqb2JJZCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBTd2FsbG93IGVycm9yIGlmIGxvY2FsbHkgcGF1c2VkIHNpbmNlIHdlIGRpZCBmb3JjZSBhIGRpc2Nvbm5lY3Rpb25cbiAgICAgIGlmICghKHRoaXMucGF1c2VkICYmIGVyci5tZXNzYWdlID09PSAnQ29ubmVjdGlvbiBpcyBjbG9zZWQuJykpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlVG9BY3RpdmUoKTtcbiAgfVxufTtcblxuUXVldWUucHJvdG90eXBlLm1vdmVUb0FjdGl2ZSA9IGFzeW5jIGZ1bmN0aW9uKGpvYklkKSB7XG4gIC8vIEZvciBtYW51YWwgcmV0cmlldmluZyBqb2JzIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIHF1ZXVlIHRvIGJlIHJlYWR5LlxuICBhd2FpdCB0aGlzLmlzUmVhZHkoKTtcblxuICByZXR1cm4gc2NyaXB0cy5tb3ZlVG9BY3RpdmUodGhpcywgam9iSWQpLnRoZW4oKFtqb2JEYXRhLCBqb2JJZF0pID0+IHtcbiAgICByZXR1cm4gdGhpcy5uZXh0Sm9iRnJvbUpvYkRhdGEoam9iRGF0YSwgam9iSWQpO1xuICB9KTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5uZXh0Sm9iRnJvbUpvYkRhdGEgPSBmdW5jdGlvbihqb2JEYXRhLCBqb2JJZCkge1xuICBpZiAoam9iRGF0YSkge1xuICAgIHRoaXMuZHJhaW5lZCA9IGZhbHNlO1xuICAgIGNvbnN0IGpvYiA9IEpvYi5mcm9tSlNPTih0aGlzLCBqb2JEYXRhLCBqb2JJZCk7XG4gICAgaWYgKGpvYi5vcHRzLnJlcGVhdCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFJlcGVhdGFibGVKb2Ioam9iLm5hbWUsIGpvYi5kYXRhLCBqb2Iub3B0cykudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBqb2I7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpvYjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRyYWluZWQgPSB0cnVlO1xuICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdkcmFpbmVkJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cblF1ZXVlLnByb3RvdHlwZS5yZXRyeUpvYiA9IGZ1bmN0aW9uKGpvYikge1xuICByZXR1cm4gam9iLnJldHJ5KCk7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUudG9LZXkgPSBmdW5jdGlvbihxdWV1ZVR5cGUpIHtcbiAgcmV0dXJuIFt0aGlzLmtleVByZWZpeCwgdGhpcy5uYW1lLCBxdWV1ZVR5cGVdLmpvaW4oJzonKTtcbn07XG5cbi8qQGZ1bmN0aW9uIGNsZWFuXG4gKlxuICogQ2xlYW5zIGpvYnMgZnJvbSBhIHF1ZXVlLiBTaW1pbGFyIHRvIHJlbW92ZSBidXQga2VlcHMgam9icyB3aXRoaW4gYSBjZXJ0YWluXG4gKiBncmFjZSBwZXJpb2QuXG4gKlxuICogQHBhcmFtIHtpbnR9IGdyYWNlIC0gVGhlIGdyYWNlIHBlcmlvZFxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPWNvbXBsZXRlZF0gLSBUaGUgdHlwZSBvZiBqb2IgdG8gY2xlYW4uIFBvc3NpYmxlIHZhbHVlcyBhcmUgY29tcGxldGVkLCB3YWl0LCBhY3RpdmUsIHBhdXNlZCwgZGVsYXllZCwgZmFpbGVkLiBEZWZhdWx0cyB0byBjb21wbGV0ZWQuXG4gKiBAcGFyYW0ge2ludH0gVGhlIG1heCBudW1iZXIgb2Ygam9icyB0byBjbGVhblxuICovXG5RdWV1ZS5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbihncmFjZSwgdHlwZSwgbGltaXQpIHtcbiAgcmV0dXJuIHRoaXMuaXNSZWFkeSgpLnRoZW4oKCkgPT4ge1xuICAgIGlmIChncmFjZSA9PT0gdW5kZWZpbmVkIHx8IGdyYWNlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGRlZmluZSBhIGdyYWNlIHBlcmlvZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHR5cGUgPSAnY29tcGxldGVkJztcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBfLmluZGV4T2YoXG4gICAgICAgIFsnY29tcGxldGVkJywgJ3dhaXQnLCAnYWN0aXZlJywgJ3BhdXNlZCcsICdkZWxheWVkJywgJ2ZhaWxlZCddLFxuICAgICAgICB0eXBlXG4gICAgICApID09PSAtMVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2xlYW4gdW5rbm93biBxdWV1ZSB0eXBlICcgKyB0eXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NyaXB0c1xuICAgICAgLmNsZWFuSm9ic0luU2V0KHRoaXMsIHR5cGUsIERhdGUubm93KCkgLSBncmFjZSwgbGltaXQpXG4gICAgICAudGhlbihqb2JzID0+IHtcbiAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2NsZWFuZWQnLCBqb2JzLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIGpvYnM7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdlcnJvcicsIGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pO1xuICB9KTtcbn07XG5cbi8qIEBtZXRob2Qgb2JsaXRlcmF0ZVxuICpcbiAqIENvbXBsZXRlbHkgZGVzdHJveXMgdGhlIHF1ZXVlIGFuZCBhbGwgb2YgaXRzIGNvbnRlbnRzIGlycmV2ZXJzaWJseS5cbiAqIFRoaXMgbWV0aG9kIHdpbGwgdGhlICpwYXVzZSogdGhlIHF1ZXVlIGFuZCByZXF1aXJlcyB0aGF0IHRoZXJlIGFyZSBub1xuICogYWN0aXZlIGpvYnMuIEl0IGlzIHBvc3NpYmxlIHRvIGJ5cGFzcyB0aGlzIHJlcXVpcmVtZW50LCBpLmUuIG5vdFxuICogaGF2aW5nIGFjdGl2ZSBqb2JzIHVzaW5nIHRoZSBcImZvcmNlXCIgb3B0aW9uLlxuICpcbiAqIE5vdGU6IFRoaXMgb3BlcmF0aW9uIHJlcXVpcmVzIHRvIGl0ZXJhdGUgb24gYWxsIHRoZSBqb2JzIHN0b3JlZCBpbiB0aGUgcXVldWVcbiAqIGFuZCBjYW4gYmUgc2xvdyBmb3IgdmVyeSBsYXJnZSBxdWV1ZXMuXG4gKlxuICogQHBhcmFtIHsgeyBmb3JjZTogYm9vbGVhbiwgY291bnQ6IG51bWJlciB9fSBvcHRzLiBVc2UgZm9yY2UgPSB0cnVlIHRvIGZvcmNlIG9ibGl0ZXJhdGlvbiBldmVuXG4gKiB3aXRoIGFjdGl2ZSBqb2JzIGluIHRoZSBxdWV1ZS4gIFVzZSBjb3VudCB3aXRoIHRoZSBtYXhpbXVuIG51bWJlciBvZiBkZWxldGVkIGtleXMgcGVyIGl0ZXJhdGlvbixcbiAqIDEwMDAgaXMgdGhlIGRlZmF1bHQuXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5vYmxpdGVyYXRlID0gYXN5bmMgZnVuY3Rpb24ob3B0cykge1xuICBhd2FpdCB0aGlzLnBhdXNlKCk7XG5cbiAgbGV0IGN1cnNvciA9IDA7XG4gIGRvIHtcbiAgICBjdXJzb3IgPSBhd2FpdCBzY3JpcHRzLm9ibGl0ZXJhdGUodGhpcywge1xuICAgICAgZm9yY2U6IGZhbHNlLFxuICAgICAgY291bnQ6IDEwMDAsXG4gICAgICAuLi5vcHRzXG4gICAgfSk7XG4gIH0gd2hpbGUgKGN1cnNvcik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhY3RpdmUgam9icyBhcmUgZmluaXNoZWRcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuUXVldWUucHJvdG90eXBlLndoZW5DdXJyZW50Sm9ic0ZpbmlzaGVkID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5iY2xpZW50SW5pdGlhbGl6ZWQpIHtcbiAgICAvLyBiY2xpZW50IG5vdCB5ZXQgaW5pdGlhbGl6ZWQsIHNvIG5vIGpvYnMgdG8gd2FpdCBmb3JcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvL1xuICAvLyBGb3JjZSByZWNvbm5lY3Rpb24gb2YgYmxvY2tpbmcgY29ubmVjdGlvbiB0byBhYm9ydCBibG9ja2luZyByZWRpcyBjYWxsIGltbWVkaWF0ZWx5LlxuICAvL1xuICBjb25zdCBmb3JjZWRSZWNvbm5lY3Rpb24gPSByZWRpc0NsaWVudERpc2Nvbm5lY3QodGhpcy5iY2xpZW50KS50aGVuKCgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5iY2xpZW50LmNvbm5lY3QoKTtcbiAgfSk7XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXModGhpcy5wcm9jZXNzaW5nKSkudGhlbihcbiAgICAoKSA9PiBmb3JjZWRSZWNvbm5lY3Rpb25cbiAgKTtcbn07XG5cbi8vXG4vLyBQcml2YXRlIGxvY2FsIGZ1bmN0aW9uc1xuLy9cblxuZnVuY3Rpb24gZ2V0UmVkaXNWZXJzaW9uKGNsaWVudCkge1xuICByZXR1cm4gY2xpZW50LmluZm8oKS50aGVuKGRvYyA9PiB7XG4gICAgY29uc3QgcHJlZml4ID0gJ3JlZGlzX3ZlcnNpb246JztcbiAgICBjb25zdCBsaW5lcyA9IGRvYy5zcGxpdCgnXFxyXFxuJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpbmVzW2ldLmluZGV4T2YocHJlZml4KSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbGluZXNbaV0uc3Vic3RyKHByZWZpeC5sZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGpvYklkRm9yR3JvdXAobGltaXRlciwgb3B0cywgZGF0YSkge1xuICBjb25zdCBqb2JJZCA9IG9wdHMgJiYgb3B0cy5qb2JJZDtcbiAgY29uc3QgZ3JvdXBLZXkgPSBfLmdldChsaW1pdGVyLCAnZ3JvdXBLZXknKTtcbiAgaWYgKGdyb3VwS2V5KSB7XG4gICAgcmV0dXJuIGAke2pvYklkIHx8IHV1aWQudjQoKX06JHtfLmdldChkYXRhLCBncm91cEtleSl9YDtcbiAgfVxuICByZXR1cm4gam9iSWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/queue.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/repeatable.js":
/*!*************************************************!*\
  !*** ../../node_modules/bull/lib/repeatable.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../../node_modules/lodash/lodash.js\");\nconst parser = __webpack_require__(/*! cron-parser */ \"(action-browser)/../../node_modules/cron-parser/lib/parser.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst Job = __webpack_require__(/*! ./job */ \"(action-browser)/../../node_modules/bull/lib/job.js\");\n\nmodule.exports = function(Queue) {\n  Queue.prototype.nextRepeatableJob = function(\n    name,\n    data,\n    opts,\n    skipCheckExists\n  ) {\n    const client = this.client;\n    const repeat = opts.repeat;\n    const prevMillis = opts.prevMillis || 0;\n\n    if (!prevMillis && opts.jobId) {\n      repeat.jobId = opts.jobId;\n    }\n\n    const currentCount = repeat.count ? repeat.count + 1 : 1;\n\n    if (!_.isUndefined(repeat.limit) && currentCount > repeat.limit) {\n      return Promise.resolve();\n    }\n\n    let now = Date.now();\n\n    if (!_.isUndefined(repeat.endDate) && now > new Date(repeat.endDate)) {\n      return Promise.resolve();\n    }\n\n    now = prevMillis < now ? now : prevMillis;\n\n    const nextMillis = getNextMillis(now, repeat);\n    if (nextMillis) {\n      const jobId = repeat.jobId ? repeat.jobId + ':' : ':';\n      const repeatKey = getRepeatKey(name, repeat, jobId);\n\n      const createNextJob = () => {\n        return client.zadd(this.keys.repeat, nextMillis, repeatKey).then(() => {\n          //\n          // Generate unique job id for this iteration.\n          //\n          const customId = getRepeatJobId(\n            name,\n            jobId,\n            nextMillis,\n            md5(repeatKey)\n          );\n          now = Date.now();\n          const delay = nextMillis - now;\n\n          return Job.create(\n            this,\n            name,\n            data,\n            _.defaultsDeep(\n              {\n                repeat: {\n                  count: currentCount,\n                  key: repeatKey\n                },\n                jobId: customId,\n                delay: delay < 0 ? 0 : delay,\n                timestamp: now,\n                prevMillis: nextMillis\n              },\n              opts\n            )\n          );\n        });\n      };\n\n      if (skipCheckExists) {\n        return createNextJob();\n      }\n\n      // Check that the repeatable job hasn't been removed\n      // TODO: a lua script would be better here\n      return client\n        .zscore(this.keys.repeat, repeatKey)\n        .then(repeatableExists => {\n          // The job could have been deleted since this check\n          if (repeatableExists) {\n            return createNextJob();\n          }\n          return Promise.resolve();\n        });\n    } else {\n      return Promise.resolve();\n    }\n  };\n\n  Queue.prototype.removeRepeatable = function(name, repeat) {\n    if (typeof name !== 'string') {\n      repeat = name;\n      name = Job.DEFAULT_JOB_NAME;\n    }\n\n    return this.isReady().then(() => {\n      const jobId = repeat.jobId ? repeat.jobId + ':' : ':';\n      const repeatJobKey = getRepeatKey(name, repeat, jobId);\n      const repeatJobId = getRepeatJobId(name, jobId, '', md5(repeatJobKey));\n      const queueKey = this.keys[''];\n      return this.client.removeRepeatable(\n        this.keys.repeat,\n        this.keys.delayed,\n        repeatJobId,\n        repeatJobKey,\n        queueKey\n      );\n    });\n  };\n\n  Queue.prototype.removeRepeatableByKey = function(repeatJobKey) {\n    const repeatMeta = this._keyToData(repeatJobKey);\n    const queueKey = this.keys[''];\n\n    const jobId = repeatMeta.id ? repeatMeta.id + ':' : ':';\n    const repeatJobId = getRepeatJobId(\n      repeatMeta.name || Job.DEFAULT_JOB_NAME,\n      jobId,\n      '',\n      md5(repeatJobKey)\n    );\n\n    return this.isReady().then(() => {\n      return this.client.removeRepeatable(\n        this.keys.repeat,\n        this.keys.delayed,\n        repeatJobId,\n        repeatJobKey,\n        queueKey\n      );\n    });\n  };\n\n  Queue.prototype._keyToData = function(key) {\n    const data = key.split(':');\n\n    return {\n      key: key,\n      name: data[0],\n      id: data[1] || null,\n      endDate: parseInt(data[2]) || null,\n      tz: data[3] || null,\n      cron: data[4]\n    };\n  };\n\n  Queue.prototype.getRepeatableJobs = function(start, end, asc) {\n    const key = this.keys.repeat;\n    start = start || 0;\n    end = end || -1;\n    return (asc\n      ? this.client.zrange(key, start, end, 'WITHSCORES')\n      : this.client.zrevrange(key, start, end, 'WITHSCORES')\n    ).then(result => {\n      const jobs = [];\n      for (let i = 0; i < result.length; i += 2) {\n        const data = this._keyToData(result[i]);\n        jobs.push({\n          key: data.key,\n          name: data.name,\n          id: data.id,\n          endDate: data.endDate,\n          tz: data.cron ? data.tz : null,\n          cron: data.cron || null,\n          every: !data.cron ? parseInt(data.tz) : null,\n          next: parseInt(result[i + 1])\n        });\n      }\n      return jobs;\n    });\n  };\n\n  Queue.prototype.getRepeatableCount = function() {\n    return this.client.zcard(this.toKey('repeat'));\n  };\n\n  function getRepeatJobId(name, jobId, nextMillis, namespace) {\n    return 'repeat:' + md5(name + jobId + namespace) + ':' + nextMillis;\n  }\n\n  function getRepeatKey(name, repeat, jobId) {\n    const endDate = repeat.endDate\n      ? new Date(repeat.endDate).getTime() + ':'\n      : ':';\n    const tz = repeat.tz ? repeat.tz + ':' : ':';\n    const suffix = repeat.cron ? tz + repeat.cron : String(repeat.every);\n\n    return name + ':' + jobId + endDate + suffix;\n  }\n\n  function getNextMillis(millis, opts) {\n    if (opts.cron && opts.every) {\n      throw new Error(\n        'Both .cron and .every options are defined for this repeatable job'\n      );\n    }\n\n    if (opts.every) {\n      return Math.floor(millis / opts.every) * opts.every + opts.every;\n    }\n\n    const currentDate =\n      opts.startDate && new Date(opts.startDate) > new Date(millis)\n        ? new Date(opts.startDate)\n        : new Date(millis);\n    const interval = parser.parseExpression(\n      opts.cron,\n      _.defaults(\n        {\n          currentDate\n        },\n        opts\n      )\n    );\n\n    try {\n      return interval.next().getTime();\n    } catch (e) {\n      // Ignore error\n    }\n  }\n\n  function md5(str) {\n    return crypto\n      .createHash('md5')\n      .update(str)\n      .digest('hex');\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcmVwZWF0YWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLG1CQUFPLENBQUMsb0VBQVE7QUFDMUIsZUFBZSxtQkFBTyxDQUFDLGtGQUFhO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0IsWUFBWSxtQkFBTyxDQUFDLGtFQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcmVwZWF0YWJsZS5qcz81NmU3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgcGFyc2VyID0gcmVxdWlyZSgnY3Jvbi1wYXJzZXInKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBKb2IgPSByZXF1aXJlKCcuL2pvYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFF1ZXVlKSB7XG4gIFF1ZXVlLnByb3RvdHlwZS5uZXh0UmVwZWF0YWJsZUpvYiA9IGZ1bmN0aW9uKFxuICAgIG5hbWUsXG4gICAgZGF0YSxcbiAgICBvcHRzLFxuICAgIHNraXBDaGVja0V4aXN0c1xuICApIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCByZXBlYXQgPSBvcHRzLnJlcGVhdDtcbiAgICBjb25zdCBwcmV2TWlsbGlzID0gb3B0cy5wcmV2TWlsbGlzIHx8IDA7XG5cbiAgICBpZiAoIXByZXZNaWxsaXMgJiYgb3B0cy5qb2JJZCkge1xuICAgICAgcmVwZWF0LmpvYklkID0gb3B0cy5qb2JJZDtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50Q291bnQgPSByZXBlYXQuY291bnQgPyByZXBlYXQuY291bnQgKyAxIDogMTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChyZXBlYXQubGltaXQpICYmIGN1cnJlbnRDb3VudCA+IHJlcGVhdC5saW1pdCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHJlcGVhdC5lbmREYXRlKSAmJiBub3cgPiBuZXcgRGF0ZShyZXBlYXQuZW5kRGF0ZSkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICBub3cgPSBwcmV2TWlsbGlzIDwgbm93ID8gbm93IDogcHJldk1pbGxpcztcblxuICAgIGNvbnN0IG5leHRNaWxsaXMgPSBnZXROZXh0TWlsbGlzKG5vdywgcmVwZWF0KTtcbiAgICBpZiAobmV4dE1pbGxpcykge1xuICAgICAgY29uc3Qgam9iSWQgPSByZXBlYXQuam9iSWQgPyByZXBlYXQuam9iSWQgKyAnOicgOiAnOic7XG4gICAgICBjb25zdCByZXBlYXRLZXkgPSBnZXRSZXBlYXRLZXkobmFtZSwgcmVwZWF0LCBqb2JJZCk7XG5cbiAgICAgIGNvbnN0IGNyZWF0ZU5leHRKb2IgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBjbGllbnQuemFkZCh0aGlzLmtleXMucmVwZWF0LCBuZXh0TWlsbGlzLCByZXBlYXRLZXkpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gR2VuZXJhdGUgdW5pcXVlIGpvYiBpZCBmb3IgdGhpcyBpdGVyYXRpb24uXG4gICAgICAgICAgLy9cbiAgICAgICAgICBjb25zdCBjdXN0b21JZCA9IGdldFJlcGVhdEpvYklkKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGpvYklkLFxuICAgICAgICAgICAgbmV4dE1pbGxpcyxcbiAgICAgICAgICAgIG1kNShyZXBlYXRLZXkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gbmV4dE1pbGxpcyAtIG5vdztcblxuICAgICAgICAgIHJldHVybiBKb2IuY3JlYXRlKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgXy5kZWZhdWx0c0RlZXAoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXBlYXQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvdW50OiBjdXJyZW50Q291bnQsXG4gICAgICAgICAgICAgICAgICBrZXk6IHJlcGVhdEtleVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgam9iSWQ6IGN1c3RvbUlkLFxuICAgICAgICAgICAgICAgIGRlbGF5OiBkZWxheSA8IDAgPyAwIDogZGVsYXksXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBub3csXG4gICAgICAgICAgICAgICAgcHJldk1pbGxpczogbmV4dE1pbGxpc1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoc2tpcENoZWNrRXhpc3RzKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVOZXh0Sm9iKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHJlcGVhdGFibGUgam9iIGhhc24ndCBiZWVuIHJlbW92ZWRcbiAgICAgIC8vIFRPRE86IGEgbHVhIHNjcmlwdCB3b3VsZCBiZSBiZXR0ZXIgaGVyZVxuICAgICAgcmV0dXJuIGNsaWVudFxuICAgICAgICAuenNjb3JlKHRoaXMua2V5cy5yZXBlYXQsIHJlcGVhdEtleSlcbiAgICAgICAgLnRoZW4ocmVwZWF0YWJsZUV4aXN0cyA9PiB7XG4gICAgICAgICAgLy8gVGhlIGpvYiBjb3VsZCBoYXZlIGJlZW4gZGVsZXRlZCBzaW5jZSB0aGlzIGNoZWNrXG4gICAgICAgICAgaWYgKHJlcGVhdGFibGVFeGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXh0Sm9iKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLnJlbW92ZVJlcGVhdGFibGUgPSBmdW5jdGlvbihuYW1lLCByZXBlYXQpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXBlYXQgPSBuYW1lO1xuICAgICAgbmFtZSA9IEpvYi5ERUZBVUxUX0pPQl9OQU1FO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlzUmVhZHkoKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IGpvYklkID0gcmVwZWF0LmpvYklkID8gcmVwZWF0LmpvYklkICsgJzonIDogJzonO1xuICAgICAgY29uc3QgcmVwZWF0Sm9iS2V5ID0gZ2V0UmVwZWF0S2V5KG5hbWUsIHJlcGVhdCwgam9iSWQpO1xuICAgICAgY29uc3QgcmVwZWF0Sm9iSWQgPSBnZXRSZXBlYXRKb2JJZChuYW1lLCBqb2JJZCwgJycsIG1kNShyZXBlYXRKb2JLZXkpKTtcbiAgICAgIGNvbnN0IHF1ZXVlS2V5ID0gdGhpcy5rZXlzWycnXTtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZW1vdmVSZXBlYXRhYmxlKFxuICAgICAgICB0aGlzLmtleXMucmVwZWF0LFxuICAgICAgICB0aGlzLmtleXMuZGVsYXllZCxcbiAgICAgICAgcmVwZWF0Sm9iSWQsXG4gICAgICAgIHJlcGVhdEpvYktleSxcbiAgICAgICAgcXVldWVLZXlcbiAgICAgICk7XG4gICAgfSk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLnJlbW92ZVJlcGVhdGFibGVCeUtleSA9IGZ1bmN0aW9uKHJlcGVhdEpvYktleSkge1xuICAgIGNvbnN0IHJlcGVhdE1ldGEgPSB0aGlzLl9rZXlUb0RhdGEocmVwZWF0Sm9iS2V5KTtcbiAgICBjb25zdCBxdWV1ZUtleSA9IHRoaXMua2V5c1snJ107XG5cbiAgICBjb25zdCBqb2JJZCA9IHJlcGVhdE1ldGEuaWQgPyByZXBlYXRNZXRhLmlkICsgJzonIDogJzonO1xuICAgIGNvbnN0IHJlcGVhdEpvYklkID0gZ2V0UmVwZWF0Sm9iSWQoXG4gICAgICByZXBlYXRNZXRhLm5hbWUgfHwgSm9iLkRFRkFVTFRfSk9CX05BTUUsXG4gICAgICBqb2JJZCxcbiAgICAgICcnLFxuICAgICAgbWQ1KHJlcGVhdEpvYktleSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuaXNSZWFkeSgpLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlbW92ZVJlcGVhdGFibGUoXG4gICAgICAgIHRoaXMua2V5cy5yZXBlYXQsXG4gICAgICAgIHRoaXMua2V5cy5kZWxheWVkLFxuICAgICAgICByZXBlYXRKb2JJZCxcbiAgICAgICAgcmVwZWF0Sm9iS2V5LFxuICAgICAgICBxdWV1ZUtleVxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUuX2tleVRvRGF0YSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGNvbnN0IGRhdGEgPSBrZXkuc3BsaXQoJzonKTtcblxuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIG5hbWU6IGRhdGFbMF0sXG4gICAgICBpZDogZGF0YVsxXSB8fCBudWxsLFxuICAgICAgZW5kRGF0ZTogcGFyc2VJbnQoZGF0YVsyXSkgfHwgbnVsbCxcbiAgICAgIHR6OiBkYXRhWzNdIHx8IG51bGwsXG4gICAgICBjcm9uOiBkYXRhWzRdXG4gICAgfTtcbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUuZ2V0UmVwZWF0YWJsZUpvYnMgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBhc2MpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmtleXMucmVwZWF0O1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBlbmQgPSBlbmQgfHwgLTE7XG4gICAgcmV0dXJuIChhc2NcbiAgICAgID8gdGhpcy5jbGllbnQuenJhbmdlKGtleSwgc3RhcnQsIGVuZCwgJ1dJVEhTQ09SRVMnKVxuICAgICAgOiB0aGlzLmNsaWVudC56cmV2cmFuZ2Uoa2V5LCBzdGFydCwgZW5kLCAnV0lUSFNDT1JFUycpXG4gICAgKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCBqb2JzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fa2V5VG9EYXRhKHJlc3VsdFtpXSk7XG4gICAgICAgIGpvYnMucHVzaCh7XG4gICAgICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgZW5kRGF0ZTogZGF0YS5lbmREYXRlLFxuICAgICAgICAgIHR6OiBkYXRhLmNyb24gPyBkYXRhLnR6IDogbnVsbCxcbiAgICAgICAgICBjcm9uOiBkYXRhLmNyb24gfHwgbnVsbCxcbiAgICAgICAgICBldmVyeTogIWRhdGEuY3JvbiA/IHBhcnNlSW50KGRhdGEudHopIDogbnVsbCxcbiAgICAgICAgICBuZXh0OiBwYXJzZUludChyZXN1bHRbaSArIDFdKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBqb2JzO1xuICAgIH0pO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRSZXBlYXRhYmxlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuemNhcmQodGhpcy50b0tleSgncmVwZWF0JykpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFJlcGVhdEpvYklkKG5hbWUsIGpvYklkLCBuZXh0TWlsbGlzLCBuYW1lc3BhY2UpIHtcbiAgICByZXR1cm4gJ3JlcGVhdDonICsgbWQ1KG5hbWUgKyBqb2JJZCArIG5hbWVzcGFjZSkgKyAnOicgKyBuZXh0TWlsbGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmVwZWF0S2V5KG5hbWUsIHJlcGVhdCwgam9iSWQpIHtcbiAgICBjb25zdCBlbmREYXRlID0gcmVwZWF0LmVuZERhdGVcbiAgICAgID8gbmV3IERhdGUocmVwZWF0LmVuZERhdGUpLmdldFRpbWUoKSArICc6J1xuICAgICAgOiAnOic7XG4gICAgY29uc3QgdHogPSByZXBlYXQudHogPyByZXBlYXQudHogKyAnOicgOiAnOic7XG4gICAgY29uc3Qgc3VmZml4ID0gcmVwZWF0LmNyb24gPyB0eiArIHJlcGVhdC5jcm9uIDogU3RyaW5nKHJlcGVhdC5ldmVyeSk7XG5cbiAgICByZXR1cm4gbmFtZSArICc6JyArIGpvYklkICsgZW5kRGF0ZSArIHN1ZmZpeDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5leHRNaWxsaXMobWlsbGlzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMuY3JvbiAmJiBvcHRzLmV2ZXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdCb3RoIC5jcm9uIGFuZCAuZXZlcnkgb3B0aW9ucyBhcmUgZGVmaW5lZCBmb3IgdGhpcyByZXBlYXRhYmxlIGpvYidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZXZlcnkpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKG1pbGxpcyAvIG9wdHMuZXZlcnkpICogb3B0cy5ldmVyeSArIG9wdHMuZXZlcnk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudERhdGUgPVxuICAgICAgb3B0cy5zdGFydERhdGUgJiYgbmV3IERhdGUob3B0cy5zdGFydERhdGUpID4gbmV3IERhdGUobWlsbGlzKVxuICAgICAgICA/IG5ldyBEYXRlKG9wdHMuc3RhcnREYXRlKVxuICAgICAgICA6IG5ldyBEYXRlKG1pbGxpcyk7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKFxuICAgICAgb3B0cy5jcm9uLFxuICAgICAgXy5kZWZhdWx0cyhcbiAgICAgICAge1xuICAgICAgICAgIGN1cnJlbnREYXRlXG4gICAgICAgIH0sXG4gICAgICAgIG9wdHNcbiAgICAgIClcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBpbnRlcnZhbC5uZXh0KCkuZ2V0VGltZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElnbm9yZSBlcnJvclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1kNShzdHIpIHtcbiAgICByZXR1cm4gY3J5cHRvXG4gICAgICAuY3JlYXRlSGFzaCgnbWQ1JylcbiAgICAgIC51cGRhdGUoc3RyKVxuICAgICAgLmRpZ2VzdCgnaGV4Jyk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/repeatable.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts.js":
/*!**********************************************!*\
  !*** ../../node_modules/bull/lib/scripts.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Includes all the scripts needed by the queue and jobs.\n */\n\n\n\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../../node_modules/lodash/lodash.js\");\nconst msgpackr = __webpack_require__(/*! msgpackr */ \"(action-browser)/../../node_modules/msgpackr/dist/node.cjs\");\n\nconst packer = new msgpackr.Packr({\n  useRecords: false,\n  encodeUndefinedAsNil: true\n});\n\nconst pack = packer.pack;\n\nconst scripts = {\n  isJobInList(client, listKey, jobId) {\n    return client.isJobInList([listKey, jobId]).then(result => {\n      return result === 1;\n    });\n  },\n\n  addJob(client, queue, job, opts) {\n    const queueKeys = queue.keys;\n    let keys = [\n      queueKeys.wait,\n      queueKeys.paused,\n      queueKeys['meta-paused'],\n      queueKeys.id,\n      queueKeys.delayed,\n      queueKeys.priority\n    ];\n\n    const args = [\n      queueKeys[''],\n      _.isUndefined(opts.customJobId) ? '' : opts.customJobId,\n      job.name,\n      job.data,\n      pack(job.opts),\n      job.timestamp,\n      job.delay,\n      job.delay ? job.timestamp + job.delay : 0,\n      opts.priority || 0,\n      opts.lifo ? 'RPUSH' : 'LPUSH',\n      queue.token,\n      job.debounceId ? `${queueKeys.de}:${job.debounceId}` : null,\n      opts.debounce ? opts.debounce.id : null,\n      opts.debounce ? opts.debounce.ttl : null,\n    ];\n    keys = keys.concat(args);\n    return client.addJob(keys);\n  },\n\n  pause(queue, pause) {\n    let src = 'wait',\n      dst = 'paused';\n    if (!pause) {\n      src = 'paused';\n      dst = 'wait';\n    }\n\n    const keys = _.map(\n      [src, dst, 'meta-paused', pause ? 'paused' : 'resumed', 'meta'],\n      name => {\n        return queue.toKey(name);\n      }\n    );\n\n    return queue.client.pause(keys.concat([pause ? 'paused' : 'resumed']));\n  },\n\n  async addLog(queue, jobId, logRow, keepLogs) {\n    const client = await queue.client;\n\n    const keys = [queue.toKey(jobId), queue.toKey(jobId) + ':logs'];\n\n    const result = await client.addLog(\n      keys.concat([jobId, logRow, keepLogs ? keepLogs : ''])\n    );\n\n    if (result < 0) {\n      throw scripts.finishedErrors(result, jobId, 'addLog');\n    }\n\n    return result;\n  },\n\n  getCountsPerPriorityArgs(queue, priorities) {\n    const keys = [\n      queue.keys.wait,\n      queue.keys.paused,\n      queue.keys['meta-paused'],\n      queue.keys.priority\n    ];\n\n    const args = priorities;\n\n    return keys.concat(args);\n  },\n\n  async getCountsPerPriority(queue, priorities) {\n    const client = await queue.client;\n    const args = this.getCountsPerPriorityArgs(queue, priorities);\n\n    return client.getCountsPerPriority(args);\n  },\n\n  moveToActive(queue, jobId) {\n    const queueKeys = queue.keys;\n    const keys = [queueKeys.wait, queueKeys.active, queueKeys.priority];\n\n    keys[3] = keys[1] + '@' + queue.token;\n    keys[4] = queueKeys.stalled;\n    keys[5] = queueKeys.limiter;\n    keys[6] = queueKeys.delayed;\n    keys[7] = queueKeys.drained;\n\n    const args = [\n      queueKeys[''],\n      queue.token,\n      queue.settings.lockDuration,\n      Date.now(),\n      jobId\n    ];\n\n    if (queue.limiter) {\n      args.push(\n        queue.limiter.max,\n        queue.limiter.duration,\n        !!queue.limiter.bounceBack\n      );\n      queue.limiter.groupKey && args.push(true);\n    }\n\n    return queue.client.moveToActive(keys.concat(args)).then(raw2jobData);\n  },\n\n  updateProgress(job, progress) {\n    const queue = job.queue;\n    const keys = [job.id, 'progress'].map(name => {\n      return queue.toKey(name);\n    });\n\n    const progressJson = JSON.stringify(progress);\n    return queue.client\n      .updateProgress(keys, [\n        progressJson,\n        JSON.stringify({ jobId: job.id, progress })\n      ])\n      .then(code => {\n        if (code < 0) {\n          throw scripts.finishedErrors(code, job.id, 'updateProgress');\n        }\n        queue.emit('progress', job, progress);\n      });\n  },\n\n  updateData(job, data) {\n    const queue = job.queue;\n    const keys = [job.id].map(name => {\n      return queue.toKey(name);\n    });\n    const dataJson = JSON.stringify(data);\n\n    return queue.client.updateData(keys, [dataJson]);\n  },\n\n  saveStacktraceArgs(\n    job,\n    stacktrace,\n    failedReason\n  ) {\n    const queue = job.queue;\n\n    const keys = [queue.toKey(job.id)];\n\n    return keys.concat([stacktrace, failedReason, job.attemptsMade]);\n  },\n\n  retryJobsArgs(queue, count) {\n    const keys = [\n      queue.toKey(''),\n      queue.toKey('failed'),\n      queue.toKey('wait'),\n      queue.toKey('meta-paused'),\n      queue.toKey('paused')\n    ];\n\n    const args = [count];\n\n    return keys.concat(args);\n  },\n\n  async retryJobs(queue, count = 1000) {\n    const client = await queue.client;\n\n    const args = this.retryJobsArgs(queue, count);\n\n    return client.retryJobs(args);\n  },\n\n  moveToFinishedArgs(\n    job,\n    val,\n    propVal,\n    shouldRemove,\n    target,\n    ignoreLock,\n    notFetch\n  ) {\n    const queue = job.queue;\n    const queueKeys = queue.keys;\n\n    const metricsKey = queue.toKey(`metrics:${target}`);\n\n    const keys = [\n      queueKeys.active,\n      queueKeys[target],\n      queue.toKey(job.id),\n      queueKeys.wait,\n      queueKeys.priority,\n      queueKeys.active + '@' + queue.token,\n      queueKeys.delayed,\n      queueKeys.stalled,\n      metricsKey\n    ];\n\n    const keepJobs = pack(\n      typeof shouldRemove === 'object'\n        ? shouldRemove\n        : typeof shouldRemove === 'number'\n        ? { count: shouldRemove }\n        : { count: shouldRemove ? 0 : -1 }\n    );\n\n    const args = [\n      job.id,\n      job.finishedOn,\n      propVal,\n      _.isUndefined(val) ? 'null' : val,\n      ignoreLock ? '0' : queue.token,\n      keepJobs,\n      JSON.stringify({ jobId: job.id, val: val }),\n      notFetch || queue.paused || queue.closing || queue.limiter ? 0 : 1,\n      queueKeys[''],\n      queue.settings.lockDuration,\n      queue.token,\n      queue.metrics && queue.metrics.maxDataPoints\n    ];\n\n    return keys.concat(args);\n  },\n\n  moveToFinished(\n    job,\n    val,\n    propVal,\n    shouldRemove,\n    target,\n    ignoreLock,\n    notFetch = false\n  ) {\n    const args = scripts.moveToFinishedArgs(\n      job,\n      val,\n      propVal,\n      shouldRemove,\n      target,\n      ignoreLock,\n      notFetch,\n      job.queue.toKey('')\n    );\n    return job.queue.client.moveToFinished(args).then(result => {\n      if (result < 0) {\n        throw scripts.finishedErrors(result, job.id, 'finished', 'active');\n      } else if (result) {\n        return raw2jobData(result);\n      }\n      return 0;\n    });\n  },\n\n  finishedErrors(code, jobId, command, state) {\n    switch (code) {\n      case -1:\n        return new Error('Missing key for job ' + jobId + ' ' + command);\n      case -2:\n        return new Error('Missing lock for job ' + jobId + ' ' + command);\n      case -3:\n        return new Error(\n          `Job ${jobId} is not in the ${state} state. ${command}`\n        );\n      case -6:\n        return new Error(\n          `Lock mismatch for job ${jobId}. Cmd ${command} from ${state}`\n        );\n    }\n  },\n\n  // TODO: add a retention argument for completed and finished jobs (in time).\n  moveToCompleted(\n    job,\n    returnvalue,\n    removeOnComplete,\n    ignoreLock,\n    notFetch = false\n  ) {\n    return scripts.moveToFinished(\n      job,\n      returnvalue,\n      'returnvalue',\n      removeOnComplete,\n      'completed',\n      ignoreLock,\n      notFetch\n    );\n  },\n\n  moveToFailedArgs(job, failedReason, removeOnFailed, ignoreLock) {\n    return scripts.moveToFinishedArgs(\n      job,\n      failedReason,\n      'failedReason',\n      removeOnFailed,\n      'failed',\n      ignoreLock,\n      true\n    );\n  },\n\n  moveToFailed(job, failedReason, removeOnFailed, ignoreLock) {\n    const args = scripts.moveToFailedArgs(\n      job,\n      failedReason,\n      removeOnFailed,\n      ignoreLock\n    );\n    return scripts.moveToFinished(args);\n  },\n\n  isFinished(job) {\n    const keys = _.map(['completed', 'failed'], key => {\n      return job.queue.toKey(key);\n    });\n\n    return job.queue.client.isFinished(keys.concat([job.id]));\n  },\n\n  moveToDelayedArgs(queue, jobId, timestamp, ignoreLock) {\n    //\n    // Bake in the job id first 12 bits into the timestamp\n    // to guarantee correct execution order of delayed jobs\n    // (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n    //\n    // WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n    //\n    timestamp = _.isUndefined(timestamp) ? 0 : timestamp;\n\n    timestamp = +timestamp || 0;\n    timestamp = timestamp < 0 ? 0 : timestamp;\n    if (timestamp > 0) {\n      timestamp = timestamp * 0x1000 + (jobId & 0xfff);\n    }\n\n    const keys = _.map(['active', 'delayed', jobId, 'stalled'], name => {\n      return queue.toKey(name);\n    });\n    return keys.concat([\n      JSON.stringify(timestamp),\n      jobId,\n      ignoreLock ? '0' : queue.token\n    ]);\n  },\n\n  moveToDelayed(queue, jobId, timestamp, ignoreLock) {\n    const args = scripts.moveToDelayedArgs(queue, jobId, timestamp, ignoreLock);\n    return queue.client.moveToDelayed(args).then(result => {\n      switch (result) {\n        case -1:\n          throw new Error(\n            'Missing Job ' +\n              jobId +\n              ' when trying to move from active to delayed'\n          );\n        case -2:\n          throw new Error(\n            'Job ' +\n              jobId +\n              ' was locked when trying to move from active to delayed'\n          );\n      }\n    });\n  },\n\n  remove(queue, jobId) {\n    const keys = [\n      queue.keys.active,\n      queue.keys.wait,\n      queue.keys.delayed,\n      queue.keys.paused,\n      queue.keys.completed,\n      queue.keys.failed,\n      queue.keys.priority,\n      queue.toKey(jobId),\n      queue.toKey(`${jobId}:logs`),\n      queue.keys.limiter,\n      queue.toKey(''),\n    ];\n    return queue.client.removeJob(keys.concat([jobId, queue.token]));\n  },\n\n  async removeWithPattern(queue, pattern) {\n    const keys = [\n      queue.keys.active,\n      queue.keys.wait,\n      queue.keys.delayed,\n      queue.keys.paused,\n      queue.keys.completed,\n      queue.keys.failed,\n      queue.keys.priority,\n      queue.keys.limiter\n    ];\n\n    const allRemoved = [];\n    let cursor = '0',\n      removed;\n    do {\n      [cursor, removed] = await queue.client.removeJobs(\n        keys.concat([queue.toKey(''), pattern, cursor])\n      );\n      allRemoved.push.apply(allRemoved, removed);\n    } while (cursor !== '0');\n\n    return allRemoved;\n  },\n\n  extendLock(queue, jobId, duration) {\n    return queue.client.extendLock([\n      queue.toKey(jobId) + ':lock',\n      queue.keys.stalled,\n      queue.token,\n      duration,\n      jobId\n    ]);\n  },\n\n  releaseLock(queue, jobId) {\n    return queue.client.releaseLock([\n      queue.toKey(jobId) + ':lock',\n      queue.token\n    ]);\n  },\n\n  takeLock(queue, job) {\n    return queue.client.takeLock([\n      job.lockKey(),\n      queue.token,\n      queue.settings.lockDuration\n    ]);\n  },\n\n  /**\n    It checks if the job in the top of the delay set should be moved back to the\n    top of the  wait queue (so that it will be processed as soon as possible)\n  */\n  updateDelaySet(queue, delayedTimestamp) {\n    const keys = [\n      queue.keys.delayed,\n      queue.keys.active,\n      queue.keys.wait,\n      queue.keys.priority,\n      queue.keys.paused,\n      queue.keys['meta-paused']\n    ];\n\n    const args = [queue.toKey(''), delayedTimestamp, queue.token];\n    return queue.client.updateDelaySet(keys.concat(args));\n  },\n\n  promote(queue, jobId) {\n    const keys = [\n      queue.keys.delayed,\n      queue.keys.wait,\n      queue.keys.paused,\n      queue.keys['meta-paused'],\n      queue.keys.priority\n    ];\n\n    const args = [queue.toKey(''), jobId, queue.token];\n\n    return queue.client.promote(keys.concat(args));\n  },\n\n  /**\n   * Looks for unlocked jobs in the active queue.\n   *\n   *    The job was being worked on, but the worker process died and it failed to renew the lock.\n   *    We call these jobs 'stalled'. This is the most common case. We resolve these by moving them\n   *    back to wait to be re-processed. To prevent jobs from cycling endlessly between active and wait,\n   *    (e.g. if the job handler keeps crashing), we limit the number stalled job recoveries to settings.maxStalledCount.\n   */\n  moveUnlockedJobsToWait(queue) {\n    const keys = [\n      queue.keys.stalled,\n      queue.keys.wait,\n      queue.keys.active,\n      queue.keys.failed,\n      queue.keys['stalled-check'],\n      queue.keys['meta-paused'],\n      queue.keys.paused\n    ];\n    const args = [\n      queue.settings.maxStalledCount,\n      queue.toKey(''),\n      Date.now(),\n      queue.settings.stalledInterval\n    ];\n    return queue.client.moveStalledJobsToWait(keys.concat(args));\n  },\n\n  cleanJobsInSet(queue, set, ts, limit) {\n    return queue.client.cleanJobsInSet([\n      queue.toKey(set),\n      queue.toKey('priority'),\n      queue.keys.limiter,\n      queue.toKey(''),\n      ts,\n      limit || 0,\n      set\n    ]);\n  },\n\n  retryJobArgs(job, ignoreLock) {\n    const queue = job.queue;\n    const jobId = job.id;\n\n    const keys = _.map(\n      ['active', 'wait', jobId, 'meta-paused', 'paused', 'stalled', 'priority'],\n      name => {\n        return queue.toKey(name);\n      }\n    );\n\n    const pushCmd = (job.opts.lifo ? 'R' : 'L') + 'PUSH';\n\n    return keys.concat([pushCmd, jobId, ignoreLock ? '0' : job.queue.token]);\n  },\n\n  /**\n   * Attempts to reprocess a job\n   *\n   * @param {Job} job\n   * @param {Object} options\n   * @param {String} options.state The expected job state. If the job is not found\n   * on the provided state, then it's not reprocessed. Supported states: 'failed', 'completed'\n   *\n   * @return {Promise<Number>} Returns a promise that evaluates to a return code:\n   * 1 means the operation was a success\n   * 0 means the job does not exist\n   * -1 means the job is currently locked and can't be retried.\n   * -2 means the job was not found in the expected set\n   */\n  reprocessJob(job, options) {\n    const queue = job.queue;\n\n    const keys = [\n      queue.toKey(job.id),\n      queue.toKey(job.id) + ':lock',\n      queue.toKey(options.state),\n      queue.toKey('wait'),\n      queue.toKey('meta-paused'),\n      queue.toKey('paused')\n    ];\n\n    const args = [\n      job.id,\n      (job.opts.lifo ? 'R' : 'L') + 'PUSH',\n      queue.token,\n      Date.now()\n    ];\n\n    return queue.client.reprocessJob(keys.concat(args));\n  },\n\n  obliterate(queue, opts) {\n    const client = queue.client;\n\n    const keys = [queue.keys['meta-paused'], queue.toKey('')];\n    const args = [opts.count, opts.force ? 'force' : null];\n\n    return client.obliterate(keys.concat(args)).then(result => {\n      if (result < 0) {\n        switch (result) {\n          case -1:\n            throw new Error('Cannot obliterate non-paused queue');\n          case -2:\n            throw new Error('Cannot obliterate queue with active jobs');\n        }\n      }\n      return result;\n    });\n  }\n};\n\nmodule.exports = scripts;\n\nfunction array2obj(arr) {\n  const obj = {};\n  for (let i = 0; i < arr.length; i += 2) {\n    obj[arr[i]] = arr[i + 1];\n  }\n  return obj;\n}\n\nfunction raw2jobData(raw) {\n  if (raw) {\n    const jobData = raw[0];\n    if (jobData.length) {\n      const job = array2obj(jobData);\n      return [job, raw[1]];\n    }\n  }\n  return [];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLG9FQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFVOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWEsR0FBRyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyxnQkFBZ0IsT0FBTyxTQUFTLFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU0sUUFBUSxTQUFTLE9BQU8sTUFBTTtBQUN2RTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMuanM/YzZjMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEluY2x1ZGVzIGFsbCB0aGUgc2NyaXB0cyBuZWVkZWQgYnkgdGhlIHF1ZXVlIGFuZCBqb2JzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgbXNncGFja3IgPSByZXF1aXJlKCdtc2dwYWNrcicpO1xuXG5jb25zdCBwYWNrZXIgPSBuZXcgbXNncGFja3IuUGFja3Ioe1xuICB1c2VSZWNvcmRzOiBmYWxzZSxcbiAgZW5jb2RlVW5kZWZpbmVkQXNOaWw6IHRydWVcbn0pO1xuXG5jb25zdCBwYWNrID0gcGFja2VyLnBhY2s7XG5cbmNvbnN0IHNjcmlwdHMgPSB7XG4gIGlzSm9iSW5MaXN0KGNsaWVudCwgbGlzdEtleSwgam9iSWQpIHtcbiAgICByZXR1cm4gY2xpZW50LmlzSm9iSW5MaXN0KFtsaXN0S2V5LCBqb2JJZF0pLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IDE7XG4gICAgfSk7XG4gIH0sXG5cbiAgYWRkSm9iKGNsaWVudCwgcXVldWUsIGpvYiwgb3B0cykge1xuICAgIGNvbnN0IHF1ZXVlS2V5cyA9IHF1ZXVlLmtleXM7XG4gICAgbGV0IGtleXMgPSBbXG4gICAgICBxdWV1ZUtleXMud2FpdCxcbiAgICAgIHF1ZXVlS2V5cy5wYXVzZWQsXG4gICAgICBxdWV1ZUtleXNbJ21ldGEtcGF1c2VkJ10sXG4gICAgICBxdWV1ZUtleXMuaWQsXG4gICAgICBxdWV1ZUtleXMuZGVsYXllZCxcbiAgICAgIHF1ZXVlS2V5cy5wcmlvcml0eVxuICAgIF07XG5cbiAgICBjb25zdCBhcmdzID0gW1xuICAgICAgcXVldWVLZXlzWycnXSxcbiAgICAgIF8uaXNVbmRlZmluZWQob3B0cy5jdXN0b21Kb2JJZCkgPyAnJyA6IG9wdHMuY3VzdG9tSm9iSWQsXG4gICAgICBqb2IubmFtZSxcbiAgICAgIGpvYi5kYXRhLFxuICAgICAgcGFjayhqb2Iub3B0cyksXG4gICAgICBqb2IudGltZXN0YW1wLFxuICAgICAgam9iLmRlbGF5LFxuICAgICAgam9iLmRlbGF5ID8gam9iLnRpbWVzdGFtcCArIGpvYi5kZWxheSA6IDAsXG4gICAgICBvcHRzLnByaW9yaXR5IHx8IDAsXG4gICAgICBvcHRzLmxpZm8gPyAnUlBVU0gnIDogJ0xQVVNIJyxcbiAgICAgIHF1ZXVlLnRva2VuLFxuICAgICAgam9iLmRlYm91bmNlSWQgPyBgJHtxdWV1ZUtleXMuZGV9OiR7am9iLmRlYm91bmNlSWR9YCA6IG51bGwsXG4gICAgICBvcHRzLmRlYm91bmNlID8gb3B0cy5kZWJvdW5jZS5pZCA6IG51bGwsXG4gICAgICBvcHRzLmRlYm91bmNlID8gb3B0cy5kZWJvdW5jZS50dGwgOiBudWxsLFxuICAgIF07XG4gICAga2V5cyA9IGtleXMuY29uY2F0KGFyZ3MpO1xuICAgIHJldHVybiBjbGllbnQuYWRkSm9iKGtleXMpO1xuICB9LFxuXG4gIHBhdXNlKHF1ZXVlLCBwYXVzZSkge1xuICAgIGxldCBzcmMgPSAnd2FpdCcsXG4gICAgICBkc3QgPSAncGF1c2VkJztcbiAgICBpZiAoIXBhdXNlKSB7XG4gICAgICBzcmMgPSAncGF1c2VkJztcbiAgICAgIGRzdCA9ICd3YWl0JztcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gXy5tYXAoXG4gICAgICBbc3JjLCBkc3QsICdtZXRhLXBhdXNlZCcsIHBhdXNlID8gJ3BhdXNlZCcgOiAncmVzdW1lZCcsICdtZXRhJ10sXG4gICAgICBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHF1ZXVlLnRvS2V5KG5hbWUpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gcXVldWUuY2xpZW50LnBhdXNlKGtleXMuY29uY2F0KFtwYXVzZSA/ICdwYXVzZWQnIDogJ3Jlc3VtZWQnXSkpO1xuICB9LFxuXG4gIGFzeW5jIGFkZExvZyhxdWV1ZSwgam9iSWQsIGxvZ1Jvdywga2VlcExvZ3MpIHtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBxdWV1ZS5jbGllbnQ7XG5cbiAgICBjb25zdCBrZXlzID0gW3F1ZXVlLnRvS2V5KGpvYklkKSwgcXVldWUudG9LZXkoam9iSWQpICsgJzpsb2dzJ107XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuYWRkTG9nKFxuICAgICAga2V5cy5jb25jYXQoW2pvYklkLCBsb2dSb3csIGtlZXBMb2dzID8ga2VlcExvZ3MgOiAnJ10pXG4gICAgKTtcblxuICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICB0aHJvdyBzY3JpcHRzLmZpbmlzaGVkRXJyb3JzKHJlc3VsdCwgam9iSWQsICdhZGRMb2cnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIGdldENvdW50c1BlclByaW9yaXR5QXJncyhxdWV1ZSwgcHJpb3JpdGllcykge1xuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICBxdWV1ZS5rZXlzLndhaXQsXG4gICAgICBxdWV1ZS5rZXlzLnBhdXNlZCxcbiAgICAgIHF1ZXVlLmtleXNbJ21ldGEtcGF1c2VkJ10sXG4gICAgICBxdWV1ZS5rZXlzLnByaW9yaXR5XG4gICAgXTtcblxuICAgIGNvbnN0IGFyZ3MgPSBwcmlvcml0aWVzO1xuXG4gICAgcmV0dXJuIGtleXMuY29uY2F0KGFyZ3MpO1xuICB9LFxuXG4gIGFzeW5jIGdldENvdW50c1BlclByaW9yaXR5KHF1ZXVlLCBwcmlvcml0aWVzKSB7XG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgcXVldWUuY2xpZW50O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmdldENvdW50c1BlclByaW9yaXR5QXJncyhxdWV1ZSwgcHJpb3JpdGllcyk7XG5cbiAgICByZXR1cm4gY2xpZW50LmdldENvdW50c1BlclByaW9yaXR5KGFyZ3MpO1xuICB9LFxuXG4gIG1vdmVUb0FjdGl2ZShxdWV1ZSwgam9iSWQpIHtcbiAgICBjb25zdCBxdWV1ZUtleXMgPSBxdWV1ZS5rZXlzO1xuICAgIGNvbnN0IGtleXMgPSBbcXVldWVLZXlzLndhaXQsIHF1ZXVlS2V5cy5hY3RpdmUsIHF1ZXVlS2V5cy5wcmlvcml0eV07XG5cbiAgICBrZXlzWzNdID0ga2V5c1sxXSArICdAJyArIHF1ZXVlLnRva2VuO1xuICAgIGtleXNbNF0gPSBxdWV1ZUtleXMuc3RhbGxlZDtcbiAgICBrZXlzWzVdID0gcXVldWVLZXlzLmxpbWl0ZXI7XG4gICAga2V5c1s2XSA9IHF1ZXVlS2V5cy5kZWxheWVkO1xuICAgIGtleXNbN10gPSBxdWV1ZUtleXMuZHJhaW5lZDtcblxuICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICBxdWV1ZUtleXNbJyddLFxuICAgICAgcXVldWUudG9rZW4sXG4gICAgICBxdWV1ZS5zZXR0aW5ncy5sb2NrRHVyYXRpb24sXG4gICAgICBEYXRlLm5vdygpLFxuICAgICAgam9iSWRcbiAgICBdO1xuXG4gICAgaWYgKHF1ZXVlLmxpbWl0ZXIpIHtcbiAgICAgIGFyZ3MucHVzaChcbiAgICAgICAgcXVldWUubGltaXRlci5tYXgsXG4gICAgICAgIHF1ZXVlLmxpbWl0ZXIuZHVyYXRpb24sXG4gICAgICAgICEhcXVldWUubGltaXRlci5ib3VuY2VCYWNrXG4gICAgICApO1xuICAgICAgcXVldWUubGltaXRlci5ncm91cEtleSAmJiBhcmdzLnB1c2godHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXVlLmNsaWVudC5tb3ZlVG9BY3RpdmUoa2V5cy5jb25jYXQoYXJncykpLnRoZW4ocmF3MmpvYkRhdGEpO1xuICB9LFxuXG4gIHVwZGF0ZVByb2dyZXNzKGpvYiwgcHJvZ3Jlc3MpIHtcbiAgICBjb25zdCBxdWV1ZSA9IGpvYi5xdWV1ZTtcbiAgICBjb25zdCBrZXlzID0gW2pvYi5pZCwgJ3Byb2dyZXNzJ10ubWFwKG5hbWUgPT4ge1xuICAgICAgcmV0dXJuIHF1ZXVlLnRvS2V5KG5hbWUpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcHJvZ3Jlc3NKc29uID0gSlNPTi5zdHJpbmdpZnkocHJvZ3Jlc3MpO1xuICAgIHJldHVybiBxdWV1ZS5jbGllbnRcbiAgICAgIC51cGRhdGVQcm9ncmVzcyhrZXlzLCBbXG4gICAgICAgIHByb2dyZXNzSnNvbixcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyBqb2JJZDogam9iLmlkLCBwcm9ncmVzcyB9KVxuICAgICAgXSlcbiAgICAgIC50aGVuKGNvZGUgPT4ge1xuICAgICAgICBpZiAoY29kZSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBzY3JpcHRzLmZpbmlzaGVkRXJyb3JzKGNvZGUsIGpvYi5pZCwgJ3VwZGF0ZVByb2dyZXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWUuZW1pdCgncHJvZ3Jlc3MnLCBqb2IsIHByb2dyZXNzKTtcbiAgICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZURhdGEoam9iLCBkYXRhKSB7XG4gICAgY29uc3QgcXVldWUgPSBqb2IucXVldWU7XG4gICAgY29uc3Qga2V5cyA9IFtqb2IuaWRdLm1hcChuYW1lID0+IHtcbiAgICAgIHJldHVybiBxdWV1ZS50b0tleShuYW1lKTtcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhSnNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXG4gICAgcmV0dXJuIHF1ZXVlLmNsaWVudC51cGRhdGVEYXRhKGtleXMsIFtkYXRhSnNvbl0pO1xuICB9LFxuXG4gIHNhdmVTdGFja3RyYWNlQXJncyhcbiAgICBqb2IsXG4gICAgc3RhY2t0cmFjZSxcbiAgICBmYWlsZWRSZWFzb25cbiAgKSB7XG4gICAgY29uc3QgcXVldWUgPSBqb2IucXVldWU7XG5cbiAgICBjb25zdCBrZXlzID0gW3F1ZXVlLnRvS2V5KGpvYi5pZCldO1xuXG4gICAgcmV0dXJuIGtleXMuY29uY2F0KFtzdGFja3RyYWNlLCBmYWlsZWRSZWFzb24sIGpvYi5hdHRlbXB0c01hZGVdKTtcbiAgfSxcblxuICByZXRyeUpvYnNBcmdzKHF1ZXVlLCBjb3VudCkge1xuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICBxdWV1ZS50b0tleSgnJyksXG4gICAgICBxdWV1ZS50b0tleSgnZmFpbGVkJyksXG4gICAgICBxdWV1ZS50b0tleSgnd2FpdCcpLFxuICAgICAgcXVldWUudG9LZXkoJ21ldGEtcGF1c2VkJyksXG4gICAgICBxdWV1ZS50b0tleSgncGF1c2VkJylcbiAgICBdO1xuXG4gICAgY29uc3QgYXJncyA9IFtjb3VudF07XG5cbiAgICByZXR1cm4ga2V5cy5jb25jYXQoYXJncyk7XG4gIH0sXG5cbiAgYXN5bmMgcmV0cnlKb2JzKHF1ZXVlLCBjb3VudCA9IDEwMDApIHtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBxdWV1ZS5jbGllbnQ7XG5cbiAgICBjb25zdCBhcmdzID0gdGhpcy5yZXRyeUpvYnNBcmdzKHF1ZXVlLCBjb3VudCk7XG5cbiAgICByZXR1cm4gY2xpZW50LnJldHJ5Sm9icyhhcmdzKTtcbiAgfSxcblxuICBtb3ZlVG9GaW5pc2hlZEFyZ3MoXG4gICAgam9iLFxuICAgIHZhbCxcbiAgICBwcm9wVmFsLFxuICAgIHNob3VsZFJlbW92ZSxcbiAgICB0YXJnZXQsXG4gICAgaWdub3JlTG9jayxcbiAgICBub3RGZXRjaFxuICApIHtcbiAgICBjb25zdCBxdWV1ZSA9IGpvYi5xdWV1ZTtcbiAgICBjb25zdCBxdWV1ZUtleXMgPSBxdWV1ZS5rZXlzO1xuXG4gICAgY29uc3QgbWV0cmljc0tleSA9IHF1ZXVlLnRvS2V5KGBtZXRyaWNzOiR7dGFyZ2V0fWApO1xuXG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgIHF1ZXVlS2V5cy5hY3RpdmUsXG4gICAgICBxdWV1ZUtleXNbdGFyZ2V0XSxcbiAgICAgIHF1ZXVlLnRvS2V5KGpvYi5pZCksXG4gICAgICBxdWV1ZUtleXMud2FpdCxcbiAgICAgIHF1ZXVlS2V5cy5wcmlvcml0eSxcbiAgICAgIHF1ZXVlS2V5cy5hY3RpdmUgKyAnQCcgKyBxdWV1ZS50b2tlbixcbiAgICAgIHF1ZXVlS2V5cy5kZWxheWVkLFxuICAgICAgcXVldWVLZXlzLnN0YWxsZWQsXG4gICAgICBtZXRyaWNzS2V5XG4gICAgXTtcblxuICAgIGNvbnN0IGtlZXBKb2JzID0gcGFjayhcbiAgICAgIHR5cGVvZiBzaG91bGRSZW1vdmUgPT09ICdvYmplY3QnXG4gICAgICAgID8gc2hvdWxkUmVtb3ZlXG4gICAgICAgIDogdHlwZW9mIHNob3VsZFJlbW92ZSA9PT0gJ251bWJlcidcbiAgICAgICAgPyB7IGNvdW50OiBzaG91bGRSZW1vdmUgfVxuICAgICAgICA6IHsgY291bnQ6IHNob3VsZFJlbW92ZSA/IDAgOiAtMSB9XG4gICAgKTtcblxuICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICBqb2IuaWQsXG4gICAgICBqb2IuZmluaXNoZWRPbixcbiAgICAgIHByb3BWYWwsXG4gICAgICBfLmlzVW5kZWZpbmVkKHZhbCkgPyAnbnVsbCcgOiB2YWwsXG4gICAgICBpZ25vcmVMb2NrID8gJzAnIDogcXVldWUudG9rZW4sXG4gICAgICBrZWVwSm9icyxcbiAgICAgIEpTT04uc3RyaW5naWZ5KHsgam9iSWQ6IGpvYi5pZCwgdmFsOiB2YWwgfSksXG4gICAgICBub3RGZXRjaCB8fCBxdWV1ZS5wYXVzZWQgfHwgcXVldWUuY2xvc2luZyB8fCBxdWV1ZS5saW1pdGVyID8gMCA6IDEsXG4gICAgICBxdWV1ZUtleXNbJyddLFxuICAgICAgcXVldWUuc2V0dGluZ3MubG9ja0R1cmF0aW9uLFxuICAgICAgcXVldWUudG9rZW4sXG4gICAgICBxdWV1ZS5tZXRyaWNzICYmIHF1ZXVlLm1ldHJpY3MubWF4RGF0YVBvaW50c1xuICAgIF07XG5cbiAgICByZXR1cm4ga2V5cy5jb25jYXQoYXJncyk7XG4gIH0sXG5cbiAgbW92ZVRvRmluaXNoZWQoXG4gICAgam9iLFxuICAgIHZhbCxcbiAgICBwcm9wVmFsLFxuICAgIHNob3VsZFJlbW92ZSxcbiAgICB0YXJnZXQsXG4gICAgaWdub3JlTG9jayxcbiAgICBub3RGZXRjaCA9IGZhbHNlXG4gICkge1xuICAgIGNvbnN0IGFyZ3MgPSBzY3JpcHRzLm1vdmVUb0ZpbmlzaGVkQXJncyhcbiAgICAgIGpvYixcbiAgICAgIHZhbCxcbiAgICAgIHByb3BWYWwsXG4gICAgICBzaG91bGRSZW1vdmUsXG4gICAgICB0YXJnZXQsXG4gICAgICBpZ25vcmVMb2NrLFxuICAgICAgbm90RmV0Y2gsXG4gICAgICBqb2IucXVldWUudG9LZXkoJycpXG4gICAgKTtcbiAgICByZXR1cm4gam9iLnF1ZXVlLmNsaWVudC5tb3ZlVG9GaW5pc2hlZChhcmdzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICBpZiAocmVzdWx0IDwgMCkge1xuICAgICAgICB0aHJvdyBzY3JpcHRzLmZpbmlzaGVkRXJyb3JzKHJlc3VsdCwgam9iLmlkLCAnZmluaXNoZWQnLCAnYWN0aXZlJyk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmF3MmpvYkRhdGEocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICB9LFxuXG4gIGZpbmlzaGVkRXJyb3JzKGNvZGUsIGpvYklkLCBjb21tYW5kLCBzdGF0ZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSAtMTpcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWlzc2luZyBrZXkgZm9yIGpvYiAnICsgam9iSWQgKyAnICcgKyBjb21tYW5kKTtcbiAgICAgIGNhc2UgLTI6XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01pc3NpbmcgbG9jayBmb3Igam9iICcgKyBqb2JJZCArICcgJyArIGNvbW1hbmQpO1xuICAgICAgY2FzZSAtMzpcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgICBgSm9iICR7am9iSWR9IGlzIG5vdCBpbiB0aGUgJHtzdGF0ZX0gc3RhdGUuICR7Y29tbWFuZH1gXG4gICAgICAgICk7XG4gICAgICBjYXNlIC02OlxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAgIGBMb2NrIG1pc21hdGNoIGZvciBqb2IgJHtqb2JJZH0uIENtZCAke2NvbW1hbmR9IGZyb20gJHtzdGF0ZX1gXG4gICAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFRPRE86IGFkZCBhIHJldGVudGlvbiBhcmd1bWVudCBmb3IgY29tcGxldGVkIGFuZCBmaW5pc2hlZCBqb2JzIChpbiB0aW1lKS5cbiAgbW92ZVRvQ29tcGxldGVkKFxuICAgIGpvYixcbiAgICByZXR1cm52YWx1ZSxcbiAgICByZW1vdmVPbkNvbXBsZXRlLFxuICAgIGlnbm9yZUxvY2ssXG4gICAgbm90RmV0Y2ggPSBmYWxzZVxuICApIHtcbiAgICByZXR1cm4gc2NyaXB0cy5tb3ZlVG9GaW5pc2hlZChcbiAgICAgIGpvYixcbiAgICAgIHJldHVybnZhbHVlLFxuICAgICAgJ3JldHVybnZhbHVlJyxcbiAgICAgIHJlbW92ZU9uQ29tcGxldGUsXG4gICAgICAnY29tcGxldGVkJyxcbiAgICAgIGlnbm9yZUxvY2ssXG4gICAgICBub3RGZXRjaFxuICAgICk7XG4gIH0sXG5cbiAgbW92ZVRvRmFpbGVkQXJncyhqb2IsIGZhaWxlZFJlYXNvbiwgcmVtb3ZlT25GYWlsZWQsIGlnbm9yZUxvY2spIHtcbiAgICByZXR1cm4gc2NyaXB0cy5tb3ZlVG9GaW5pc2hlZEFyZ3MoXG4gICAgICBqb2IsXG4gICAgICBmYWlsZWRSZWFzb24sXG4gICAgICAnZmFpbGVkUmVhc29uJyxcbiAgICAgIHJlbW92ZU9uRmFpbGVkLFxuICAgICAgJ2ZhaWxlZCcsXG4gICAgICBpZ25vcmVMb2NrLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH0sXG5cbiAgbW92ZVRvRmFpbGVkKGpvYiwgZmFpbGVkUmVhc29uLCByZW1vdmVPbkZhaWxlZCwgaWdub3JlTG9jaykge1xuICAgIGNvbnN0IGFyZ3MgPSBzY3JpcHRzLm1vdmVUb0ZhaWxlZEFyZ3MoXG4gICAgICBqb2IsXG4gICAgICBmYWlsZWRSZWFzb24sXG4gICAgICByZW1vdmVPbkZhaWxlZCxcbiAgICAgIGlnbm9yZUxvY2tcbiAgICApO1xuICAgIHJldHVybiBzY3JpcHRzLm1vdmVUb0ZpbmlzaGVkKGFyZ3MpO1xuICB9LFxuXG4gIGlzRmluaXNoZWQoam9iKSB7XG4gICAgY29uc3Qga2V5cyA9IF8ubWFwKFsnY29tcGxldGVkJywgJ2ZhaWxlZCddLCBrZXkgPT4ge1xuICAgICAgcmV0dXJuIGpvYi5xdWV1ZS50b0tleShrZXkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGpvYi5xdWV1ZS5jbGllbnQuaXNGaW5pc2hlZChrZXlzLmNvbmNhdChbam9iLmlkXSkpO1xuICB9LFxuXG4gIG1vdmVUb0RlbGF5ZWRBcmdzKHF1ZXVlLCBqb2JJZCwgdGltZXN0YW1wLCBpZ25vcmVMb2NrKSB7XG4gICAgLy9cbiAgICAvLyBCYWtlIGluIHRoZSBqb2IgaWQgZmlyc3QgMTIgYml0cyBpbnRvIHRoZSB0aW1lc3RhbXBcbiAgICAvLyB0byBndWFyYW50ZWUgY29ycmVjdCBleGVjdXRpb24gb3JkZXIgb2YgZGVsYXllZCBqb2JzXG4gICAgLy8gKHVwIHRvIDQwOTYgam9icyBwZXIgZ2l2ZW4gdGltZXN0YW1wIG9yIDQwOTYgam9icyBhcGFydCBwZXIgdGltZXN0YW1wKVxuICAgIC8vXG4gICAgLy8gV0FSTklORzogSm9icyB0aGF0IGFyZSBzbyBmYXIgYXBhcnQgdGhhdCB0aGV5IHdyYXAgYXJvdW5kIHdpbGwgY2F1c2UgRklGTyB0byBmYWlsXG4gICAgLy9cbiAgICB0aW1lc3RhbXAgPSBfLmlzVW5kZWZpbmVkKHRpbWVzdGFtcCkgPyAwIDogdGltZXN0YW1wO1xuXG4gICAgdGltZXN0YW1wID0gK3RpbWVzdGFtcCB8fCAwO1xuICAgIHRpbWVzdGFtcCA9IHRpbWVzdGFtcCA8IDAgPyAwIDogdGltZXN0YW1wO1xuICAgIGlmICh0aW1lc3RhbXAgPiAwKSB7XG4gICAgICB0aW1lc3RhbXAgPSB0aW1lc3RhbXAgKiAweDEwMDAgKyAoam9iSWQgJiAweGZmZik7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IF8ubWFwKFsnYWN0aXZlJywgJ2RlbGF5ZWQnLCBqb2JJZCwgJ3N0YWxsZWQnXSwgbmFtZSA9PiB7XG4gICAgICByZXR1cm4gcXVldWUudG9LZXkobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KFtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHRpbWVzdGFtcCksXG4gICAgICBqb2JJZCxcbiAgICAgIGlnbm9yZUxvY2sgPyAnMCcgOiBxdWV1ZS50b2tlblxuICAgIF0pO1xuICB9LFxuXG4gIG1vdmVUb0RlbGF5ZWQocXVldWUsIGpvYklkLCB0aW1lc3RhbXAsIGlnbm9yZUxvY2spIHtcbiAgICBjb25zdCBhcmdzID0gc2NyaXB0cy5tb3ZlVG9EZWxheWVkQXJncyhxdWV1ZSwgam9iSWQsIHRpbWVzdGFtcCwgaWdub3JlTG9jayk7XG4gICAgcmV0dXJuIHF1ZXVlLmNsaWVudC5tb3ZlVG9EZWxheWVkKGFyZ3MpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIHN3aXRjaCAocmVzdWx0KSB7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ01pc3NpbmcgSm9iICcgK1xuICAgICAgICAgICAgICBqb2JJZCArXG4gICAgICAgICAgICAgICcgd2hlbiB0cnlpbmcgdG8gbW92ZSBmcm9tIGFjdGl2ZSB0byBkZWxheWVkJ1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgLTI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0pvYiAnICtcbiAgICAgICAgICAgICAgam9iSWQgK1xuICAgICAgICAgICAgICAnIHdhcyBsb2NrZWQgd2hlbiB0cnlpbmcgdG8gbW92ZSBmcm9tIGFjdGl2ZSB0byBkZWxheWVkJ1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVtb3ZlKHF1ZXVlLCBqb2JJZCkge1xuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICBxdWV1ZS5rZXlzLmFjdGl2ZSxcbiAgICAgIHF1ZXVlLmtleXMud2FpdCxcbiAgICAgIHF1ZXVlLmtleXMuZGVsYXllZCxcbiAgICAgIHF1ZXVlLmtleXMucGF1c2VkLFxuICAgICAgcXVldWUua2V5cy5jb21wbGV0ZWQsXG4gICAgICBxdWV1ZS5rZXlzLmZhaWxlZCxcbiAgICAgIHF1ZXVlLmtleXMucHJpb3JpdHksXG4gICAgICBxdWV1ZS50b0tleShqb2JJZCksXG4gICAgICBxdWV1ZS50b0tleShgJHtqb2JJZH06bG9nc2ApLFxuICAgICAgcXVldWUua2V5cy5saW1pdGVyLFxuICAgICAgcXVldWUudG9LZXkoJycpLFxuICAgIF07XG4gICAgcmV0dXJuIHF1ZXVlLmNsaWVudC5yZW1vdmVKb2Ioa2V5cy5jb25jYXQoW2pvYklkLCBxdWV1ZS50b2tlbl0pKTtcbiAgfSxcblxuICBhc3luYyByZW1vdmVXaXRoUGF0dGVybihxdWV1ZSwgcGF0dGVybikge1xuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICBxdWV1ZS5rZXlzLmFjdGl2ZSxcbiAgICAgIHF1ZXVlLmtleXMud2FpdCxcbiAgICAgIHF1ZXVlLmtleXMuZGVsYXllZCxcbiAgICAgIHF1ZXVlLmtleXMucGF1c2VkLFxuICAgICAgcXVldWUua2V5cy5jb21wbGV0ZWQsXG4gICAgICBxdWV1ZS5rZXlzLmZhaWxlZCxcbiAgICAgIHF1ZXVlLmtleXMucHJpb3JpdHksXG4gICAgICBxdWV1ZS5rZXlzLmxpbWl0ZXJcbiAgICBdO1xuXG4gICAgY29uc3QgYWxsUmVtb3ZlZCA9IFtdO1xuICAgIGxldCBjdXJzb3IgPSAnMCcsXG4gICAgICByZW1vdmVkO1xuICAgIGRvIHtcbiAgICAgIFtjdXJzb3IsIHJlbW92ZWRdID0gYXdhaXQgcXVldWUuY2xpZW50LnJlbW92ZUpvYnMoXG4gICAgICAgIGtleXMuY29uY2F0KFtxdWV1ZS50b0tleSgnJyksIHBhdHRlcm4sIGN1cnNvcl0pXG4gICAgICApO1xuICAgICAgYWxsUmVtb3ZlZC5wdXNoLmFwcGx5KGFsbFJlbW92ZWQsIHJlbW92ZWQpO1xuICAgIH0gd2hpbGUgKGN1cnNvciAhPT0gJzAnKTtcblxuICAgIHJldHVybiBhbGxSZW1vdmVkO1xuICB9LFxuXG4gIGV4dGVuZExvY2socXVldWUsIGpvYklkLCBkdXJhdGlvbikge1xuICAgIHJldHVybiBxdWV1ZS5jbGllbnQuZXh0ZW5kTG9jayhbXG4gICAgICBxdWV1ZS50b0tleShqb2JJZCkgKyAnOmxvY2snLFxuICAgICAgcXVldWUua2V5cy5zdGFsbGVkLFxuICAgICAgcXVldWUudG9rZW4sXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGpvYklkXG4gICAgXSk7XG4gIH0sXG5cbiAgcmVsZWFzZUxvY2socXVldWUsIGpvYklkKSB7XG4gICAgcmV0dXJuIHF1ZXVlLmNsaWVudC5yZWxlYXNlTG9jayhbXG4gICAgICBxdWV1ZS50b0tleShqb2JJZCkgKyAnOmxvY2snLFxuICAgICAgcXVldWUudG9rZW5cbiAgICBdKTtcbiAgfSxcblxuICB0YWtlTG9jayhxdWV1ZSwgam9iKSB7XG4gICAgcmV0dXJuIHF1ZXVlLmNsaWVudC50YWtlTG9jayhbXG4gICAgICBqb2IubG9ja0tleSgpLFxuICAgICAgcXVldWUudG9rZW4sXG4gICAgICBxdWV1ZS5zZXR0aW5ncy5sb2NrRHVyYXRpb25cbiAgICBdKTtcbiAgfSxcblxuICAvKipcbiAgICBJdCBjaGVja3MgaWYgdGhlIGpvYiBpbiB0aGUgdG9wIG9mIHRoZSBkZWxheSBzZXQgc2hvdWxkIGJlIG1vdmVkIGJhY2sgdG8gdGhlXG4gICAgdG9wIG9mIHRoZSAgd2FpdCBxdWV1ZSAoc28gdGhhdCBpdCB3aWxsIGJlIHByb2Nlc3NlZCBhcyBzb29uIGFzIHBvc3NpYmxlKVxuICAqL1xuICB1cGRhdGVEZWxheVNldChxdWV1ZSwgZGVsYXllZFRpbWVzdGFtcCkge1xuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICBxdWV1ZS5rZXlzLmRlbGF5ZWQsXG4gICAgICBxdWV1ZS5rZXlzLmFjdGl2ZSxcbiAgICAgIHF1ZXVlLmtleXMud2FpdCxcbiAgICAgIHF1ZXVlLmtleXMucHJpb3JpdHksXG4gICAgICBxdWV1ZS5rZXlzLnBhdXNlZCxcbiAgICAgIHF1ZXVlLmtleXNbJ21ldGEtcGF1c2VkJ11cbiAgICBdO1xuXG4gICAgY29uc3QgYXJncyA9IFtxdWV1ZS50b0tleSgnJyksIGRlbGF5ZWRUaW1lc3RhbXAsIHF1ZXVlLnRva2VuXTtcbiAgICByZXR1cm4gcXVldWUuY2xpZW50LnVwZGF0ZURlbGF5U2V0KGtleXMuY29uY2F0KGFyZ3MpKTtcbiAgfSxcblxuICBwcm9tb3RlKHF1ZXVlLCBqb2JJZCkge1xuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICBxdWV1ZS5rZXlzLmRlbGF5ZWQsXG4gICAgICBxdWV1ZS5rZXlzLndhaXQsXG4gICAgICBxdWV1ZS5rZXlzLnBhdXNlZCxcbiAgICAgIHF1ZXVlLmtleXNbJ21ldGEtcGF1c2VkJ10sXG4gICAgICBxdWV1ZS5rZXlzLnByaW9yaXR5XG4gICAgXTtcblxuICAgIGNvbnN0IGFyZ3MgPSBbcXVldWUudG9LZXkoJycpLCBqb2JJZCwgcXVldWUudG9rZW5dO1xuXG4gICAgcmV0dXJuIHF1ZXVlLmNsaWVudC5wcm9tb3RlKGtleXMuY29uY2F0KGFyZ3MpKTtcbiAgfSxcblxuICAvKipcbiAgICogTG9va3MgZm9yIHVubG9ja2VkIGpvYnMgaW4gdGhlIGFjdGl2ZSBxdWV1ZS5cbiAgICpcbiAgICogICAgVGhlIGpvYiB3YXMgYmVpbmcgd29ya2VkIG9uLCBidXQgdGhlIHdvcmtlciBwcm9jZXNzIGRpZWQgYW5kIGl0IGZhaWxlZCB0byByZW5ldyB0aGUgbG9jay5cbiAgICogICAgV2UgY2FsbCB0aGVzZSBqb2JzICdzdGFsbGVkJy4gVGhpcyBpcyB0aGUgbW9zdCBjb21tb24gY2FzZS4gV2UgcmVzb2x2ZSB0aGVzZSBieSBtb3ZpbmcgdGhlbVxuICAgKiAgICBiYWNrIHRvIHdhaXQgdG8gYmUgcmUtcHJvY2Vzc2VkLiBUbyBwcmV2ZW50IGpvYnMgZnJvbSBjeWNsaW5nIGVuZGxlc3NseSBiZXR3ZWVuIGFjdGl2ZSBhbmQgd2FpdCxcbiAgICogICAgKGUuZy4gaWYgdGhlIGpvYiBoYW5kbGVyIGtlZXBzIGNyYXNoaW5nKSwgd2UgbGltaXQgdGhlIG51bWJlciBzdGFsbGVkIGpvYiByZWNvdmVyaWVzIHRvIHNldHRpbmdzLm1heFN0YWxsZWRDb3VudC5cbiAgICovXG4gIG1vdmVVbmxvY2tlZEpvYnNUb1dhaXQocXVldWUpIHtcbiAgICBjb25zdCBrZXlzID0gW1xuICAgICAgcXVldWUua2V5cy5zdGFsbGVkLFxuICAgICAgcXVldWUua2V5cy53YWl0LFxuICAgICAgcXVldWUua2V5cy5hY3RpdmUsXG4gICAgICBxdWV1ZS5rZXlzLmZhaWxlZCxcbiAgICAgIHF1ZXVlLmtleXNbJ3N0YWxsZWQtY2hlY2snXSxcbiAgICAgIHF1ZXVlLmtleXNbJ21ldGEtcGF1c2VkJ10sXG4gICAgICBxdWV1ZS5rZXlzLnBhdXNlZFxuICAgIF07XG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgIHF1ZXVlLnNldHRpbmdzLm1heFN0YWxsZWRDb3VudCxcbiAgICAgIHF1ZXVlLnRvS2V5KCcnKSxcbiAgICAgIERhdGUubm93KCksXG4gICAgICBxdWV1ZS5zZXR0aW5ncy5zdGFsbGVkSW50ZXJ2YWxcbiAgICBdO1xuICAgIHJldHVybiBxdWV1ZS5jbGllbnQubW92ZVN0YWxsZWRKb2JzVG9XYWl0KGtleXMuY29uY2F0KGFyZ3MpKTtcbiAgfSxcblxuICBjbGVhbkpvYnNJblNldChxdWV1ZSwgc2V0LCB0cywgbGltaXQpIHtcbiAgICByZXR1cm4gcXVldWUuY2xpZW50LmNsZWFuSm9ic0luU2V0KFtcbiAgICAgIHF1ZXVlLnRvS2V5KHNldCksXG4gICAgICBxdWV1ZS50b0tleSgncHJpb3JpdHknKSxcbiAgICAgIHF1ZXVlLmtleXMubGltaXRlcixcbiAgICAgIHF1ZXVlLnRvS2V5KCcnKSxcbiAgICAgIHRzLFxuICAgICAgbGltaXQgfHwgMCxcbiAgICAgIHNldFxuICAgIF0pO1xuICB9LFxuXG4gIHJldHJ5Sm9iQXJncyhqb2IsIGlnbm9yZUxvY2spIHtcbiAgICBjb25zdCBxdWV1ZSA9IGpvYi5xdWV1ZTtcbiAgICBjb25zdCBqb2JJZCA9IGpvYi5pZDtcblxuICAgIGNvbnN0IGtleXMgPSBfLm1hcChcbiAgICAgIFsnYWN0aXZlJywgJ3dhaXQnLCBqb2JJZCwgJ21ldGEtcGF1c2VkJywgJ3BhdXNlZCcsICdzdGFsbGVkJywgJ3ByaW9yaXR5J10sXG4gICAgICBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHF1ZXVlLnRvS2V5KG5hbWUpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBjb25zdCBwdXNoQ21kID0gKGpvYi5vcHRzLmxpZm8gPyAnUicgOiAnTCcpICsgJ1BVU0gnO1xuXG4gICAgcmV0dXJuIGtleXMuY29uY2F0KFtwdXNoQ21kLCBqb2JJZCwgaWdub3JlTG9jayA/ICcwJyA6IGpvYi5xdWV1ZS50b2tlbl0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byByZXByb2Nlc3MgYSBqb2JcbiAgICpcbiAgICogQHBhcmFtIHtKb2J9IGpvYlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5zdGF0ZSBUaGUgZXhwZWN0ZWQgam9iIHN0YXRlLiBJZiB0aGUgam9iIGlzIG5vdCBmb3VuZFxuICAgKiBvbiB0aGUgcHJvdmlkZWQgc3RhdGUsIHRoZW4gaXQncyBub3QgcmVwcm9jZXNzZWQuIFN1cHBvcnRlZCBzdGF0ZXM6ICdmYWlsZWQnLCAnY29tcGxldGVkJ1xuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE51bWJlcj59IFJldHVybnMgYSBwcm9taXNlIHRoYXQgZXZhbHVhdGVzIHRvIGEgcmV0dXJuIGNvZGU6XG4gICAqIDEgbWVhbnMgdGhlIG9wZXJhdGlvbiB3YXMgYSBzdWNjZXNzXG4gICAqIDAgbWVhbnMgdGhlIGpvYiBkb2VzIG5vdCBleGlzdFxuICAgKiAtMSBtZWFucyB0aGUgam9iIGlzIGN1cnJlbnRseSBsb2NrZWQgYW5kIGNhbid0IGJlIHJldHJpZWQuXG4gICAqIC0yIG1lYW5zIHRoZSBqb2Igd2FzIG5vdCBmb3VuZCBpbiB0aGUgZXhwZWN0ZWQgc2V0XG4gICAqL1xuICByZXByb2Nlc3NKb2Ioam9iLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVldWUgPSBqb2IucXVldWU7XG5cbiAgICBjb25zdCBrZXlzID0gW1xuICAgICAgcXVldWUudG9LZXkoam9iLmlkKSxcbiAgICAgIHF1ZXVlLnRvS2V5KGpvYi5pZCkgKyAnOmxvY2snLFxuICAgICAgcXVldWUudG9LZXkob3B0aW9ucy5zdGF0ZSksXG4gICAgICBxdWV1ZS50b0tleSgnd2FpdCcpLFxuICAgICAgcXVldWUudG9LZXkoJ21ldGEtcGF1c2VkJyksXG4gICAgICBxdWV1ZS50b0tleSgncGF1c2VkJylcbiAgICBdO1xuXG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgIGpvYi5pZCxcbiAgICAgIChqb2Iub3B0cy5saWZvID8gJ1InIDogJ0wnKSArICdQVVNIJyxcbiAgICAgIHF1ZXVlLnRva2VuLFxuICAgICAgRGF0ZS5ub3coKVxuICAgIF07XG5cbiAgICByZXR1cm4gcXVldWUuY2xpZW50LnJlcHJvY2Vzc0pvYihrZXlzLmNvbmNhdChhcmdzKSk7XG4gIH0sXG5cbiAgb2JsaXRlcmF0ZShxdWV1ZSwgb3B0cykge1xuICAgIGNvbnN0IGNsaWVudCA9IHF1ZXVlLmNsaWVudDtcblxuICAgIGNvbnN0IGtleXMgPSBbcXVldWUua2V5c1snbWV0YS1wYXVzZWQnXSwgcXVldWUudG9LZXkoJycpXTtcbiAgICBjb25zdCBhcmdzID0gW29wdHMuY291bnQsIG9wdHMuZm9yY2UgPyAnZm9yY2UnIDogbnVsbF07XG5cbiAgICByZXR1cm4gY2xpZW50Lm9ibGl0ZXJhdGUoa2V5cy5jb25jYXQoYXJncykpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgIHN3aXRjaCAocmVzdWx0KSB7XG4gICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG9ibGl0ZXJhdGUgbm9uLXBhdXNlZCBxdWV1ZScpO1xuICAgICAgICAgIGNhc2UgLTI6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBvYmxpdGVyYXRlIHF1ZXVlIHdpdGggYWN0aXZlIGpvYnMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzY3JpcHRzO1xuXG5mdW5jdGlvbiBhcnJheTJvYmooYXJyKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMikge1xuICAgIG9ialthcnJbaV1dID0gYXJyW2kgKyAxXTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiByYXcyam9iRGF0YShyYXcpIHtcbiAgaWYgKHJhdykge1xuICAgIGNvbnN0IGpvYkRhdGEgPSByYXdbMF07XG4gICAgaWYgKGpvYkRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCBqb2IgPSBhcnJheTJvYmooam9iRGF0YSk7XG4gICAgICByZXR1cm4gW2pvYiwgcmF3WzFdXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/addJob-6.js":
/*!*******************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/addJob-6.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Adds a job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - if delayed:\n      - computes timestamp.\n      - adds to delayed zset.\n      - Emits a global event 'delayed' if the job is delayed.\n    - if not delayed\n      - Adds the jobId to the wait/paused list in one of three ways:\n         - LIFO\n         - FIFO\n         - prioritized.\n      - Adds the job to the \"added\" list so that workers gets notified.\n    Input:\n      KEYS[1] 'wait',\n      KEYS[2] 'paused'\n      KEYS[3] 'meta-paused'\n      KEYS[4] 'id'\n      KEYS[5] 'delayed'\n      KEYS[6] 'priority'\n      ARGV[1]  key prefix,\n      ARGV[2]  custom id (will not generate one automatically)\n      ARGV[3]  name\n      ARGV[4]  data (json stringified job data)\n      ARGV[5]  opts (json stringified job opts)\n      ARGV[6]  timestamp\n      ARGV[7]  delay\n      ARGV[8]  delayedTimestamp\n      ARGV[9]  priority\n      ARGV[10] LIFO\n      ARGV[11] token\n      ARGV[12] debounce key\n      ARGV[13] debounceId\n      ARGV[14] debounceTtl\n]]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\nlocal function addJobWithPriority(priorityKey, priority, jobId, targetKey)\n  rcall(\"ZADD\", priorityKey, priority, jobId)\n  local count = rcall(\"ZCOUNT\", priorityKey, 0, priority)\n  local len = rcall(\"LLEN\", targetKey)\n  local id = rcall(\"LINDEX\", targetKey, len - (count - 1))\n  if id then\n    rcall(\"LINSERT\", targetKey, \"BEFORE\", id, jobId)\n  else\n    rcall(\"RPUSH\", targetKey, jobId)\n  end\nend\n--[[\n  Function to debounce a job.\n]]\nlocal function debounceJob(prefixKey, debounceId, ttl, jobId, debounceKey, token)\n  if debounceId ~= \"\" then\n    local debounceKeyExists\n    if ttl ~= \"\" then\n      debounceKeyExists = not rcall('SET', debounceKey, jobId, 'PX', ttl, 'NX')\n    else\n      debounceKeyExists = not rcall('SET', debounceKey, jobId, 'NX')\n    end\n    if debounceKeyExists then\n      local currentDebounceJobId = rcall('GET', debounceKey)\n      rcall(\"PUBLISH\", prefixKey .. \"debounced@\" .. token, currentDebounceJobId)\n      return currentDebounceJobId\n    end\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal jobCounter = rcall(\"INCR\", KEYS[4])\nif ARGV[2] == \"\" then\n  jobId = jobCounter\n  jobIdKey = ARGV[1] .. jobId\nelse\n  jobId = ARGV[2]\n  jobIdKey = ARGV[1] .. jobId\n  if rcall(\"EXISTS\", jobIdKey) == 1 then\n    rcall(\"PUBLISH\", ARGV[1] .. \"duplicated@\" .. ARGV[11], jobId)\n    return jobId .. \"\" -- convert to string\n  end\nend\nlocal debounceKey = ARGV[12]\nlocal opts = cmsgpack.unpack(ARGV[5])\nlocal debouncedJobId = debounceJob(ARGV[1], ARGV[13], ARGV[14],\n  jobId, debounceKey, ARGV[11])\nif debouncedJobId then\n  return debouncedJobId\nend\nlocal debounceId = ARGV[13]\nlocal optionalValues = {}\nif debounceId ~= \"\" then\n  table.insert(optionalValues, \"deid\")\n  table.insert(optionalValues, debounceId)\nend\n    -- Store the job.\nrcall(\"HMSET\", jobIdKey, \"name\", ARGV[3], \"data\", ARGV[4], \"opts\", opts, \"timestamp\",\n  ARGV[6], \"delay\", ARGV[7], \"priority\", ARGV[9], unpack(optionalValues))\n-- Check if job is delayed\nlocal delayedTimestamp = tonumber(ARGV[8])\nif(delayedTimestamp ~= 0) then\n  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)\n  rcall(\"ZADD\", KEYS[5], timestamp, jobId)\n  rcall(\"PUBLISH\", KEYS[5], delayedTimestamp)\nelse\n  local target\n  -- Whe check for the meta-paused key to decide if we are paused or not\n  -- (since an empty list and !EXISTS are not really the same)\n  local target, paused = getTargetQueueList(KEYS[3], KEYS[1], KEYS[2])\n  -- Standard or priority add\n  local priority = tonumber(ARGV[9])\n  if priority == 0 then\n      -- LIFO or FIFO\n    rcall(ARGV[10], target, jobId)\n  else\n    addJobWithPriority(KEYS[6], priority, jobId, target)\n  end\n  -- Emit waiting event (wait..ing@token)\n  rcall(\"PUBLISH\", KEYS[1] .. \"ing@\" .. ARGV[11], jobId)\nend\nreturn jobId .. \"\" -- convert to string\n`;\nmodule.exports = {\n  name: 'addJob',\n  content,\n  keys: 6,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9hZGRKb2ItNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvYWRkSm9iLTYuanM/OGM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgQWRkcyBhIGpvYiB0byB0aGUgcXVldWUgYnkgZG9pbmcgdGhlIGZvbGxvd2luZzpcbiAgICAtIEluY3JlYXNlcyB0aGUgam9iIGNvdW50ZXIgaWYgbmVlZGVkLlxuICAgIC0gQ3JlYXRlcyBhIG5ldyBqb2Iga2V5IHdpdGggdGhlIGpvYiBkYXRhLlxuICAgIC0gaWYgZGVsYXllZDpcbiAgICAgIC0gY29tcHV0ZXMgdGltZXN0YW1wLlxuICAgICAgLSBhZGRzIHRvIGRlbGF5ZWQgenNldC5cbiAgICAgIC0gRW1pdHMgYSBnbG9iYWwgZXZlbnQgJ2RlbGF5ZWQnIGlmIHRoZSBqb2IgaXMgZGVsYXllZC5cbiAgICAtIGlmIG5vdCBkZWxheWVkXG4gICAgICAtIEFkZHMgdGhlIGpvYklkIHRvIHRoZSB3YWl0L3BhdXNlZCBsaXN0IGluIG9uZSBvZiB0aHJlZSB3YXlzOlxuICAgICAgICAgLSBMSUZPXG4gICAgICAgICAtIEZJRk9cbiAgICAgICAgIC0gcHJpb3JpdGl6ZWQuXG4gICAgICAtIEFkZHMgdGhlIGpvYiB0byB0aGUgXCJhZGRlZFwiIGxpc3Qgc28gdGhhdCB3b3JrZXJzIGdldHMgbm90aWZpZWQuXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICd3YWl0JyxcbiAgICAgIEtFWVNbMl0gJ3BhdXNlZCdcbiAgICAgIEtFWVNbM10gJ21ldGEtcGF1c2VkJ1xuICAgICAgS0VZU1s0XSAnaWQnXG4gICAgICBLRVlTWzVdICdkZWxheWVkJ1xuICAgICAgS0VZU1s2XSAncHJpb3JpdHknXG4gICAgICBBUkdWWzFdICBrZXkgcHJlZml4LFxuICAgICAgQVJHVlsyXSAgY3VzdG9tIGlkICh3aWxsIG5vdCBnZW5lcmF0ZSBvbmUgYXV0b21hdGljYWxseSlcbiAgICAgIEFSR1ZbM10gIG5hbWVcbiAgICAgIEFSR1ZbNF0gIGRhdGEgKGpzb24gc3RyaW5naWZpZWQgam9iIGRhdGEpXG4gICAgICBBUkdWWzVdICBvcHRzIChqc29uIHN0cmluZ2lmaWVkIGpvYiBvcHRzKVxuICAgICAgQVJHVls2XSAgdGltZXN0YW1wXG4gICAgICBBUkdWWzddICBkZWxheVxuICAgICAgQVJHVls4XSAgZGVsYXllZFRpbWVzdGFtcFxuICAgICAgQVJHVls5XSAgcHJpb3JpdHlcbiAgICAgIEFSR1ZbMTBdIExJRk9cbiAgICAgIEFSR1ZbMTFdIHRva2VuXG4gICAgICBBUkdWWzEyXSBkZWJvdW5jZSBrZXlcbiAgICAgIEFSR1ZbMTNdIGRlYm91bmNlSWRcbiAgICAgIEFSR1ZbMTRdIGRlYm91bmNlVHRsXG5dXVxubG9jYWwgam9iSWRcbmxvY2FsIGpvYklkS2V5XG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgY29uc2lkZXJpbmcgcHJpb3JpdHkuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkSm9iV2l0aFByaW9yaXR5KHByaW9yaXR5S2V5LCBwcmlvcml0eSwgam9iSWQsIHRhcmdldEtleSlcbiAgcmNhbGwoXCJaQUREXCIsIHByaW9yaXR5S2V5LCBwcmlvcml0eSwgam9iSWQpXG4gIGxvY2FsIGNvdW50ID0gcmNhbGwoXCJaQ09VTlRcIiwgcHJpb3JpdHlLZXksIDAsIHByaW9yaXR5KVxuICBsb2NhbCBsZW4gPSByY2FsbChcIkxMRU5cIiwgdGFyZ2V0S2V5KVxuICBsb2NhbCBpZCA9IHJjYWxsKFwiTElOREVYXCIsIHRhcmdldEtleSwgbGVuIC0gKGNvdW50IC0gMSkpXG4gIGlmIGlkIHRoZW5cbiAgICByY2FsbChcIkxJTlNFUlRcIiwgdGFyZ2V0S2V5LCBcIkJFRk9SRVwiLCBpZCwgam9iSWQpXG4gIGVsc2VcbiAgICByY2FsbChcIlJQVVNIXCIsIHRhcmdldEtleSwgam9iSWQpXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGRlYm91bmNlIGEgam9iLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGRlYm91bmNlSm9iKHByZWZpeEtleSwgZGVib3VuY2VJZCwgdHRsLCBqb2JJZCwgZGVib3VuY2VLZXksIHRva2VuKVxuICBpZiBkZWJvdW5jZUlkIH49IFwiXCIgdGhlblxuICAgIGxvY2FsIGRlYm91bmNlS2V5RXhpc3RzXG4gICAgaWYgdHRsIH49IFwiXCIgdGhlblxuICAgICAgZGVib3VuY2VLZXlFeGlzdHMgPSBub3QgcmNhbGwoJ1NFVCcsIGRlYm91bmNlS2V5LCBqb2JJZCwgJ1BYJywgdHRsLCAnTlgnKVxuICAgIGVsc2VcbiAgICAgIGRlYm91bmNlS2V5RXhpc3RzID0gbm90IHJjYWxsKCdTRVQnLCBkZWJvdW5jZUtleSwgam9iSWQsICdOWCcpXG4gICAgZW5kXG4gICAgaWYgZGVib3VuY2VLZXlFeGlzdHMgdGhlblxuICAgICAgbG9jYWwgY3VycmVudERlYm91bmNlSm9iSWQgPSByY2FsbCgnR0VUJywgZGVib3VuY2VLZXkpXG4gICAgICByY2FsbChcIlBVQkxJU0hcIiwgcHJlZml4S2V5IC4uIFwiZGVib3VuY2VkQFwiIC4uIHRva2VuLCBjdXJyZW50RGVib3VuY2VKb2JJZClcbiAgICAgIHJldHVybiBjdXJyZW50RGVib3VuY2VKb2JJZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgaWYgcmNhbGwoXCJFWElTVFNcIiwgcXVldWVNZXRhS2V5KSB+PSAxIHRoZW5cbiAgICByZXR1cm4gd2FpdEtleSwgZmFsc2VcbiAgZWxzZVxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWVcbiAgZW5kXG5lbmRcbmxvY2FsIGpvYkNvdW50ZXIgPSByY2FsbChcIklOQ1JcIiwgS0VZU1s0XSlcbmlmIEFSR1ZbMl0gPT0gXCJcIiB0aGVuXG4gIGpvYklkID0gam9iQ291bnRlclxuICBqb2JJZEtleSA9IEFSR1ZbMV0gLi4gam9iSWRcbmVsc2VcbiAgam9iSWQgPSBBUkdWWzJdXG4gIGpvYklkS2V5ID0gQVJHVlsxXSAuLiBqb2JJZFxuICBpZiByY2FsbChcIkVYSVNUU1wiLCBqb2JJZEtleSkgPT0gMSB0aGVuXG4gICAgcmNhbGwoXCJQVUJMSVNIXCIsIEFSR1ZbMV0gLi4gXCJkdXBsaWNhdGVkQFwiIC4uIEFSR1ZbMTFdLCBqb2JJZClcbiAgICByZXR1cm4gam9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuICBlbmRcbmVuZFxubG9jYWwgZGVib3VuY2VLZXkgPSBBUkdWWzEyXVxubG9jYWwgb3B0cyA9IGNtc2dwYWNrLnVucGFjayhBUkdWWzVdKVxubG9jYWwgZGVib3VuY2VkSm9iSWQgPSBkZWJvdW5jZUpvYihBUkdWWzFdLCBBUkdWWzEzXSwgQVJHVlsxNF0sXG4gIGpvYklkLCBkZWJvdW5jZUtleSwgQVJHVlsxMV0pXG5pZiBkZWJvdW5jZWRKb2JJZCB0aGVuXG4gIHJldHVybiBkZWJvdW5jZWRKb2JJZFxuZW5kXG5sb2NhbCBkZWJvdW5jZUlkID0gQVJHVlsxM11cbmxvY2FsIG9wdGlvbmFsVmFsdWVzID0ge31cbmlmIGRlYm91bmNlSWQgfj0gXCJcIiB0aGVuXG4gIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJkZWlkXCIpXG4gIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgZGVib3VuY2VJZClcbmVuZFxuICAgIC0tIFN0b3JlIHRoZSBqb2IuXG5yY2FsbChcIkhNU0VUXCIsIGpvYklkS2V5LCBcIm5hbWVcIiwgQVJHVlszXSwgXCJkYXRhXCIsIEFSR1ZbNF0sIFwib3B0c1wiLCBvcHRzLCBcInRpbWVzdGFtcFwiLFxuICBBUkdWWzZdLCBcImRlbGF5XCIsIEFSR1ZbN10sIFwicHJpb3JpdHlcIiwgQVJHVls5XSwgdW5wYWNrKG9wdGlvbmFsVmFsdWVzKSlcbi0tIENoZWNrIGlmIGpvYiBpcyBkZWxheWVkXG5sb2NhbCBkZWxheWVkVGltZXN0YW1wID0gdG9udW1iZXIoQVJHVls4XSlcbmlmKGRlbGF5ZWRUaW1lc3RhbXAgfj0gMCkgdGhlblxuICBsb2NhbCB0aW1lc3RhbXAgPSBkZWxheWVkVGltZXN0YW1wICogMHgxMDAwICsgYml0LmJhbmQoam9iQ291bnRlciwgMHhmZmYpXG4gIHJjYWxsKFwiWkFERFwiLCBLRVlTWzVdLCB0aW1lc3RhbXAsIGpvYklkKVxuICByY2FsbChcIlBVQkxJU0hcIiwgS0VZU1s1XSwgZGVsYXllZFRpbWVzdGFtcClcbmVsc2VcbiAgbG9jYWwgdGFyZ2V0XG4gIC0tIFdoZSBjaGVjayBmb3IgdGhlIG1ldGEtcGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgLS0gKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpXG4gIGxvY2FsIHRhcmdldCwgcGF1c2VkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KEtFWVNbM10sIEtFWVNbMV0sIEtFWVNbMl0pXG4gIC0tIFN0YW5kYXJkIG9yIHByaW9yaXR5IGFkZFxuICBsb2NhbCBwcmlvcml0eSA9IHRvbnVtYmVyKEFSR1ZbOV0pXG4gIGlmIHByaW9yaXR5ID09IDAgdGhlblxuICAgICAgLS0gTElGTyBvciBGSUZPXG4gICAgcmNhbGwoQVJHVlsxMF0sIHRhcmdldCwgam9iSWQpXG4gIGVsc2VcbiAgICBhZGRKb2JXaXRoUHJpb3JpdHkoS0VZU1s2XSwgcHJpb3JpdHksIGpvYklkLCB0YXJnZXQpXG4gIGVuZFxuICAtLSBFbWl0IHdhaXRpbmcgZXZlbnQgKHdhaXQuLmluZ0B0b2tlbilcbiAgcmNhbGwoXCJQVUJMSVNIXCIsIEtFWVNbMV0gLi4gXCJpbmdAXCIgLi4gQVJHVlsxMV0sIGpvYklkKVxuZW5kXG5yZXR1cm4gam9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAnYWRkSm9iJyxcbiAgY29udGVudCxcbiAga2V5czogNixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/addJob-6.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/addLog-2.js":
/*!*******************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/addLog-2.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Add job log\n  Input:\n    KEYS[1] job id key\n    KEYS[2] job logs key\n    ARGV[1] id\n    ARGV[2] log\n    ARGV[3] keepLogs\n  Output:\n    -1 - Missing job.\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[1]) == 1 then -- // Make sure job exists\n  local logCount = rcall(\"RPUSH\", KEYS[2], ARGV[2])\n  if ARGV[3] ~= '' then\n    local keepLogs = tonumber(ARGV[3])\n    rcall(\"LTRIM\", KEYS[2], -keepLogs, -1)\n    return math.min(keepLogs, logCount)\n  end\n  return logCount\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'addLog',\n  content,\n  keys: 2,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9hZGRMb2ctMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvYWRkTG9nLTIuanM/NjhiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgQWRkIGpvYiBsb2dcbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBqb2IgaWQga2V5XG4gICAgS0VZU1syXSBqb2IgbG9ncyBrZXlcbiAgICBBUkdWWzFdIGlkXG4gICAgQVJHVlsyXSBsb2dcbiAgICBBUkdWWzNdIGtlZXBMb2dzXG4gIE91dHB1dDpcbiAgICAtMSAtIE1pc3Npbmcgam9iLlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1sxXSkgPT0gMSB0aGVuIC0tIC8vIE1ha2Ugc3VyZSBqb2IgZXhpc3RzXG4gIGxvY2FsIGxvZ0NvdW50ID0gcmNhbGwoXCJSUFVTSFwiLCBLRVlTWzJdLCBBUkdWWzJdKVxuICBpZiBBUkdWWzNdIH49ICcnIHRoZW5cbiAgICBsb2NhbCBrZWVwTG9ncyA9IHRvbnVtYmVyKEFSR1ZbM10pXG4gICAgcmNhbGwoXCJMVFJJTVwiLCBLRVlTWzJdLCAta2VlcExvZ3MsIC0xKVxuICAgIHJldHVybiBtYXRoLm1pbihrZWVwTG9ncywgbG9nQ291bnQpXG4gIGVuZFxuICByZXR1cm4gbG9nQ291bnRcbmVsc2VcbiAgcmV0dXJuIC0xXG5lbmRcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ2FkZExvZycsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDIsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/addLog-2.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/cleanJobsInSet-3.js":
/*!***************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/cleanJobsInSet-3.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Remove jobs from the specific set.\n  Input:\n    KEYS[1]  set key,\n    KEYS[2]  priority key\n    KEYS[3]  rate limiter key\n    ARGV[1]  prefix key\n    ARGV[2]  maxTimestamp\n    ARGV[3]  limit the number of jobs to be removed. 0 is unlimited\n    ARGV[4]  set name, can be any of 'wait', 'active', 'paused', 'delayed', 'completed', or 'failed'\n]]\nlocal setKey = KEYS[1]\nlocal priorityKey = KEYS[2]\nlocal rateLimiterKey = KEYS[3]\nlocal prefixKey = ARGV[1]\nlocal maxTimestamp = ARGV[2]\nlocal limitStr = ARGV[3]\nlocal setName = ARGV[4]\nlocal isList = false\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to remove debounce key.\n]]\nlocal function removeDebounceKey(prefixKey, jobKey)\n  local debounceId = rcall(\"HGET\", jobKey, \"deid\")\n  if debounceId then\n    local debounceKey = prefixKey .. \"de:\" .. debounceId\n    rcall(\"DEL\", debounceKey)\n  end\nend\nif setName == \"wait\" or setName == \"active\" or setName == \"paused\" then\n  isList = true\nend\n-- We use ZRANGEBYSCORE to make the case where we're deleting a limited number\n-- of items in a sorted set only run a single iteration. If we simply used\n-- ZRANGE, we may take a long time traversing through jobs that are within the\n-- grace period.\nlocal function shouldUseZRangeByScore(isList, limit)\n  return not isList and limit > 0\nend\nlocal function getJobs(setKey, isList, rangeStart, rangeEnd, maxTimestamp, limit)\n  if isList then\n    return rcall(\"LRANGE\", setKey, rangeStart, rangeEnd)\n  elseif shouldUseZRangeByScore(isList, limit) then\n    return rcall(\"ZRANGEBYSCORE\", setKey, 0, maxTimestamp, \"LIMIT\", 0, limit)\n  else\n    return rcall(\"ZRANGE\", setKey, rangeStart, rangeEnd)\n  end\nend\nlocal limit = tonumber(limitStr)\nlocal rangeStart = 0\nlocal rangeEnd = -1\n-- If we're only deleting _n_ items, avoid retrieving all items\n-- for faster performance\n--\n-- Start from the tail of the list, since that's where oldest elements\n-- are generally added for FIFO lists\nif limit > 0 then\n  rangeStart = -1 - limit + 1\n  rangeEnd = -1\nend\nlocal jobIds = getJobs(setKey, isList, rangeStart, rangeEnd, maxTimestamp, limit)\nlocal deleted = {}\nlocal deletedCount = 0\nlocal jobTS\n-- Run this loop:\n-- - Once, if limit is -1 or 0\n-- - As many times as needed if limit is positive\nwhile ((limit <= 0 or deletedCount < limit) and next(jobIds, nil) ~= nil) do\n  local jobIdsLen = #jobIds\n  for i, jobId in ipairs(jobIds) do\n    if limit > 0 and deletedCount >= limit then\n      break\n    end\n    local jobKey = prefixKey .. jobId\n    if (rcall(\"EXISTS\", jobKey .. \":lock\") == 0) then\n      -- Find the right timestamp of the job to compare to maxTimestamp:\n      -- * finishedOn says when the job was completed, but it isn't set unless the job has actually completed\n      -- * processedOn represents when the job was last attempted, but it doesn't get populated until the job is first tried\n      -- * timestamp is the original job submission time\n      -- Fetch all three of these (in that order) and use the first one that is set so that we'll leave jobs that have been active within the grace period:\n      for _, ts in ipairs(rcall(\"HMGET\", jobKey, \"finishedOn\", \"processedOn\", \"timestamp\")) do\n        if (ts) then\n          jobTS = ts\n          break\n        end\n      end\n      if (not jobTS or jobTS < maxTimestamp) then\n        if isList then\n          -- Job ids can't be the empty string. Use the empty string as a\n          -- deletion marker. The actual deletion will occur at the end of the\n          -- script.\n          rcall(\"LSET\", setKey, rangeEnd - jobIdsLen + i, \"\")\n        else\n          rcall(\"ZREM\", setKey, jobId)\n        end\n        rcall(\"ZREM\", priorityKey, jobId)\n        if setName ~= \"completed\" and setName ~= \"failed\" then\n          removeDebounceKey(prefixKey, jobKey)\n        end\n        rcall(\"DEL\", jobKey)\n        rcall(\"DEL\", jobKey .. \":logs\")\n        -- delete keys related to rate limiter\n        -- NOTE: this code is unncessary for other sets than wait, paused and delayed.\n        local limiterIndexTable = rateLimiterKey .. \":index\"\n        local limitedSetKey = rcall(\"HGET\", limiterIndexTable, jobId)\n        if limitedSetKey then\n          rcall(\"SREM\", limitedSetKey, jobId)\n          rcall(\"HDEL\", limiterIndexTable, jobId)\n        end\n        deletedCount = deletedCount + 1\n        table.insert(deleted, jobId)\n      end\n    end\n  end\n  -- If we didn't have a limit or used the single-iteration ZRANGEBYSCORE\n  -- function, return immediately. We should have deleted all the jobs we can\n  if limit <= 0 or shouldUseZRangeByScore(isList, limit) then\n    break\n  end\n  if deletedCount < limit then\n    -- We didn't delete enough. Look for more to delete\n    rangeStart = rangeStart - limit\n    rangeEnd = rangeEnd - limit\n    jobIds = getJobs(setKey, isList, rangeStart, rangeEnd, maxTimestamp, limit)\n  end\nend\nif isList then\n  rcall(\"LREM\", setKey, 0, \"\")\nend\nreturn deleted\n`;\nmodule.exports = {\n  name: 'cleanJobsInSet',\n  content,\n  keys: 3,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9jbGVhbkpvYnNJblNldC0zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL2NsZWFuSm9ic0luU2V0LTMuanM/YTNiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgUmVtb3ZlIGpvYnMgZnJvbSB0aGUgc3BlY2lmaWMgc2V0LlxuICBJbnB1dDpcbiAgICBLRVlTWzFdICBzZXQga2V5LFxuICAgIEtFWVNbMl0gIHByaW9yaXR5IGtleVxuICAgIEtFWVNbM10gIHJhdGUgbGltaXRlciBrZXlcbiAgICBBUkdWWzFdICBwcmVmaXgga2V5XG4gICAgQVJHVlsyXSAgbWF4VGltZXN0YW1wXG4gICAgQVJHVlszXSAgbGltaXQgdGhlIG51bWJlciBvZiBqb2JzIHRvIGJlIHJlbW92ZWQuIDAgaXMgdW5saW1pdGVkXG4gICAgQVJHVls0XSAgc2V0IG5hbWUsIGNhbiBiZSBhbnkgb2YgJ3dhaXQnLCAnYWN0aXZlJywgJ3BhdXNlZCcsICdkZWxheWVkJywgJ2NvbXBsZXRlZCcsIG9yICdmYWlsZWQnXG5dXVxubG9jYWwgc2V0S2V5ID0gS0VZU1sxXVxubG9jYWwgcHJpb3JpdHlLZXkgPSBLRVlTWzJdXG5sb2NhbCByYXRlTGltaXRlcktleSA9IEtFWVNbM11cbmxvY2FsIHByZWZpeEtleSA9IEFSR1ZbMV1cbmxvY2FsIG1heFRpbWVzdGFtcCA9IEFSR1ZbMl1cbmxvY2FsIGxpbWl0U3RyID0gQVJHVlszXVxubG9jYWwgc2V0TmFtZSA9IEFSR1ZbNF1cbmxvY2FsIGlzTGlzdCA9IGZhbHNlXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBkZWJvdW5jZSBrZXkuXG5dXVxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlRGVib3VuY2VLZXkocHJlZml4S2V5LCBqb2JLZXkpXG4gIGxvY2FsIGRlYm91bmNlSWQgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcImRlaWRcIilcbiAgaWYgZGVib3VuY2VJZCB0aGVuXG4gICAgbG9jYWwgZGVib3VuY2VLZXkgPSBwcmVmaXhLZXkgLi4gXCJkZTpcIiAuLiBkZWJvdW5jZUlkXG4gICAgcmNhbGwoXCJERUxcIiwgZGVib3VuY2VLZXkpXG4gIGVuZFxuZW5kXG5pZiBzZXROYW1lID09IFwid2FpdFwiIG9yIHNldE5hbWUgPT0gXCJhY3RpdmVcIiBvciBzZXROYW1lID09IFwicGF1c2VkXCIgdGhlblxuICBpc0xpc3QgPSB0cnVlXG5lbmRcbi0tIFdlIHVzZSBaUkFOR0VCWVNDT1JFIHRvIG1ha2UgdGhlIGNhc2Ugd2hlcmUgd2UncmUgZGVsZXRpbmcgYSBsaW1pdGVkIG51bWJlclxuLS0gb2YgaXRlbXMgaW4gYSBzb3J0ZWQgc2V0IG9ubHkgcnVuIGEgc2luZ2xlIGl0ZXJhdGlvbi4gSWYgd2Ugc2ltcGx5IHVzZWRcbi0tIFpSQU5HRSwgd2UgbWF5IHRha2UgYSBsb25nIHRpbWUgdHJhdmVyc2luZyB0aHJvdWdoIGpvYnMgdGhhdCBhcmUgd2l0aGluIHRoZVxuLS0gZ3JhY2UgcGVyaW9kLlxubG9jYWwgZnVuY3Rpb24gc2hvdWxkVXNlWlJhbmdlQnlTY29yZShpc0xpc3QsIGxpbWl0KVxuICByZXR1cm4gbm90IGlzTGlzdCBhbmQgbGltaXQgPiAwXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGdldEpvYnMoc2V0S2V5LCBpc0xpc3QsIHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBtYXhUaW1lc3RhbXAsIGxpbWl0KVxuICBpZiBpc0xpc3QgdGhlblxuICAgIHJldHVybiByY2FsbChcIkxSQU5HRVwiLCBzZXRLZXksIHJhbmdlU3RhcnQsIHJhbmdlRW5kKVxuICBlbHNlaWYgc2hvdWxkVXNlWlJhbmdlQnlTY29yZShpc0xpc3QsIGxpbWl0KSB0aGVuXG4gICAgcmV0dXJuIHJjYWxsKFwiWlJBTkdFQllTQ09SRVwiLCBzZXRLZXksIDAsIG1heFRpbWVzdGFtcCwgXCJMSU1JVFwiLCAwLCBsaW1pdClcbiAgZWxzZVxuICAgIHJldHVybiByY2FsbChcIlpSQU5HRVwiLCBzZXRLZXksIHJhbmdlU3RhcnQsIHJhbmdlRW5kKVxuICBlbmRcbmVuZFxubG9jYWwgbGltaXQgPSB0b251bWJlcihsaW1pdFN0cilcbmxvY2FsIHJhbmdlU3RhcnQgPSAwXG5sb2NhbCByYW5nZUVuZCA9IC0xXG4tLSBJZiB3ZSdyZSBvbmx5IGRlbGV0aW5nIF9uXyBpdGVtcywgYXZvaWQgcmV0cmlldmluZyBhbGwgaXRlbXNcbi0tIGZvciBmYXN0ZXIgcGVyZm9ybWFuY2Vcbi0tXG4tLSBTdGFydCBmcm9tIHRoZSB0YWlsIG9mIHRoZSBsaXN0LCBzaW5jZSB0aGF0J3Mgd2hlcmUgb2xkZXN0IGVsZW1lbnRzXG4tLSBhcmUgZ2VuZXJhbGx5IGFkZGVkIGZvciBGSUZPIGxpc3RzXG5pZiBsaW1pdCA+IDAgdGhlblxuICByYW5nZVN0YXJ0ID0gLTEgLSBsaW1pdCArIDFcbiAgcmFuZ2VFbmQgPSAtMVxuZW5kXG5sb2NhbCBqb2JJZHMgPSBnZXRKb2JzKHNldEtleSwgaXNMaXN0LCByYW5nZVN0YXJ0LCByYW5nZUVuZCwgbWF4VGltZXN0YW1wLCBsaW1pdClcbmxvY2FsIGRlbGV0ZWQgPSB7fVxubG9jYWwgZGVsZXRlZENvdW50ID0gMFxubG9jYWwgam9iVFNcbi0tIFJ1biB0aGlzIGxvb3A6XG4tLSAtIE9uY2UsIGlmIGxpbWl0IGlzIC0xIG9yIDBcbi0tIC0gQXMgbWFueSB0aW1lcyBhcyBuZWVkZWQgaWYgbGltaXQgaXMgcG9zaXRpdmVcbndoaWxlICgobGltaXQgPD0gMCBvciBkZWxldGVkQ291bnQgPCBsaW1pdCkgYW5kIG5leHQoam9iSWRzLCBuaWwpIH49IG5pbCkgZG9cbiAgbG9jYWwgam9iSWRzTGVuID0gI2pvYklkc1xuICBmb3IgaSwgam9iSWQgaW4gaXBhaXJzKGpvYklkcykgZG9cbiAgICBpZiBsaW1pdCA+IDAgYW5kIGRlbGV0ZWRDb3VudCA+PSBsaW1pdCB0aGVuXG4gICAgICBicmVha1xuICAgIGVuZFxuICAgIGxvY2FsIGpvYktleSA9IHByZWZpeEtleSAuLiBqb2JJZFxuICAgIGlmIChyY2FsbChcIkVYSVNUU1wiLCBqb2JLZXkgLi4gXCI6bG9ja1wiKSA9PSAwKSB0aGVuXG4gICAgICAtLSBGaW5kIHRoZSByaWdodCB0aW1lc3RhbXAgb2YgdGhlIGpvYiB0byBjb21wYXJlIHRvIG1heFRpbWVzdGFtcDpcbiAgICAgIC0tICogZmluaXNoZWRPbiBzYXlzIHdoZW4gdGhlIGpvYiB3YXMgY29tcGxldGVkLCBidXQgaXQgaXNuJ3Qgc2V0IHVubGVzcyB0aGUgam9iIGhhcyBhY3R1YWxseSBjb21wbGV0ZWRcbiAgICAgIC0tICogcHJvY2Vzc2VkT24gcmVwcmVzZW50cyB3aGVuIHRoZSBqb2Igd2FzIGxhc3QgYXR0ZW1wdGVkLCBidXQgaXQgZG9lc24ndCBnZXQgcG9wdWxhdGVkIHVudGlsIHRoZSBqb2IgaXMgZmlyc3QgdHJpZWRcbiAgICAgIC0tICogdGltZXN0YW1wIGlzIHRoZSBvcmlnaW5hbCBqb2Igc3VibWlzc2lvbiB0aW1lXG4gICAgICAtLSBGZXRjaCBhbGwgdGhyZWUgb2YgdGhlc2UgKGluIHRoYXQgb3JkZXIpIGFuZCB1c2UgdGhlIGZpcnN0IG9uZSB0aGF0IGlzIHNldCBzbyB0aGF0IHdlJ2xsIGxlYXZlIGpvYnMgdGhhdCBoYXZlIGJlZW4gYWN0aXZlIHdpdGhpbiB0aGUgZ3JhY2UgcGVyaW9kOlxuICAgICAgZm9yIF8sIHRzIGluIGlwYWlycyhyY2FsbChcIkhNR0VUXCIsIGpvYktleSwgXCJmaW5pc2hlZE9uXCIsIFwicHJvY2Vzc2VkT25cIiwgXCJ0aW1lc3RhbXBcIikpIGRvXG4gICAgICAgIGlmICh0cykgdGhlblxuICAgICAgICAgIGpvYlRTID0gdHNcbiAgICAgICAgICBicmVha1xuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgaWYgKG5vdCBqb2JUUyBvciBqb2JUUyA8IG1heFRpbWVzdGFtcCkgdGhlblxuICAgICAgICBpZiBpc0xpc3QgdGhlblxuICAgICAgICAgIC0tIEpvYiBpZHMgY2FuJ3QgYmUgdGhlIGVtcHR5IHN0cmluZy4gVXNlIHRoZSBlbXB0eSBzdHJpbmcgYXMgYVxuICAgICAgICAgIC0tIGRlbGV0aW9uIG1hcmtlci4gVGhlIGFjdHVhbCBkZWxldGlvbiB3aWxsIG9jY3VyIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgLS0gc2NyaXB0LlxuICAgICAgICAgIHJjYWxsKFwiTFNFVFwiLCBzZXRLZXksIHJhbmdlRW5kIC0gam9iSWRzTGVuICsgaSwgXCJcIilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJjYWxsKFwiWlJFTVwiLCBzZXRLZXksIGpvYklkKVxuICAgICAgICBlbmRcbiAgICAgICAgcmNhbGwoXCJaUkVNXCIsIHByaW9yaXR5S2V5LCBqb2JJZClcbiAgICAgICAgaWYgc2V0TmFtZSB+PSBcImNvbXBsZXRlZFwiIGFuZCBzZXROYW1lIH49IFwiZmFpbGVkXCIgdGhlblxuICAgICAgICAgIHJlbW92ZURlYm91bmNlS2V5KHByZWZpeEtleSwgam9iS2V5KVxuICAgICAgICBlbmRcbiAgICAgICAgcmNhbGwoXCJERUxcIiwgam9iS2V5KVxuICAgICAgICByY2FsbChcIkRFTFwiLCBqb2JLZXkgLi4gXCI6bG9nc1wiKVxuICAgICAgICAtLSBkZWxldGUga2V5cyByZWxhdGVkIHRvIHJhdGUgbGltaXRlclxuICAgICAgICAtLSBOT1RFOiB0aGlzIGNvZGUgaXMgdW5uY2Vzc2FyeSBmb3Igb3RoZXIgc2V0cyB0aGFuIHdhaXQsIHBhdXNlZCBhbmQgZGVsYXllZC5cbiAgICAgICAgbG9jYWwgbGltaXRlckluZGV4VGFibGUgPSByYXRlTGltaXRlcktleSAuLiBcIjppbmRleFwiXG4gICAgICAgIGxvY2FsIGxpbWl0ZWRTZXRLZXkgPSByY2FsbChcIkhHRVRcIiwgbGltaXRlckluZGV4VGFibGUsIGpvYklkKVxuICAgICAgICBpZiBsaW1pdGVkU2V0S2V5IHRoZW5cbiAgICAgICAgICByY2FsbChcIlNSRU1cIiwgbGltaXRlZFNldEtleSwgam9iSWQpXG4gICAgICAgICAgcmNhbGwoXCJIREVMXCIsIGxpbWl0ZXJJbmRleFRhYmxlLCBqb2JJZClcbiAgICAgICAgZW5kXG4gICAgICAgIGRlbGV0ZWRDb3VudCA9IGRlbGV0ZWRDb3VudCArIDFcbiAgICAgICAgdGFibGUuaW5zZXJ0KGRlbGV0ZWQsIGpvYklkKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICAtLSBJZiB3ZSBkaWRuJ3QgaGF2ZSBhIGxpbWl0IG9yIHVzZWQgdGhlIHNpbmdsZS1pdGVyYXRpb24gWlJBTkdFQllTQ09SRVxuICAtLSBmdW5jdGlvbiwgcmV0dXJuIGltbWVkaWF0ZWx5LiBXZSBzaG91bGQgaGF2ZSBkZWxldGVkIGFsbCB0aGUgam9icyB3ZSBjYW5cbiAgaWYgbGltaXQgPD0gMCBvciBzaG91bGRVc2VaUmFuZ2VCeVNjb3JlKGlzTGlzdCwgbGltaXQpIHRoZW5cbiAgICBicmVha1xuICBlbmRcbiAgaWYgZGVsZXRlZENvdW50IDwgbGltaXQgdGhlblxuICAgIC0tIFdlIGRpZG4ndCBkZWxldGUgZW5vdWdoLiBMb29rIGZvciBtb3JlIHRvIGRlbGV0ZVxuICAgIHJhbmdlU3RhcnQgPSByYW5nZVN0YXJ0IC0gbGltaXRcbiAgICByYW5nZUVuZCA9IHJhbmdlRW5kIC0gbGltaXRcbiAgICBqb2JJZHMgPSBnZXRKb2JzKHNldEtleSwgaXNMaXN0LCByYW5nZVN0YXJ0LCByYW5nZUVuZCwgbWF4VGltZXN0YW1wLCBsaW1pdClcbiAgZW5kXG5lbmRcbmlmIGlzTGlzdCB0aGVuXG4gIHJjYWxsKFwiTFJFTVwiLCBzZXRLZXksIDAsIFwiXCIpXG5lbmRcbnJldHVybiBkZWxldGVkXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdjbGVhbkpvYnNJblNldCcsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDMsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/cleanJobsInSet-3.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/extendLock-2.js":
/*!***********************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/extendLock-2.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Extend lock and removes the job from the stalled set.\n  Input:\n    KEYS[1] 'lock',\n    KEYS[2] 'stalled'\n    ARGV[1]  token\n    ARGV[2]  lock duration in milliseconds\n    ARGV[3]  jobid\n  Output:\n    \"1\" if lock extended succesfully.\n]]\nlocal rcall = redis.call\nif rcall(\"GET\", KEYS[1]) == ARGV[1] then\n  if rcall(\"SET\", KEYS[1], ARGV[1], \"PX\", ARGV[2]) then\n    rcall(\"SREM\", KEYS[2], ARGV[3])\n    return 1\n  end\nend\nreturn 0\n`;\nmodule.exports = {\n  name: 'extendLock',\n  content,\n  keys: 2,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9leHRlbmRMb2NrLTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9leHRlbmRMb2NrLTIuanM/YTQ1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgRXh0ZW5kIGxvY2sgYW5kIHJlbW92ZXMgdGhlIGpvYiBmcm9tIHRoZSBzdGFsbGVkIHNldC5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSAnbG9jaycsXG4gICAgS0VZU1syXSAnc3RhbGxlZCdcbiAgICBBUkdWWzFdICB0b2tlblxuICAgIEFSR1ZbMl0gIGxvY2sgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgQVJHVlszXSAgam9iaWRcbiAgT3V0cHV0OlxuICAgIFwiMVwiIGlmIGxvY2sgZXh0ZW5kZWQgc3VjY2VzZnVsbHkuXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5pZiByY2FsbChcIkdFVFwiLCBLRVlTWzFdKSA9PSBBUkdWWzFdIHRoZW5cbiAgaWYgcmNhbGwoXCJTRVRcIiwgS0VZU1sxXSwgQVJHVlsxXSwgXCJQWFwiLCBBUkdWWzJdKSB0aGVuXG4gICAgcmNhbGwoXCJTUkVNXCIsIEtFWVNbMl0sIEFSR1ZbM10pXG4gICAgcmV0dXJuIDFcbiAgZW5kXG5lbmRcbnJldHVybiAwXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdleHRlbmRMb2NrJyxcbiAgY29udGVudCxcbiAga2V5czogMixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/extendLock-2.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/getCountsPerPriority-4.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/getCountsPerPriority-4.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Get counts per provided states\n    Input:\n      KEYS[1] wait key\n      KEYS[2] paused key\n      KEYS[3] meta-paused key\n      KEYS[4] priority key\n      ARGV[1...] priorities\n]]\nlocal rcall = redis.call\nlocal results = {}\nlocal prioritizedKey = KEYS[4]\n-- Includes\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nfor i = 1, #ARGV do\n  local priority = tonumber(ARGV[i])\n  if priority == 0 then\n    local target = getTargetQueueList(KEYS[3], KEYS[1], KEYS[2])\n    local count = rcall(\"LLEN\", target) - rcall(\"ZCARD\", prioritizedKey)\n    if count < 0 then\n      -- considering when last waiting job is moved to active before\n      -- removing priority reference\n      results[#results+1] = 0\n    else\n      results[#results+1] = count\n    end\n  else\n    results[#results+1] = rcall(\"ZCOUNT\", prioritizedKey,\n      priority, priority)\n  end\nend\nreturn results\n`;\nmodule.exports = {\n  name: 'getCountsPerPriority',\n  content,\n  keys: 4,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9nZXRDb3VudHNQZXJQcmlvcml0eS00LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL2dldENvdW50c1BlclByaW9yaXR5LTQuanM/YTM2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgR2V0IGNvdW50cyBwZXIgcHJvdmlkZWQgc3RhdGVzXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdIHdhaXQga2V5XG4gICAgICBLRVlTWzJdIHBhdXNlZCBrZXlcbiAgICAgIEtFWVNbM10gbWV0YS1wYXVzZWQga2V5XG4gICAgICBLRVlTWzRdIHByaW9yaXR5IGtleVxuICAgICAgQVJHVlsxLi4uXSBwcmlvcml0aWVzXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5sb2NhbCByZXN1bHRzID0ge31cbmxvY2FsIHByaW9yaXRpemVkS2V5ID0gS0VZU1s0XVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGlmIHJjYWxsKFwiRVhJU1RTXCIsIHF1ZXVlTWV0YUtleSkgfj0gMSB0aGVuXG4gICAgcmV0dXJuIHdhaXRLZXksIGZhbHNlXG4gIGVsc2VcbiAgICByZXR1cm4gcGF1c2VkS2V5LCB0cnVlXG4gIGVuZFxuZW5kXG5mb3IgaSA9IDEsICNBUkdWIGRvXG4gIGxvY2FsIHByaW9yaXR5ID0gdG9udW1iZXIoQVJHVltpXSlcbiAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgbG9jYWwgdGFyZ2V0ID0gZ2V0VGFyZ2V0UXVldWVMaXN0KEtFWVNbM10sIEtFWVNbMV0sIEtFWVNbMl0pXG4gICAgbG9jYWwgY291bnQgPSByY2FsbChcIkxMRU5cIiwgdGFyZ2V0KSAtIHJjYWxsKFwiWkNBUkRcIiwgcHJpb3JpdGl6ZWRLZXkpXG4gICAgaWYgY291bnQgPCAwIHRoZW5cbiAgICAgIC0tIGNvbnNpZGVyaW5nIHdoZW4gbGFzdCB3YWl0aW5nIGpvYiBpcyBtb3ZlZCB0byBhY3RpdmUgYmVmb3JlXG4gICAgICAtLSByZW1vdmluZyBwcmlvcml0eSByZWZlcmVuY2VcbiAgICAgIHJlc3VsdHNbI3Jlc3VsdHMrMV0gPSAwXG4gICAgZWxzZVxuICAgICAgcmVzdWx0c1sjcmVzdWx0cysxXSA9IGNvdW50XG4gICAgZW5kXG4gIGVsc2VcbiAgICByZXN1bHRzWyNyZXN1bHRzKzFdID0gcmNhbGwoXCJaQ09VTlRcIiwgcHJpb3JpdGl6ZWRLZXksXG4gICAgICBwcmlvcml0eSwgcHJpb3JpdHkpXG4gIGVuZFxuZW5kXG5yZXR1cm4gcmVzdWx0c1xuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAnZ2V0Q291bnRzUGVyUHJpb3JpdHknLFxuICBjb250ZW50LFxuICBrZXlzOiA0LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/getCountsPerPriority-4.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = {\n  [\"addJob-6\"]: __webpack_require__(/*! ./addJob-6 */ \"(action-browser)/../../node_modules/bull/lib/scripts/addJob-6.js\"),\n  [\"addLog-2\"]: __webpack_require__(/*! ./addLog-2 */ \"(action-browser)/../../node_modules/bull/lib/scripts/addLog-2.js\"),\n  [\"cleanJobsInSet-3\"]: __webpack_require__(/*! ./cleanJobsInSet-3 */ \"(action-browser)/../../node_modules/bull/lib/scripts/cleanJobsInSet-3.js\"),\n  [\"extendLock-2\"]: __webpack_require__(/*! ./extendLock-2 */ \"(action-browser)/../../node_modules/bull/lib/scripts/extendLock-2.js\"),\n  [\"getCountsPerPriority-4\"]: __webpack_require__(/*! ./getCountsPerPriority-4 */ \"(action-browser)/../../node_modules/bull/lib/scripts/getCountsPerPriority-4.js\"),\n  [\"isFinished-2\"]: __webpack_require__(/*! ./isFinished-2 */ \"(action-browser)/../../node_modules/bull/lib/scripts/isFinished-2.js\"),\n  [\"isJobInList-1\"]: __webpack_require__(/*! ./isJobInList-1 */ \"(action-browser)/../../node_modules/bull/lib/scripts/isJobInList-1.js\"),\n  [\"moveStalledJobsToWait-7\"]: __webpack_require__(/*! ./moveStalledJobsToWait-7 */ \"(action-browser)/../../node_modules/bull/lib/scripts/moveStalledJobsToWait-7.js\"),\n  [\"moveToActive-8\"]: __webpack_require__(/*! ./moveToActive-8 */ \"(action-browser)/../../node_modules/bull/lib/scripts/moveToActive-8.js\"),\n  [\"moveToDelayed-4\"]: __webpack_require__(/*! ./moveToDelayed-4 */ \"(action-browser)/../../node_modules/bull/lib/scripts/moveToDelayed-4.js\"),\n  [\"moveToFinished-9\"]: __webpack_require__(/*! ./moveToFinished-9 */ \"(action-browser)/../../node_modules/bull/lib/scripts/moveToFinished-9.js\"),\n  [\"obliterate-2\"]: __webpack_require__(/*! ./obliterate-2 */ \"(action-browser)/../../node_modules/bull/lib/scripts/obliterate-2.js\"),\n  [\"pause-5\"]: __webpack_require__(/*! ./pause-5 */ \"(action-browser)/../../node_modules/bull/lib/scripts/pause-5.js\"),\n  [\"promote-5\"]: __webpack_require__(/*! ./promote-5 */ \"(action-browser)/../../node_modules/bull/lib/scripts/promote-5.js\"),\n  [\"releaseLock-1\"]: __webpack_require__(/*! ./releaseLock-1 */ \"(action-browser)/../../node_modules/bull/lib/scripts/releaseLock-1.js\"),\n  [\"removeJob-11\"]: __webpack_require__(/*! ./removeJob-11 */ \"(action-browser)/../../node_modules/bull/lib/scripts/removeJob-11.js\"),\n  [\"removeJobs-8\"]: __webpack_require__(/*! ./removeJobs-8 */ \"(action-browser)/../../node_modules/bull/lib/scripts/removeJobs-8.js\"),\n  [\"removeRepeatable-2\"]: __webpack_require__(/*! ./removeRepeatable-2 */ \"(action-browser)/../../node_modules/bull/lib/scripts/removeRepeatable-2.js\"),\n  [\"reprocessJob-6\"]: __webpack_require__(/*! ./reprocessJob-6 */ \"(action-browser)/../../node_modules/bull/lib/scripts/reprocessJob-6.js\"),\n  [\"retryJob-7\"]: __webpack_require__(/*! ./retryJob-7 */ \"(action-browser)/../../node_modules/bull/lib/scripts/retryJob-7.js\"),\n  [\"retryJobs-5\"]: __webpack_require__(/*! ./retryJobs-5 */ \"(action-browser)/../../node_modules/bull/lib/scripts/retryJobs-5.js\"),\n  [\"saveStacktrace-1\"]: __webpack_require__(/*! ./saveStacktrace-1 */ \"(action-browser)/../../node_modules/bull/lib/scripts/saveStacktrace-1.js\"),\n  [\"takeLock-1\"]: __webpack_require__(/*! ./takeLock-1 */ \"(action-browser)/../../node_modules/bull/lib/scripts/takeLock-1.js\"),\n  [\"updateData-1\"]: __webpack_require__(/*! ./updateData-1 */ \"(action-browser)/../../node_modules/bull/lib/scripts/updateData-1.js\"),\n  [\"updateDelaySet-6\"]: __webpack_require__(/*! ./updateDelaySet-6 */ \"(action-browser)/../../node_modules/bull/lib/scripts/updateDelaySet-6.js\"),\n  [\"updateProgress-2\"]: __webpack_require__(/*! ./updateProgress-2 */ \"(action-browser)/../../node_modules/bull/lib/scripts/updateProgress-2.js\"),\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsb0ZBQVk7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsb0ZBQVk7QUFDcEMsd0JBQXdCLG1CQUFPLENBQUMsb0dBQW9CO0FBQ3BELG9CQUFvQixtQkFBTyxDQUFDLDRGQUFnQjtBQUM1Qyw4QkFBOEIsbUJBQU8sQ0FBQyxnSEFBMEI7QUFDaEUsb0JBQW9CLG1CQUFPLENBQUMsNEZBQWdCO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLDhGQUFpQjtBQUM5QywrQkFBK0IsbUJBQU8sQ0FBQyxrSEFBMkI7QUFDbEUsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQWtCO0FBQ2hELHVCQUF1QixtQkFBTyxDQUFDLGtHQUFtQjtBQUNsRCx3QkFBd0IsbUJBQU8sQ0FBQyxvR0FBb0I7QUFDcEQsb0JBQW9CLG1CQUFPLENBQUMsNEZBQWdCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxrRkFBVztBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyxzRkFBYTtBQUN0QyxxQkFBcUIsbUJBQU8sQ0FBQyw4RkFBaUI7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsNEZBQWdCO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLDRGQUFnQjtBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQyx3R0FBc0I7QUFDeEQsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQWtCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLHdGQUFjO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFlO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLG9HQUFvQjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQyx3RkFBYztBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyw0RkFBZ0I7QUFDNUMsd0JBQXdCLG1CQUFPLENBQUMsb0dBQW9CO0FBQ3BELHdCQUF3QixtQkFBTyxDQUFDLG9HQUFvQjtBQUNwRCIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9pbmRleC5qcz9mNDQwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0ge1xuICBbXCJhZGRKb2ItNlwiXTogcmVxdWlyZSgnLi9hZGRKb2ItNicpLFxuICBbXCJhZGRMb2ctMlwiXTogcmVxdWlyZSgnLi9hZGRMb2ctMicpLFxuICBbXCJjbGVhbkpvYnNJblNldC0zXCJdOiByZXF1aXJlKCcuL2NsZWFuSm9ic0luU2V0LTMnKSxcbiAgW1wiZXh0ZW5kTG9jay0yXCJdOiByZXF1aXJlKCcuL2V4dGVuZExvY2stMicpLFxuICBbXCJnZXRDb3VudHNQZXJQcmlvcml0eS00XCJdOiByZXF1aXJlKCcuL2dldENvdW50c1BlclByaW9yaXR5LTQnKSxcbiAgW1wiaXNGaW5pc2hlZC0yXCJdOiByZXF1aXJlKCcuL2lzRmluaXNoZWQtMicpLFxuICBbXCJpc0pvYkluTGlzdC0xXCJdOiByZXF1aXJlKCcuL2lzSm9iSW5MaXN0LTEnKSxcbiAgW1wibW92ZVN0YWxsZWRKb2JzVG9XYWl0LTdcIl06IHJlcXVpcmUoJy4vbW92ZVN0YWxsZWRKb2JzVG9XYWl0LTcnKSxcbiAgW1wibW92ZVRvQWN0aXZlLThcIl06IHJlcXVpcmUoJy4vbW92ZVRvQWN0aXZlLTgnKSxcbiAgW1wibW92ZVRvRGVsYXllZC00XCJdOiByZXF1aXJlKCcuL21vdmVUb0RlbGF5ZWQtNCcpLFxuICBbXCJtb3ZlVG9GaW5pc2hlZC05XCJdOiByZXF1aXJlKCcuL21vdmVUb0ZpbmlzaGVkLTknKSxcbiAgW1wib2JsaXRlcmF0ZS0yXCJdOiByZXF1aXJlKCcuL29ibGl0ZXJhdGUtMicpLFxuICBbXCJwYXVzZS01XCJdOiByZXF1aXJlKCcuL3BhdXNlLTUnKSxcbiAgW1wicHJvbW90ZS01XCJdOiByZXF1aXJlKCcuL3Byb21vdGUtNScpLFxuICBbXCJyZWxlYXNlTG9jay0xXCJdOiByZXF1aXJlKCcuL3JlbGVhc2VMb2NrLTEnKSxcbiAgW1wicmVtb3ZlSm9iLTExXCJdOiByZXF1aXJlKCcuL3JlbW92ZUpvYi0xMScpLFxuICBbXCJyZW1vdmVKb2JzLThcIl06IHJlcXVpcmUoJy4vcmVtb3ZlSm9icy04JyksXG4gIFtcInJlbW92ZVJlcGVhdGFibGUtMlwiXTogcmVxdWlyZSgnLi9yZW1vdmVSZXBlYXRhYmxlLTInKSxcbiAgW1wicmVwcm9jZXNzSm9iLTZcIl06IHJlcXVpcmUoJy4vcmVwcm9jZXNzSm9iLTYnKSxcbiAgW1wicmV0cnlKb2ItN1wiXTogcmVxdWlyZSgnLi9yZXRyeUpvYi03JyksXG4gIFtcInJldHJ5Sm9icy01XCJdOiByZXF1aXJlKCcuL3JldHJ5Sm9icy01JyksXG4gIFtcInNhdmVTdGFja3RyYWNlLTFcIl06IHJlcXVpcmUoJy4vc2F2ZVN0YWNrdHJhY2UtMScpLFxuICBbXCJ0YWtlTG9jay0xXCJdOiByZXF1aXJlKCcuL3Rha2VMb2NrLTEnKSxcbiAgW1widXBkYXRlRGF0YS0xXCJdOiByZXF1aXJlKCcuL3VwZGF0ZURhdGEtMScpLFxuICBbXCJ1cGRhdGVEZWxheVNldC02XCJdOiByZXF1aXJlKCcuL3VwZGF0ZURlbGF5U2V0LTYnKSxcbiAgW1widXBkYXRlUHJvZ3Jlc3MtMlwiXTogcmVxdWlyZSgnLi91cGRhdGVQcm9ncmVzcy0yJyksXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/index.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/isFinished-2.js":
/*!***********************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/isFinished-2.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Checks if a job is finished (.i.e. is in the completed or failed set)\n  Input: \n    KEYS[1] completed key\n    KEYS[2] failed key\n    ARGV[1] job id\n  Output:\n    0 - not finished.\n    1 - completed.\n    2 - failed.\n]]\nif redis.call(\"ZSCORE\", KEYS[1], ARGV[1]) ~= false then\n  return 1\nend\nif redis.call(\"ZSCORE\", KEYS[2], ARGV[1]) ~= false then\n  return 2\nend\nreturn redis.call(\"ZSCORE\", KEYS[2], ARGV[1])\n`;\nmodule.exports = {\n  name: 'isFinished',\n  content,\n  keys: 2,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9pc0ZpbmlzaGVkLTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvaXNGaW5pc2hlZC0yLmpzPzkxN2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgY29udGVudCA9IGAtLVtbXG4gIENoZWNrcyBpZiBhIGpvYiBpcyBmaW5pc2hlZCAoLmkuZS4gaXMgaW4gdGhlIGNvbXBsZXRlZCBvciBmYWlsZWQgc2V0KVxuICBJbnB1dDogXG4gICAgS0VZU1sxXSBjb21wbGV0ZWQga2V5XG4gICAgS0VZU1syXSBmYWlsZWQga2V5XG4gICAgQVJHVlsxXSBqb2IgaWRcbiAgT3V0cHV0OlxuICAgIDAgLSBub3QgZmluaXNoZWQuXG4gICAgMSAtIGNvbXBsZXRlZC5cbiAgICAyIC0gZmFpbGVkLlxuXV1cbmlmIHJlZGlzLmNhbGwoXCJaU0NPUkVcIiwgS0VZU1sxXSwgQVJHVlsxXSkgfj0gZmFsc2UgdGhlblxuICByZXR1cm4gMVxuZW5kXG5pZiByZWRpcy5jYWxsKFwiWlNDT1JFXCIsIEtFWVNbMl0sIEFSR1ZbMV0pIH49IGZhbHNlIHRoZW5cbiAgcmV0dXJuIDJcbmVuZFxucmV0dXJuIHJlZGlzLmNhbGwoXCJaU0NPUkVcIiwgS0VZU1syXSwgQVJHVlsxXSlcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ2lzRmluaXNoZWQnLFxuICBjb250ZW50LFxuICBrZXlzOiAyLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/isFinished-2.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/isJobInList-1.js":
/*!************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/isJobInList-1.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n      Checks if job is in a given list.\n      Input:\n        KEYS[1]\n        ARGV[1]\n      Output:\n        1 if element found in the list.\n]]\nlocal function item_in_list (list, item)\n  for _, v in pairs(list) do\n    if v == item then\n      return 1\n    end\n  end\n  return nil\nend\nlocal items = redis.call(\"LRANGE\", KEYS[1] , 0, -1)\nreturn item_in_list(items, ARGV[1])\n`;\nmodule.exports = {\n  name: 'isJobInList',\n  content,\n  keys: 1,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9pc0pvYkluTGlzdC0xLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL2lzSm9iSW5MaXN0LTEuanM/NWRjYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgICAgIENoZWNrcyBpZiBqb2IgaXMgaW4gYSBnaXZlbiBsaXN0LlxuICAgICAgSW5wdXQ6XG4gICAgICAgIEtFWVNbMV1cbiAgICAgICAgQVJHVlsxXVxuICAgICAgT3V0cHV0OlxuICAgICAgICAxIGlmIGVsZW1lbnQgZm91bmQgaW4gdGhlIGxpc3QuXG5dXVxubG9jYWwgZnVuY3Rpb24gaXRlbV9pbl9saXN0IChsaXN0LCBpdGVtKVxuICBmb3IgXywgdiBpbiBwYWlycyhsaXN0KSBkb1xuICAgIGlmIHYgPT0gaXRlbSB0aGVuXG4gICAgICByZXR1cm4gMVxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIG5pbFxuZW5kXG5sb2NhbCBpdGVtcyA9IHJlZGlzLmNhbGwoXCJMUkFOR0VcIiwgS0VZU1sxXSAsIDAsIC0xKVxucmV0dXJuIGl0ZW1faW5fbGlzdChpdGVtcywgQVJHVlsxXSlcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ2lzSm9iSW5MaXN0JyxcbiAgY29udGVudCxcbiAga2V5czogMSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/isJobInList-1.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/moveStalledJobsToWait-7.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/moveStalledJobsToWait-7.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Move stalled jobs to wait.\n    Input:\n      KEYS[1] 'stalled' (SET)\n      KEYS[2] 'wait',   (LIST)\n      KEYS[3] 'active', (LIST)\n      KEYS[4] 'failed', (ZSET)\n      KEYS[5] 'stalled-check', (KEY)\n      KEYS[6] 'meta-paused', (KEY)\n      KEYS[7] 'paused', (LIST)\n      ARGV[1]  Max stalled job count\n      ARGV[2]  queue.toKey('')\n      ARGV[3]  timestamp\n      ARGV[4]  max check time\n    Events:\n      'stalled' with stalled job id.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\n--[[\n  Function to remove debounce key if needed.\n]]\nlocal function removeDebounceKeyIfNeeded(prefixKey, debounceId)\n  if debounceId then\n    local debounceKey = prefixKey .. \"de:\" .. debounceId\n    local pttl = rcall(\"PTTL\", debounceKey)\n    if pttl == 0 or pttl == -1 then\n      rcall(\"DEL\", debounceKey)\n    end\n  end\nend\nlocal function removeJob(jobId, baseKey)\n  local jobKey = baseKey .. jobId\n  rcall(\"DEL\", jobKey, jobKey .. ':logs')\nend\nlocal function removeJobsByMaxAge(timestamp, maxAge, targetSet, prefix)\n  local start = timestamp - maxAge * 1000\n  local jobIds = rcall(\"ZREVRANGEBYSCORE\", targetSet, start, \"-inf\")\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, prefix)\n  end\n  rcall(\"ZREMRANGEBYSCORE\", targetSet, \"-inf\", start)\nend\nlocal function removeJobsByMaxCount(maxCount, targetSet, prefix)\n  local start = maxCount\n  local jobIds = rcall(\"ZREVRANGE\", targetSet, start, -1)\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, prefix)\n  end\n  rcall(\"ZREMRANGEBYRANK\", targetSet, 0, -(maxCount + 1))\nend\n-- Check if we need to check for stalled jobs now.\nif rcall(\"EXISTS\", KEYS[5]) == 1 then\n  return {{}, {}}\nend\nrcall(\"SET\", KEYS[5], ARGV[3], \"PX\", ARGV[4])\n-- Move all stalled jobs to wait\nlocal stalling = rcall('SMEMBERS', KEYS[1])\nlocal stalled = {}\nlocal failed = {}\nif(#stalling > 0) then\n  rcall('DEL', KEYS[1])\n  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])\n  -- Remove from active list\n  for i, jobId in ipairs(stalling) do\n    local jobKey = ARGV[2] .. jobId\n    -- Check that the lock is also missing, then we can handle this job as really stalled.\n    if(rcall(\"EXISTS\", jobKey .. \":lock\") == 0) then\n      --  Remove from the active queue.\n      local removed = rcall(\"LREM\", KEYS[3], 1, jobId)\n      if(removed > 0) then\n        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.\n        local stalledCount = rcall(\"HINCRBY\", jobKey, \"stalledCounter\", 1)\n        if(stalledCount > MAX_STALLED_JOB_COUNT) then\n          local jobAttributes = rcall(\"HMGET\", jobKey, \"opts\", \"deid\")\n          local opts = cjson.decode(jobAttributes[1])\n          local removeOnFailType = type(opts[\"removeOnFail\"])\n          rcall(\"ZADD\", KEYS[4], ARGV[3], jobId)\n          rcall(\"HMSET\", jobKey, \"failedReason\", \"job stalled more than allowable limit\",\n            \"finishedOn\", ARGV[3])\n          removeDebounceKeyIfNeeded(ARGV[2], jobAttributes[2])\n          rcall(\"PUBLISH\", KEYS[4],  '{\"jobId\":\"' .. jobId .. '\", \"val\": \"job stalled more than maxStalledCount\"}')\n          if removeOnFailType == \"number\" then\n            removeJobsByMaxCount(opts[\"removeOnFail\"],\n                KEYS[4], ARGV[2])\n          elseif removeOnFailType == \"boolean\" then\n            if opts[\"removeOnFail\"] then\n              removeJob(jobId, ARGV[2])\n              rcall(\"ZREM\", KEYS[4], jobId)\n            end\n          elseif removeOnFailType ~= \"nil\" then\n            local maxAge = opts[\"removeOnFail\"][\"age\"]\n            local maxCount = opts[\"removeOnFail\"][\"count\"]\n            if maxAge ~= nil then\n              removeJobsByMaxAge(ARGV[3], maxAge,\n                KEYS[4], ARGV[2])\n            end\n            if maxCount ~= nil and maxCount > 0 then\n              removeJobsByMaxCount(maxCount, KEYS[4],\n                ARGV[2])\n            end\n          end\n          table.insert(failed, jobId)\n        else\n          local target = getTargetQueueList(KEYS[6], KEYS[2], KEYS[7])\n          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.\n          rcall(\"RPUSH\", target, jobId)\n          rcall('PUBLISH', KEYS[1] .. '@', jobId)\n          table.insert(stalled, jobId)\n        end\n      end\n    end\n  end\nend\n-- Mark potentially stalled jobs\nlocal active = rcall('LRANGE', KEYS[3], 0, -1)\nif (#active > 0) then\n  for from, to in batches(#active, 7000) do\n    rcall('SADD', KEYS[1], unpack(active, from, to))\n  end\nend\nreturn {failed, stalled}\n`;\nmodule.exports = {\n  name: 'moveStalledJobsToWait',\n  content,\n  keys: 7,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9tb3ZlU3RhbGxlZEpvYnNUb1dhaXQtNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBFQUEwRTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL21vdmVTdGFsbGVkSm9ic1RvV2FpdC03LmpzPzU5YmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgY29udGVudCA9IGAtLVtbXG4gIE1vdmUgc3RhbGxlZCBqb2JzIHRvIHdhaXQuXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICdzdGFsbGVkJyAoU0VUKVxuICAgICAgS0VZU1syXSAnd2FpdCcsICAgKExJU1QpXG4gICAgICBLRVlTWzNdICdhY3RpdmUnLCAoTElTVClcbiAgICAgIEtFWVNbNF0gJ2ZhaWxlZCcsIChaU0VUKVxuICAgICAgS0VZU1s1XSAnc3RhbGxlZC1jaGVjaycsIChLRVkpXG4gICAgICBLRVlTWzZdICdtZXRhLXBhdXNlZCcsIChLRVkpXG4gICAgICBLRVlTWzddICdwYXVzZWQnLCAoTElTVClcbiAgICAgIEFSR1ZbMV0gIE1heCBzdGFsbGVkIGpvYiBjb3VudFxuICAgICAgQVJHVlsyXSAgcXVldWUudG9LZXkoJycpXG4gICAgICBBUkdWWzNdICB0aW1lc3RhbXBcbiAgICAgIEFSR1ZbNF0gIG1heCBjaGVjayB0aW1lXG4gICAgRXZlbnRzOlxuICAgICAgJ3N0YWxsZWQnIHdpdGggc3RhbGxlZCBqb2IgaWQuXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBsb29wIGluIGJhdGNoZXMuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgc29tZSBjb21tYW5kcyBhcyBaUkVNXG4gIGNvdWxkIHJlY2VpdmUgYSBtYXhpbXVtIG9mIDcwMDAgcGFyYW1ldGVycyBwZXIgY2FsbC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBiYXRjaGVzKG4sIGJhdGNoU2l6ZSlcbiAgbG9jYWwgaSA9IDBcbiAgcmV0dXJuIGZ1bmN0aW9uKClcbiAgICBsb2NhbCBmcm9tID0gaSAqIGJhdGNoU2l6ZSArIDFcbiAgICBpID0gaSArIDFcbiAgICBpZiAoZnJvbSA8PSBuKSB0aGVuXG4gICAgICBsb2NhbCB0byA9IG1hdGgubWluKGZyb20gKyBiYXRjaFNpemUgLSAxLCBuKVxuICAgICAgcmV0dXJuIGZyb20sIHRvXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBpZiByY2FsbChcIkVYSVNUU1wiLCBxdWV1ZU1ldGFLZXkpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZGVib3VuY2Uga2V5IGlmIG5lZWRlZC5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVEZWJvdW5jZUtleUlmTmVlZGVkKHByZWZpeEtleSwgZGVib3VuY2VJZClcbiAgaWYgZGVib3VuY2VJZCB0aGVuXG4gICAgbG9jYWwgZGVib3VuY2VLZXkgPSBwcmVmaXhLZXkgLi4gXCJkZTpcIiAuLiBkZWJvdW5jZUlkXG4gICAgbG9jYWwgcHR0bCA9IHJjYWxsKFwiUFRUTFwiLCBkZWJvdW5jZUtleSlcbiAgICBpZiBwdHRsID09IDAgb3IgcHR0bCA9PSAtMSB0aGVuXG4gICAgICByY2FsbChcIkRFTFwiLCBkZWJvdW5jZUtleSlcbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYihqb2JJZCwgYmFzZUtleSlcbiAgbG9jYWwgam9iS2V5ID0gYmFzZUtleSAuLiBqb2JJZFxuICByY2FsbChcIkRFTFwiLCBqb2JLZXksIGpvYktleSAuLiAnOmxvZ3MnKVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JzQnlNYXhBZ2UodGltZXN0YW1wLCBtYXhBZ2UsIHRhcmdldFNldCwgcHJlZml4KVxuICBsb2NhbCBzdGFydCA9IHRpbWVzdGFtcCAtIG1heEFnZSAqIDEwMDBcbiAgbG9jYWwgam9iSWRzID0gcmNhbGwoXCJaUkVWUkFOR0VCWVNDT1JFXCIsIHRhcmdldFNldCwgc3RhcnQsIFwiLWluZlwiKVxuICBmb3IgaSwgam9iSWQgaW4gaXBhaXJzKGpvYklkcykgZG9cbiAgICByZW1vdmVKb2Ioam9iSWQsIHByZWZpeClcbiAgZW5kXG4gIHJjYWxsKFwiWlJFTVJBTkdFQllTQ09SRVwiLCB0YXJnZXRTZXQsIFwiLWluZlwiLCBzdGFydClcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9ic0J5TWF4Q291bnQobWF4Q291bnQsIHRhcmdldFNldCwgcHJlZml4KVxuICBsb2NhbCBzdGFydCA9IG1heENvdW50XG4gIGxvY2FsIGpvYklkcyA9IHJjYWxsKFwiWlJFVlJBTkdFXCIsIHRhcmdldFNldCwgc3RhcnQsIC0xKVxuICBmb3IgaSwgam9iSWQgaW4gaXBhaXJzKGpvYklkcykgZG9cbiAgICByZW1vdmVKb2Ioam9iSWQsIHByZWZpeClcbiAgZW5kXG4gIHJjYWxsKFwiWlJFTVJBTkdFQllSQU5LXCIsIHRhcmdldFNldCwgMCwgLShtYXhDb3VudCArIDEpKVxuZW5kXG4tLSBDaGVjayBpZiB3ZSBuZWVkIHRvIGNoZWNrIGZvciBzdGFsbGVkIGpvYnMgbm93LlxuaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1s1XSkgPT0gMSB0aGVuXG4gIHJldHVybiB7e30sIHt9fVxuZW5kXG5yY2FsbChcIlNFVFwiLCBLRVlTWzVdLCBBUkdWWzNdLCBcIlBYXCIsIEFSR1ZbNF0pXG4tLSBNb3ZlIGFsbCBzdGFsbGVkIGpvYnMgdG8gd2FpdFxubG9jYWwgc3RhbGxpbmcgPSByY2FsbCgnU01FTUJFUlMnLCBLRVlTWzFdKVxubG9jYWwgc3RhbGxlZCA9IHt9XG5sb2NhbCBmYWlsZWQgPSB7fVxuaWYoI3N0YWxsaW5nID4gMCkgdGhlblxuICByY2FsbCgnREVMJywgS0VZU1sxXSlcbiAgbG9jYWwgTUFYX1NUQUxMRURfSk9CX0NPVU5UID0gdG9udW1iZXIoQVJHVlsxXSlcbiAgLS0gUmVtb3ZlIGZyb20gYWN0aXZlIGxpc3RcbiAgZm9yIGksIGpvYklkIGluIGlwYWlycyhzdGFsbGluZykgZG9cbiAgICBsb2NhbCBqb2JLZXkgPSBBUkdWWzJdIC4uIGpvYklkXG4gICAgLS0gQ2hlY2sgdGhhdCB0aGUgbG9jayBpcyBhbHNvIG1pc3NpbmcsIHRoZW4gd2UgY2FuIGhhbmRsZSB0aGlzIGpvYiBhcyByZWFsbHkgc3RhbGxlZC5cbiAgICBpZihyY2FsbChcIkVYSVNUU1wiLCBqb2JLZXkgLi4gXCI6bG9ja1wiKSA9PSAwKSB0aGVuXG4gICAgICAtLSAgUmVtb3ZlIGZyb20gdGhlIGFjdGl2ZSBxdWV1ZS5cbiAgICAgIGxvY2FsIHJlbW92ZWQgPSByY2FsbChcIkxSRU1cIiwgS0VZU1szXSwgMSwgam9iSWQpXG4gICAgICBpZihyZW1vdmVkID4gMCkgdGhlblxuICAgICAgICAtLSBJZiB0aGlzIGpvYiBoYXMgYmVlbiBzdGFsbGVkIHRvbyBtYW55IHRpbWVzLCBzdWNoIGFzIGlmIGl0IGNyYXNoZXMgdGhlIHdvcmtlciwgdGhlbiBmYWlsIGl0LlxuICAgICAgICBsb2NhbCBzdGFsbGVkQ291bnQgPSByY2FsbChcIkhJTkNSQllcIiwgam9iS2V5LCBcInN0YWxsZWRDb3VudGVyXCIsIDEpXG4gICAgICAgIGlmKHN0YWxsZWRDb3VudCA+IE1BWF9TVEFMTEVEX0pPQl9DT1VOVCkgdGhlblxuICAgICAgICAgIGxvY2FsIGpvYkF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIGpvYktleSwgXCJvcHRzXCIsIFwiZGVpZFwiKVxuICAgICAgICAgIGxvY2FsIG9wdHMgPSBjanNvbi5kZWNvZGUoam9iQXR0cmlidXRlc1sxXSlcbiAgICAgICAgICBsb2NhbCByZW1vdmVPbkZhaWxUeXBlID0gdHlwZShvcHRzW1wicmVtb3ZlT25GYWlsXCJdKVxuICAgICAgICAgIHJjYWxsKFwiWkFERFwiLCBLRVlTWzRdLCBBUkdWWzNdLCBqb2JJZClcbiAgICAgICAgICByY2FsbChcIkhNU0VUXCIsIGpvYktleSwgXCJmYWlsZWRSZWFzb25cIiwgXCJqb2Igc3RhbGxlZCBtb3JlIHRoYW4gYWxsb3dhYmxlIGxpbWl0XCIsXG4gICAgICAgICAgICBcImZpbmlzaGVkT25cIiwgQVJHVlszXSlcbiAgICAgICAgICByZW1vdmVEZWJvdW5jZUtleUlmTmVlZGVkKEFSR1ZbMl0sIGpvYkF0dHJpYnV0ZXNbMl0pXG4gICAgICAgICAgcmNhbGwoXCJQVUJMSVNIXCIsIEtFWVNbNF0sICAne1wiam9iSWRcIjpcIicgLi4gam9iSWQgLi4gJ1wiLCBcInZhbFwiOiBcImpvYiBzdGFsbGVkIG1vcmUgdGhhbiBtYXhTdGFsbGVkQ291bnRcIn0nKVxuICAgICAgICAgIGlmIHJlbW92ZU9uRmFpbFR5cGUgPT0gXCJudW1iZXJcIiB0aGVuXG4gICAgICAgICAgICByZW1vdmVKb2JzQnlNYXhDb3VudChvcHRzW1wicmVtb3ZlT25GYWlsXCJdLFxuICAgICAgICAgICAgICAgIEtFWVNbNF0sIEFSR1ZbMl0pXG4gICAgICAgICAgZWxzZWlmIHJlbW92ZU9uRmFpbFR5cGUgPT0gXCJib29sZWFuXCIgdGhlblxuICAgICAgICAgICAgaWYgb3B0c1tcInJlbW92ZU9uRmFpbFwiXSB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZUpvYihqb2JJZCwgQVJHVlsyXSlcbiAgICAgICAgICAgICAgcmNhbGwoXCJaUkVNXCIsIEtFWVNbNF0sIGpvYklkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZWlmIHJlbW92ZU9uRmFpbFR5cGUgfj0gXCJuaWxcIiB0aGVuXG4gICAgICAgICAgICBsb2NhbCBtYXhBZ2UgPSBvcHRzW1wicmVtb3ZlT25GYWlsXCJdW1wiYWdlXCJdXG4gICAgICAgICAgICBsb2NhbCBtYXhDb3VudCA9IG9wdHNbXCJyZW1vdmVPbkZhaWxcIl1bXCJjb3VudFwiXVxuICAgICAgICAgICAgaWYgbWF4QWdlIH49IG5pbCB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZUpvYnNCeU1heEFnZShBUkdWWzNdLCBtYXhBZ2UsXG4gICAgICAgICAgICAgICAgS0VZU1s0XSwgQVJHVlsyXSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgaWYgbWF4Q291bnQgfj0gbmlsIGFuZCBtYXhDb3VudCA+IDAgdGhlblxuICAgICAgICAgICAgICByZW1vdmVKb2JzQnlNYXhDb3VudChtYXhDb3VudCwgS0VZU1s0XSxcbiAgICAgICAgICAgICAgICBBUkdWWzJdKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgdGFibGUuaW5zZXJ0KGZhaWxlZCwgam9iSWQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsb2NhbCB0YXJnZXQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QoS0VZU1s2XSwgS0VZU1syXSwgS0VZU1s3XSlcbiAgICAgICAgICAtLSBNb3ZlIHRoZSBqb2IgYmFjayB0byB0aGUgd2FpdCBxdWV1ZSwgdG8gaW1tZWRpYXRlbHkgYmUgcGlja2VkIHVwIGJ5IGEgd2FpdGluZyB3b3JrZXIuXG4gICAgICAgICAgcmNhbGwoXCJSUFVTSFwiLCB0YXJnZXQsIGpvYklkKVxuICAgICAgICAgIHJjYWxsKCdQVUJMSVNIJywgS0VZU1sxXSAuLiAnQCcsIGpvYklkKVxuICAgICAgICAgIHRhYmxlLmluc2VydChzdGFsbGVkLCBqb2JJZClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbi0tIE1hcmsgcG90ZW50aWFsbHkgc3RhbGxlZCBqb2JzXG5sb2NhbCBhY3RpdmUgPSByY2FsbCgnTFJBTkdFJywgS0VZU1szXSwgMCwgLTEpXG5pZiAoI2FjdGl2ZSA+IDApIHRoZW5cbiAgZm9yIGZyb20sIHRvIGluIGJhdGNoZXMoI2FjdGl2ZSwgNzAwMCkgZG9cbiAgICByY2FsbCgnU0FERCcsIEtFWVNbMV0sIHVucGFjayhhY3RpdmUsIGZyb20sIHRvKSlcbiAgZW5kXG5lbmRcbnJldHVybiB7ZmFpbGVkLCBzdGFsbGVkfVxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAnbW92ZVN0YWxsZWRKb2JzVG9XYWl0JyxcbiAgY29udGVudCxcbiAga2V5czogNyxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/moveStalledJobsToWait-7.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/moveToActive-8.js":
/*!*************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/moveToActive-8.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Move next job to be processed to active, lock it and fetch its data. The job\n  may be delayed, in that case we need to move it to the delayed set instead.\n  This operation guarantees that the worker owns the job during the locks\n  expiration time. The worker is responsible of keeping the lock fresh\n  so that no other worker picks this job again.\n  Input:\n      KEYS[1] wait key\n      KEYS[2] active key\n      KEYS[3] priority key\n      KEYS[4] active event key\n      KEYS[5] stalled key\n      -- Rate limiting\n      KEYS[6] rate limiter key\n      KEYS[7] delayed key\n      --\n      KEYS[8] drained key\n      ARGV[1] key prefix\n      ARGV[2] lock token\n      ARGV[3] lock duration in milliseconds\n      ARGV[4] timestamp\n      ARGV[5] optional jobid\n      ARGV[6] optional jobs per time unit (rate limiter)\n      ARGV[7] optional time unit (rate limiter)\n      ARGV[8] optional do not do anything with job if rate limit hit\n      ARGV[9] optional rate limit by key\n]]\nlocal rcall = redis.call\nlocal rateLimit = function(jobId, maxJobs)\n  local rateLimiterKey = KEYS[6];\n  local limiterIndexTable = rateLimiterKey .. \":index\"\n  -- Rate limit by group?\n  if(ARGV[9]) then\n    local group = string.match(jobId, \"[^:]+$\")\n    if group ~= nil then\n      rateLimiterKey = rateLimiterKey .. \":\" .. group\n    end\n  end\n  -- -- key for storing rate limited jobs\n  -- When a job has been previously rate limited it should be part of this set\n  -- if the job is back here means that the delay time for this job has passed and now we should\n  -- be able to process it again.\n  local limitedSetKey = rateLimiterKey .. \":limited\"\n  local delay = 0\n  -- -- Check if job was already limited\n  local isLimited = rcall(\"SISMEMBER\", limitedSetKey, jobId);\n  if isLimited == 1 then\n     -- Remove from limited zset since we are going to try to process it\n     rcall(\"SREM\", limitedSetKey, jobId)\n     rcall(\"HDEL\", limiterIndexTable, jobId)\n  else\n    -- If not, check if there are any limited jobs\n    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that\n    -- is the case we do not want to process this job, just calculate a delay for it and put it to \"sleep\".\n    local numLimitedJobs = rcall(\"SCARD\", limitedSetKey)\n    if numLimitedJobs > 0 then\n      -- Note, add some slack to compensate for drift.\n      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall(\"PTTL\", rateLimiterKey))\n    end\n  end\n  local jobCounter = tonumber(rcall(\"GET\", rateLimiterKey))\n  if(jobCounter == nil) then\n    jobCounter = 0\n  end\n  -- check if rate limit hit\n  if (delay == 0) and (jobCounter >= maxJobs) then\n    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.\n    local exceedingJobs = jobCounter - maxJobs\n    delay = tonumber(rcall(\"PTTL\", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs\n  end\n  if delay > 0 then\n    local bounceBack = ARGV[8]\n    if bounceBack == 'false' then\n      local timestamp = delay + tonumber(ARGV[4])\n      -- put job into delayed queue\n      rcall(\"ZADD\", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)\n      rcall(\"PUBLISH\", KEYS[7], timestamp)\n      rcall(\"SADD\", limitedSetKey, jobId)\n      -- store index so that we can delete rate limited data\n      rcall(\"HSET\", limiterIndexTable, jobId, limitedSetKey)\n    end\n    -- remove from active queue\n    rcall(\"LREM\", KEYS[2], 1, jobId)\n    return true\n  else\n    -- false indicates not rate limited\n    -- increment jobCounter only when a job is not rate limited\n    if (jobCounter == 0) then\n      rcall(\"PSETEX\", rateLimiterKey, ARGV[7], 1)\n    else\n      rcall(\"INCR\", rateLimiterKey)\n    end\n    return false\n  end\nend\nlocal jobId = ARGV[5]\nif jobId ~= '' then\n  -- clean stalled key\n  rcall(\"SREM\", KEYS[5], jobId)\nelse\n  -- move from wait to active\n  jobId = rcall(\"RPOPLPUSH\", KEYS[1], KEYS[2])\nend\nif jobId then\n  -- Check if we need to perform rate limiting.\n  local maxJobs = tonumber(ARGV[6])\n  if maxJobs then\n    if rateLimit(jobId, maxJobs) then\n       return\n    end\n  end\n  -- get a lock\n  local jobKey = ARGV[1] .. jobId\n  local lockKey = jobKey .. ':lock'\n  rcall(\"SET\", lockKey, ARGV[2], \"PX\", ARGV[3])\n  -- remove from priority\n  rcall(\"ZREM\", KEYS[3], jobId)\n  rcall(\"PUBLISH\", KEYS[4], jobId)\n  rcall(\"HSET\", jobKey, \"processedOn\", ARGV[4])\n  return {rcall(\"HGETALL\", jobKey), jobId} -- get job data\nelse\n  rcall(\"PUBLISH\", KEYS[8], \"\")\nend\n`;\nmodule.exports = {\n  name: 'moveToActive',\n  content,\n  keys: 8,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9tb3ZlVG9BY3RpdmUtOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvbW92ZVRvQWN0aXZlLTguanM/ZTgxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgTW92ZSBuZXh0IGpvYiB0byBiZSBwcm9jZXNzZWQgdG8gYWN0aXZlLCBsb2NrIGl0IGFuZCBmZXRjaCBpdHMgZGF0YS4gVGhlIGpvYlxuICBtYXkgYmUgZGVsYXllZCwgaW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gbW92ZSBpdCB0byB0aGUgZGVsYXllZCBzZXQgaW5zdGVhZC5cbiAgVGhpcyBvcGVyYXRpb24gZ3VhcmFudGVlcyB0aGF0IHRoZSB3b3JrZXIgb3ducyB0aGUgam9iIGR1cmluZyB0aGUgbG9ja3NcbiAgZXhwaXJhdGlvbiB0aW1lLiBUaGUgd29ya2VyIGlzIHJlc3BvbnNpYmxlIG9mIGtlZXBpbmcgdGhlIGxvY2sgZnJlc2hcbiAgc28gdGhhdCBubyBvdGhlciB3b3JrZXIgcGlja3MgdGhpcyBqb2IgYWdhaW4uXG4gIElucHV0OlxuICAgICAgS0VZU1sxXSB3YWl0IGtleVxuICAgICAgS0VZU1syXSBhY3RpdmUga2V5XG4gICAgICBLRVlTWzNdIHByaW9yaXR5IGtleVxuICAgICAgS0VZU1s0XSBhY3RpdmUgZXZlbnQga2V5XG4gICAgICBLRVlTWzVdIHN0YWxsZWQga2V5XG4gICAgICAtLSBSYXRlIGxpbWl0aW5nXG4gICAgICBLRVlTWzZdIHJhdGUgbGltaXRlciBrZXlcbiAgICAgIEtFWVNbN10gZGVsYXllZCBrZXlcbiAgICAgIC0tXG4gICAgICBLRVlTWzhdIGRyYWluZWQga2V5XG4gICAgICBBUkdWWzFdIGtleSBwcmVmaXhcbiAgICAgIEFSR1ZbMl0gbG9jayB0b2tlblxuICAgICAgQVJHVlszXSBsb2NrIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgICAgQVJHVls0XSB0aW1lc3RhbXBcbiAgICAgIEFSR1ZbNV0gb3B0aW9uYWwgam9iaWRcbiAgICAgIEFSR1ZbNl0gb3B0aW9uYWwgam9icyBwZXIgdGltZSB1bml0IChyYXRlIGxpbWl0ZXIpXG4gICAgICBBUkdWWzddIG9wdGlvbmFsIHRpbWUgdW5pdCAocmF0ZSBsaW1pdGVyKVxuICAgICAgQVJHVls4XSBvcHRpb25hbCBkbyBub3QgZG8gYW55dGhpbmcgd2l0aCBqb2IgaWYgcmF0ZSBsaW1pdCBoaXRcbiAgICAgIEFSR1ZbOV0gb3B0aW9uYWwgcmF0ZSBsaW1pdCBieSBrZXlcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIHJhdGVMaW1pdCA9IGZ1bmN0aW9uKGpvYklkLCBtYXhKb2JzKVxuICBsb2NhbCByYXRlTGltaXRlcktleSA9IEtFWVNbNl07XG4gIGxvY2FsIGxpbWl0ZXJJbmRleFRhYmxlID0gcmF0ZUxpbWl0ZXJLZXkgLi4gXCI6aW5kZXhcIlxuICAtLSBSYXRlIGxpbWl0IGJ5IGdyb3VwP1xuICBpZihBUkdWWzldKSB0aGVuXG4gICAgbG9jYWwgZ3JvdXAgPSBzdHJpbmcubWF0Y2goam9iSWQsIFwiW146XSskXCIpXG4gICAgaWYgZ3JvdXAgfj0gbmlsIHRoZW5cbiAgICAgIHJhdGVMaW1pdGVyS2V5ID0gcmF0ZUxpbWl0ZXJLZXkgLi4gXCI6XCIgLi4gZ3JvdXBcbiAgICBlbmRcbiAgZW5kXG4gIC0tIC0tIGtleSBmb3Igc3RvcmluZyByYXRlIGxpbWl0ZWQgam9ic1xuICAtLSBXaGVuIGEgam9iIGhhcyBiZWVuIHByZXZpb3VzbHkgcmF0ZSBsaW1pdGVkIGl0IHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMgc2V0XG4gIC0tIGlmIHRoZSBqb2IgaXMgYmFjayBoZXJlIG1lYW5zIHRoYXQgdGhlIGRlbGF5IHRpbWUgZm9yIHRoaXMgam9iIGhhcyBwYXNzZWQgYW5kIG5vdyB3ZSBzaG91bGRcbiAgLS0gYmUgYWJsZSB0byBwcm9jZXNzIGl0IGFnYWluLlxuICBsb2NhbCBsaW1pdGVkU2V0S2V5ID0gcmF0ZUxpbWl0ZXJLZXkgLi4gXCI6bGltaXRlZFwiXG4gIGxvY2FsIGRlbGF5ID0gMFxuICAtLSAtLSBDaGVjayBpZiBqb2Igd2FzIGFscmVhZHkgbGltaXRlZFxuICBsb2NhbCBpc0xpbWl0ZWQgPSByY2FsbChcIlNJU01FTUJFUlwiLCBsaW1pdGVkU2V0S2V5LCBqb2JJZCk7XG4gIGlmIGlzTGltaXRlZCA9PSAxIHRoZW5cbiAgICAgLS0gUmVtb3ZlIGZyb20gbGltaXRlZCB6c2V0IHNpbmNlIHdlIGFyZSBnb2luZyB0byB0cnkgdG8gcHJvY2VzcyBpdFxuICAgICByY2FsbChcIlNSRU1cIiwgbGltaXRlZFNldEtleSwgam9iSWQpXG4gICAgIHJjYWxsKFwiSERFTFwiLCBsaW1pdGVySW5kZXhUYWJsZSwgam9iSWQpXG4gIGVsc2VcbiAgICAtLSBJZiBub3QsIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGltaXRlZCBqb2JzXG4gICAgLS0gSWYgdGhlIGpvYiBoYXMgbm90IGJlZW4gcmF0ZSBsaW1pdGVkLCB3ZSBzaG91bGQgY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBvdGhlciByYXRlIGxpbWl0ZWQgam9icywgYmVjYXVzZSBpZiB0aGF0XG4gICAgLS0gaXMgdGhlIGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gcHJvY2VzcyB0aGlzIGpvYiwganVzdCBjYWxjdWxhdGUgYSBkZWxheSBmb3IgaXQgYW5kIHB1dCBpdCB0byBcInNsZWVwXCIuXG4gICAgbG9jYWwgbnVtTGltaXRlZEpvYnMgPSByY2FsbChcIlNDQVJEXCIsIGxpbWl0ZWRTZXRLZXkpXG4gICAgaWYgbnVtTGltaXRlZEpvYnMgPiAwIHRoZW5cbiAgICAgIC0tIE5vdGUsIGFkZCBzb21lIHNsYWNrIHRvIGNvbXBlbnNhdGUgZm9yIGRyaWZ0LlxuICAgICAgZGVsYXkgPSAoKG51bUxpbWl0ZWRKb2JzICogQVJHVls3XSAqIDEuMSkgLyAgbWF4Sm9icykgKyB0b251bWJlcihyY2FsbChcIlBUVExcIiwgcmF0ZUxpbWl0ZXJLZXkpKVxuICAgIGVuZFxuICBlbmRcbiAgbG9jYWwgam9iQ291bnRlciA9IHRvbnVtYmVyKHJjYWxsKFwiR0VUXCIsIHJhdGVMaW1pdGVyS2V5KSlcbiAgaWYoam9iQ291bnRlciA9PSBuaWwpIHRoZW5cbiAgICBqb2JDb3VudGVyID0gMFxuICBlbmRcbiAgLS0gY2hlY2sgaWYgcmF0ZSBsaW1pdCBoaXRcbiAgaWYgKGRlbGF5ID09IDApIGFuZCAoam9iQ291bnRlciA+PSBtYXhKb2JzKSB0aGVuXG4gICAgLS0gU2VlbXMgbGlrZSB0aGVyZSBhcmUgbm8gY3VycmVudCByYXRlZCBsaW1pdGVkIGpvYnMsIGJ1dCB0aGUgam9iQ291bnRlciBoYXMgZXhjZWVkZWQgdGhlIG51bWJlciBvZiBqb2JzIGZvciB0aGlzIHVuaXQgb2YgdGltZSBzbyB3ZSBuZWVkIHRvIHJhdGUgbGltaXQgdGhpcyBqb2IuXG4gICAgbG9jYWwgZXhjZWVkaW5nSm9icyA9IGpvYkNvdW50ZXIgLSBtYXhKb2JzXG4gICAgZGVsYXkgPSB0b251bWJlcihyY2FsbChcIlBUVExcIiwgcmF0ZUxpbWl0ZXJLZXkpKSArICgoZXhjZWVkaW5nSm9icykgKiBBUkdWWzddKSAvIG1heEpvYnNcbiAgZW5kXG4gIGlmIGRlbGF5ID4gMCB0aGVuXG4gICAgbG9jYWwgYm91bmNlQmFjayA9IEFSR1ZbOF1cbiAgICBpZiBib3VuY2VCYWNrID09ICdmYWxzZScgdGhlblxuICAgICAgbG9jYWwgdGltZXN0YW1wID0gZGVsYXkgKyB0b251bWJlcihBUkdWWzRdKVxuICAgICAgLS0gcHV0IGpvYiBpbnRvIGRlbGF5ZWQgcXVldWVcbiAgICAgIHJjYWxsKFwiWkFERFwiLCBLRVlTWzddLCB0aW1lc3RhbXAgKiAweDEwMDAgKyBiaXQuYmFuZChqb2JDb3VudGVyLCAweGZmZiksIGpvYklkKVxuICAgICAgcmNhbGwoXCJQVUJMSVNIXCIsIEtFWVNbN10sIHRpbWVzdGFtcClcbiAgICAgIHJjYWxsKFwiU0FERFwiLCBsaW1pdGVkU2V0S2V5LCBqb2JJZClcbiAgICAgIC0tIHN0b3JlIGluZGV4IHNvIHRoYXQgd2UgY2FuIGRlbGV0ZSByYXRlIGxpbWl0ZWQgZGF0YVxuICAgICAgcmNhbGwoXCJIU0VUXCIsIGxpbWl0ZXJJbmRleFRhYmxlLCBqb2JJZCwgbGltaXRlZFNldEtleSlcbiAgICBlbmRcbiAgICAtLSByZW1vdmUgZnJvbSBhY3RpdmUgcXVldWVcbiAgICByY2FsbChcIkxSRU1cIiwgS0VZU1syXSwgMSwgam9iSWQpXG4gICAgcmV0dXJuIHRydWVcbiAgZWxzZVxuICAgIC0tIGZhbHNlIGluZGljYXRlcyBub3QgcmF0ZSBsaW1pdGVkXG4gICAgLS0gaW5jcmVtZW50IGpvYkNvdW50ZXIgb25seSB3aGVuIGEgam9iIGlzIG5vdCByYXRlIGxpbWl0ZWRcbiAgICBpZiAoam9iQ291bnRlciA9PSAwKSB0aGVuXG4gICAgICByY2FsbChcIlBTRVRFWFwiLCByYXRlTGltaXRlcktleSwgQVJHVls3XSwgMSlcbiAgICBlbHNlXG4gICAgICByY2FsbChcIklOQ1JcIiwgcmF0ZUxpbWl0ZXJLZXkpXG4gICAgZW5kXG4gICAgcmV0dXJuIGZhbHNlXG4gIGVuZFxuZW5kXG5sb2NhbCBqb2JJZCA9IEFSR1ZbNV1cbmlmIGpvYklkIH49ICcnIHRoZW5cbiAgLS0gY2xlYW4gc3RhbGxlZCBrZXlcbiAgcmNhbGwoXCJTUkVNXCIsIEtFWVNbNV0sIGpvYklkKVxuZWxzZVxuICAtLSBtb3ZlIGZyb20gd2FpdCB0byBhY3RpdmVcbiAgam9iSWQgPSByY2FsbChcIlJQT1BMUFVTSFwiLCBLRVlTWzFdLCBLRVlTWzJdKVxuZW5kXG5pZiBqb2JJZCB0aGVuXG4gIC0tIENoZWNrIGlmIHdlIG5lZWQgdG8gcGVyZm9ybSByYXRlIGxpbWl0aW5nLlxuICBsb2NhbCBtYXhKb2JzID0gdG9udW1iZXIoQVJHVls2XSlcbiAgaWYgbWF4Sm9icyB0aGVuXG4gICAgaWYgcmF0ZUxpbWl0KGpvYklkLCBtYXhKb2JzKSB0aGVuXG4gICAgICAgcmV0dXJuXG4gICAgZW5kXG4gIGVuZFxuICAtLSBnZXQgYSBsb2NrXG4gIGxvY2FsIGpvYktleSA9IEFSR1ZbMV0gLi4gam9iSWRcbiAgbG9jYWwgbG9ja0tleSA9IGpvYktleSAuLiAnOmxvY2snXG4gIHJjYWxsKFwiU0VUXCIsIGxvY2tLZXksIEFSR1ZbMl0sIFwiUFhcIiwgQVJHVlszXSlcbiAgLS0gcmVtb3ZlIGZyb20gcHJpb3JpdHlcbiAgcmNhbGwoXCJaUkVNXCIsIEtFWVNbM10sIGpvYklkKVxuICByY2FsbChcIlBVQkxJU0hcIiwgS0VZU1s0XSwgam9iSWQpXG4gIHJjYWxsKFwiSFNFVFwiLCBqb2JLZXksIFwicHJvY2Vzc2VkT25cIiwgQVJHVls0XSlcbiAgcmV0dXJuIHtyY2FsbChcIkhHRVRBTExcIiwgam9iS2V5KSwgam9iSWR9IC0tIGdldCBqb2IgZGF0YVxuZWxzZVxuICByY2FsbChcIlBVQkxJU0hcIiwgS0VZU1s4XSwgXCJcIilcbmVuZFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAnbW92ZVRvQWN0aXZlJyxcbiAgY29udGVudCxcbiAga2V5czogOCxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/moveToActive-8.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/moveToDelayed-4.js":
/*!**************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/moveToDelayed-4.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Moves job from active to delayed set.\n  Input:\n    KEYS[1] active key\n    KEYS[2] delayed key\n    KEYS[3] job key\n    KEYS[4] stalled key\n    ARGV[1] delayedTimestamp\n    ARGV[2] the id of the job\n    ARGV[3] queue token\n  Output:\n    0 - OK\n   -1 - Missing job.\n   -2 - Job is locked.\n  Events:\n    - delayed key.\n]]\nlocal rcall = redis.call\n-- Includes\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    local lockToken = rcall(\"GET\", lockKey)\n    if lockToken == token then\n      rcall(\"DEL\", lockKey)\n      rcall(\"SREM\", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\nif rcall(\"EXISTS\", KEYS[3]) == 1 then\n  local errorCode = removeLock(KEYS[3], KEYS[4], ARGV[3], ARGV[2])\n  if errorCode < 0 then\n    return errorCode\n  end\n  local numRemovedElements = rcall(\"LREM\", KEYS[1], -1, ARGV[2])\n  if numRemovedElements < 1 then return -3 end\n  local score = tonumber(ARGV[1])\n  rcall(\"ZADD\", KEYS[2], score, ARGV[2])\n  rcall(\"PUBLISH\", KEYS[2], (score / 0x1000))\n  return 0\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'moveToDelayed',\n  content,\n  keys: 4,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9tb3ZlVG9EZWxheWVkLTQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9tb3ZlVG9EZWxheWVkLTQuanM/OTFiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgTW92ZXMgam9iIGZyb20gYWN0aXZlIHRvIGRlbGF5ZWQgc2V0LlxuICBJbnB1dDpcbiAgICBLRVlTWzFdIGFjdGl2ZSBrZXlcbiAgICBLRVlTWzJdIGRlbGF5ZWQga2V5XG4gICAgS0VZU1szXSBqb2Iga2V5XG4gICAgS0VZU1s0XSBzdGFsbGVkIGtleVxuICAgIEFSR1ZbMV0gZGVsYXllZFRpbWVzdGFtcFxuICAgIEFSR1ZbMl0gdGhlIGlkIG9mIHRoZSBqb2JcbiAgICBBUkdWWzNdIHF1ZXVlIHRva2VuXG4gIE91dHB1dDpcbiAgICAwIC0gT0tcbiAgIC0xIC0gTWlzc2luZyBqb2IuXG4gICAtMiAtIEpvYiBpcyBsb2NrZWQuXG4gIEV2ZW50czpcbiAgICAtIGRlbGF5ZWQga2V5LlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUxvY2soam9iS2V5LCBzdGFsbGVkS2V5LCB0b2tlbiwgam9iSWQpXG4gIGlmIHRva2VuIH49IFwiMFwiIHRoZW5cbiAgICBsb2NhbCBsb2NrS2V5ID0gam9iS2V5IC4uICc6bG9jaydcbiAgICBsb2NhbCBsb2NrVG9rZW4gPSByY2FsbChcIkdFVFwiLCBsb2NrS2V5KVxuICAgIGlmIGxvY2tUb2tlbiA9PSB0b2tlbiB0aGVuXG4gICAgICByY2FsbChcIkRFTFwiLCBsb2NrS2V5KVxuICAgICAgcmNhbGwoXCJTUkVNXCIsIHN0YWxsZWRLZXksIGpvYklkKVxuICAgIGVsc2VcbiAgICAgIGlmIGxvY2tUb2tlbiB0aGVuXG4gICAgICAgIC0tIExvY2sgZXhpc3RzIGJ1dCB0b2tlbiBkb2VzIG5vdCBtYXRjaFxuICAgICAgICByZXR1cm4gLTZcbiAgICAgIGVsc2VcbiAgICAgICAgLS0gTG9jayBpcyBtaXNzaW5nIGNvbXBsZXRlbHlcbiAgICAgICAgcmV0dXJuIC0yXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiAwXG5lbmRcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbM10pID09IDEgdGhlblxuICBsb2NhbCBlcnJvckNvZGUgPSByZW1vdmVMb2NrKEtFWVNbM10sIEtFWVNbNF0sIEFSR1ZbM10sIEFSR1ZbMl0pXG4gIGlmIGVycm9yQ29kZSA8IDAgdGhlblxuICAgIHJldHVybiBlcnJvckNvZGVcbiAgZW5kXG4gIGxvY2FsIG51bVJlbW92ZWRFbGVtZW50cyA9IHJjYWxsKFwiTFJFTVwiLCBLRVlTWzFdLCAtMSwgQVJHVlsyXSlcbiAgaWYgbnVtUmVtb3ZlZEVsZW1lbnRzIDwgMSB0aGVuIHJldHVybiAtMyBlbmRcbiAgbG9jYWwgc2NvcmUgPSB0b251bWJlcihBUkdWWzFdKVxuICByY2FsbChcIlpBRERcIiwgS0VZU1syXSwgc2NvcmUsIEFSR1ZbMl0pXG4gIHJjYWxsKFwiUFVCTElTSFwiLCBLRVlTWzJdLCAoc2NvcmUgLyAweDEwMDApKVxuICByZXR1cm4gMFxuZWxzZVxuICByZXR1cm4gLTFcbmVuZFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAnbW92ZVRvRGVsYXllZCcsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDQsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/moveToDelayed-4.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/moveToFinished-9.js":
/*!***************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/moveToFinished-9.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Move job from active to a finished status (completed or failed)\n  A job can only be moved to completed if it was active.\n  The job must be locked before it can be moved to a finished status,\n  and the lock must be released in this script.\n     Input:\n      KEYS[1] active key\n      KEYS[2] completed/failed key\n      KEYS[3] jobId key\n      KEYS[4] wait key\n      KEYS[5] priority key\n      KEYS[6] active event key\n      KEYS[7] delayed key\n      KEYS[8] stalled key\n      KEYS[9] metrics key\n      ARGV[1]  jobId\n      ARGV[2]  timestamp\n      ARGV[3]  msg property\n      ARGV[4]  return value / failed reason\n      ARGV[5]  token\n      ARGV[6]  shouldRemove\n      ARGV[7]  event data (? maybe just send jobid).\n      ARGV[8]  should fetch next job\n      ARGV[9]  base key\n      ARGV[10] lock token\n      ARGV[11] lock duration in milliseconds\n      ARGV[12] maxMetricsSize\n     Output:\n      0 OK\n      -1 Missing key.\n      -2 Missing lock.\n      -3 - Job not in active set.\n     Events:\n      'completed/failed'\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Functions to collect metrics based on a current and previous count of jobs.\n  Granualarity is fixed at 1 minute.\n]]\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\nlocal function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)\n    -- Increment current count\n    local count = rcall(\"HINCRBY\", metaKey, \"count\", 1) - 1\n    -- Compute how many data points we need to add to the list, N.\n    local prevTS = rcall(\"HGET\", metaKey, \"prevTS\")\n    if not prevTS then\n        -- If prevTS is nil, set it to the current timestamp\n        rcall(\"HSET\", metaKey, \"prevTS\", timestamp, \"prevCount\", 0)\n        return\n    end\n    local N = math.min(math.floor(timestamp / 60000) - math.floor(prevTS / 60000), tonumber(maxDataPoints))\n    if N > 0 then\n        local delta = count - rcall(\"HGET\", metaKey, \"prevCount\")\n        -- If N > 1, add N-1 zeros to the list\n        if N > 1 then\n            local points = {}\n            points[1] = delta\n            for i = 2, N do points[i] = 0 end\n            for from, to in batches(#points, 7000) do\n                rcall(\"LPUSH\", dataPointsList, unpack(points, from, to))\n            end\n        else\n            -- LPUSH delta to the list\n            rcall(\"LPUSH\", dataPointsList, delta)\n        end\n        -- LTRIM to keep list to its max size\n        rcall(\"LTRIM\", dataPointsList, 0, maxDataPoints - 1)\n        -- update prev count with current count\n        rcall(\"HSET\", metaKey, \"prevCount\", count, \"prevTS\", timestamp)\n    end\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    local lockToken = rcall(\"GET\", lockKey)\n    if lockToken == token then\n      rcall(\"DEL\", lockKey)\n      rcall(\"SREM\", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\n--[[\n  Function to remove debounce key if needed.\n]]\nlocal function removeDebounceKeyIfNeeded(prefixKey, debounceId)\n  if debounceId then\n    local debounceKey = prefixKey .. \"de:\" .. debounceId\n    local pttl = rcall(\"PTTL\", debounceKey)\n    if pttl == 0 or pttl == -1 then\n      rcall(\"DEL\", debounceKey)\n    end\n  end\nend\nif rcall(\"EXISTS\", KEYS[3]) == 1 then -- // Make sure job exists\n    local errorCode = removeLock(KEYS[3], KEYS[8], ARGV[5], ARGV[1])\n    if errorCode < 0 then\n        return errorCode\n    end\n    -- Remove from active list (if not active we shall return error)\n    local numRemovedElements = rcall(\"LREM\", KEYS[1], -1, ARGV[1])\n    if numRemovedElements < 1 then return -3 end\n    local debounceId = rcall(\"HGET\", KEYS[3], \"deid\")\n    removeDebounceKeyIfNeeded(ARGV[9], debounceId)\n    -- Remove job?\n    local keepJobs = cmsgpack.unpack(ARGV[6])\n    local maxCount = keepJobs['count']\n    local maxAge = keepJobs['age']\n    local targetSet = KEYS[2]\n    local timestamp = ARGV[2]\n    if maxCount ~= 0 then\n        -- Add to complete/failed set\n        rcall(\"ZADD\", targetSet, timestamp, ARGV[1])\n        rcall(\"HMSET\", KEYS[3], ARGV[3], ARGV[4], \"finishedOn\", timestamp) -- \"returnvalue\" / \"failedReason\" and \"finishedOn\"\n        local function removeJobs(jobIds)\n            for i, jobId in ipairs(jobIds) do\n                local jobKey = ARGV[9] .. jobId\n                local jobLogKey = jobKey .. ':logs'\n                rcall(\"DEL\", jobKey, jobLogKey)\n            end\n        end\n        -- Remove old jobs?\n        if maxAge ~= nil then\n            local start = timestamp - maxAge * 1000\n            local jobIds = rcall(\"ZREVRANGEBYSCORE\", targetSet, start, \"-inf\")\n            removeJobs(jobIds)\n            rcall(\"ZREMRANGEBYSCORE\", targetSet, \"-inf\", start)\n        end\n        if maxCount ~= nil and maxCount > 0 then\n            local start = maxCount\n            local jobIds = rcall(\"ZREVRANGE\", targetSet, start, -1)\n            removeJobs(jobIds)\n            rcall(\"ZREMRANGEBYRANK\", targetSet, 0, -(maxCount + 1));\n        end\n    else\n        local jobLogKey = KEYS[3] .. ':logs'\n        rcall(\"DEL\", KEYS[3], jobLogKey)\n    end\n    -- Collect metrics\n    if ARGV[12] ~= \"\" then\n      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)\n    end\n    rcall(\"PUBLISH\", targetSet, ARGV[7])\n    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, \n    -- and not rate limited.\n    if (ARGV[8] == \"1\") then\n        -- move from wait to active \n        local jobId = rcall(\"RPOPLPUSH\", KEYS[4], KEYS[1])\n        if jobId then\n            local jobKey = ARGV[9] .. jobId\n            local lockKey = jobKey .. ':lock'\n            -- get a lock\n            rcall(\"SET\", lockKey, ARGV[11], \"PX\", ARGV[10])\n            rcall(\"ZREM\", KEYS[5], jobId) -- remove from priority\n            rcall(\"PUBLISH\", KEYS[6], jobId)\n            rcall(\"HSET\", jobKey, \"processedOn\", ARGV[2])\n            return {rcall(\"HGETALL\", jobKey), jobId} -- get job data\n        end\n    end\n    return 0\nelse\n    return -1\nend\n`;\nmodule.exports = {\n  name: 'moveToFinished',\n  content,\n  keys: 9,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9tb3ZlVG9GaW5pc2hlZC05LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL21vdmVUb0ZpbmlzaGVkLTkuanM/Y2ZkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgTW92ZSBqb2IgZnJvbSBhY3RpdmUgdG8gYSBmaW5pc2hlZCBzdGF0dXMgKGNvbXBsZXRlZCBvciBmYWlsZWQpXG4gIEEgam9iIGNhbiBvbmx5IGJlIG1vdmVkIHRvIGNvbXBsZXRlZCBpZiBpdCB3YXMgYWN0aXZlLlxuICBUaGUgam9iIG11c3QgYmUgbG9ja2VkIGJlZm9yZSBpdCBjYW4gYmUgbW92ZWQgdG8gYSBmaW5pc2hlZCBzdGF0dXMsXG4gIGFuZCB0aGUgbG9jayBtdXN0IGJlIHJlbGVhc2VkIGluIHRoaXMgc2NyaXB0LlxuICAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gYWN0aXZlIGtleVxuICAgICAgS0VZU1syXSBjb21wbGV0ZWQvZmFpbGVkIGtleVxuICAgICAgS0VZU1szXSBqb2JJZCBrZXlcbiAgICAgIEtFWVNbNF0gd2FpdCBrZXlcbiAgICAgIEtFWVNbNV0gcHJpb3JpdHkga2V5XG4gICAgICBLRVlTWzZdIGFjdGl2ZSBldmVudCBrZXlcbiAgICAgIEtFWVNbN10gZGVsYXllZCBrZXlcbiAgICAgIEtFWVNbOF0gc3RhbGxlZCBrZXlcbiAgICAgIEtFWVNbOV0gbWV0cmljcyBrZXlcbiAgICAgIEFSR1ZbMV0gIGpvYklkXG4gICAgICBBUkdWWzJdICB0aW1lc3RhbXBcbiAgICAgIEFSR1ZbM10gIG1zZyBwcm9wZXJ0eVxuICAgICAgQVJHVls0XSAgcmV0dXJuIHZhbHVlIC8gZmFpbGVkIHJlYXNvblxuICAgICAgQVJHVls1XSAgdG9rZW5cbiAgICAgIEFSR1ZbNl0gIHNob3VsZFJlbW92ZVxuICAgICAgQVJHVls3XSAgZXZlbnQgZGF0YSAoPyBtYXliZSBqdXN0IHNlbmQgam9iaWQpLlxuICAgICAgQVJHVls4XSAgc2hvdWxkIGZldGNoIG5leHQgam9iXG4gICAgICBBUkdWWzldICBiYXNlIGtleVxuICAgICAgQVJHVlsxMF0gbG9jayB0b2tlblxuICAgICAgQVJHVlsxMV0gbG9jayBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgIEFSR1ZbMTJdIG1heE1ldHJpY3NTaXplXG4gICAgIE91dHB1dDpcbiAgICAgIDAgT0tcbiAgICAgIC0xIE1pc3Npbmcga2V5LlxuICAgICAgLTIgTWlzc2luZyBsb2NrLlxuICAgICAgLTMgLSBKb2Igbm90IGluIGFjdGl2ZSBzZXQuXG4gICAgIEV2ZW50czpcbiAgICAgICdjb21wbGV0ZWQvZmFpbGVkJ1xuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGNvbGxlY3QgbWV0cmljcyBiYXNlZCBvbiBhIGN1cnJlbnQgYW5kIHByZXZpb3VzIGNvdW50IG9mIGpvYnMuXG4gIEdyYW51YWxhcml0eSBpcyBmaXhlZCBhdCAxIG1pbnV0ZS5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBsb29wIGluIGJhdGNoZXMuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgc29tZSBjb21tYW5kcyBhcyBaUkVNXG4gIGNvdWxkIHJlY2VpdmUgYSBtYXhpbXVtIG9mIDcwMDAgcGFyYW1ldGVycyBwZXIgY2FsbC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBiYXRjaGVzKG4sIGJhdGNoU2l6ZSlcbiAgbG9jYWwgaSA9IDBcbiAgcmV0dXJuIGZ1bmN0aW9uKClcbiAgICBsb2NhbCBmcm9tID0gaSAqIGJhdGNoU2l6ZSArIDFcbiAgICBpID0gaSArIDFcbiAgICBpZiAoZnJvbSA8PSBuKSB0aGVuXG4gICAgICBsb2NhbCB0byA9IG1hdGgubWluKGZyb20gKyBiYXRjaFNpemUgLSAxLCBuKVxuICAgICAgcmV0dXJuIGZyb20sIHRvXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBjb2xsZWN0TWV0cmljcyhtZXRhS2V5LCBkYXRhUG9pbnRzTGlzdCwgbWF4RGF0YVBvaW50cywgdGltZXN0YW1wKVxuICAgIC0tIEluY3JlbWVudCBjdXJyZW50IGNvdW50XG4gICAgbG9jYWwgY291bnQgPSByY2FsbChcIkhJTkNSQllcIiwgbWV0YUtleSwgXCJjb3VudFwiLCAxKSAtIDFcbiAgICAtLSBDb21wdXRlIGhvdyBtYW55IGRhdGEgcG9pbnRzIHdlIG5lZWQgdG8gYWRkIHRvIHRoZSBsaXN0LCBOLlxuICAgIGxvY2FsIHByZXZUUyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcInByZXZUU1wiKVxuICAgIGlmIG5vdCBwcmV2VFMgdGhlblxuICAgICAgICAtLSBJZiBwcmV2VFMgaXMgbmlsLCBzZXQgaXQgdG8gdGhlIGN1cnJlbnQgdGltZXN0YW1wXG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcInByZXZUU1wiLCB0aW1lc3RhbXAsIFwicHJldkNvdW50XCIsIDApXG4gICAgICAgIHJldHVyblxuICAgIGVuZFxuICAgIGxvY2FsIE4gPSBtYXRoLm1pbihtYXRoLmZsb29yKHRpbWVzdGFtcCAvIDYwMDAwKSAtIG1hdGguZmxvb3IocHJldlRTIC8gNjAwMDApLCB0b251bWJlcihtYXhEYXRhUG9pbnRzKSlcbiAgICBpZiBOID4gMCB0aGVuXG4gICAgICAgIGxvY2FsIGRlbHRhID0gY291bnQgLSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJwcmV2Q291bnRcIilcbiAgICAgICAgLS0gSWYgTiA+IDEsIGFkZCBOLTEgemVyb3MgdG8gdGhlIGxpc3RcbiAgICAgICAgaWYgTiA+IDEgdGhlblxuICAgICAgICAgICAgbG9jYWwgcG9pbnRzID0ge31cbiAgICAgICAgICAgIHBvaW50c1sxXSA9IGRlbHRhXG4gICAgICAgICAgICBmb3IgaSA9IDIsIE4gZG8gcG9pbnRzW2ldID0gMCBlbmRcbiAgICAgICAgICAgIGZvciBmcm9tLCB0byBpbiBiYXRjaGVzKCNwb2ludHMsIDcwMDApIGRvXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJMUFVTSFwiLCBkYXRhUG9pbnRzTGlzdCwgdW5wYWNrKHBvaW50cywgZnJvbSwgdG8pKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIExQVVNIIGRlbHRhIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICByY2FsbChcIkxQVVNIXCIsIGRhdGFQb2ludHNMaXN0LCBkZWx0YSlcbiAgICAgICAgZW5kXG4gICAgICAgIC0tIExUUklNIHRvIGtlZXAgbGlzdCB0byBpdHMgbWF4IHNpemVcbiAgICAgICAgcmNhbGwoXCJMVFJJTVwiLCBkYXRhUG9pbnRzTGlzdCwgMCwgbWF4RGF0YVBvaW50cyAtIDEpXG4gICAgICAgIC0tIHVwZGF0ZSBwcmV2IGNvdW50IHdpdGggY3VycmVudCBjb3VudFxuICAgICAgICByY2FsbChcIkhTRVRcIiwgbWV0YUtleSwgXCJwcmV2Q291bnRcIiwgY291bnQsIFwicHJldlRTXCIsIHRpbWVzdGFtcClcbiAgICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlTG9jayhqb2JLZXksIHN0YWxsZWRLZXksIHRva2VuLCBqb2JJZClcbiAgaWYgdG9rZW4gfj0gXCIwXCIgdGhlblxuICAgIGxvY2FsIGxvY2tLZXkgPSBqb2JLZXkgLi4gJzpsb2NrJ1xuICAgIGxvY2FsIGxvY2tUb2tlbiA9IHJjYWxsKFwiR0VUXCIsIGxvY2tLZXkpXG4gICAgaWYgbG9ja1Rva2VuID09IHRva2VuIHRoZW5cbiAgICAgIHJjYWxsKFwiREVMXCIsIGxvY2tLZXkpXG4gICAgICByY2FsbChcIlNSRU1cIiwgc3RhbGxlZEtleSwgam9iSWQpXG4gICAgZWxzZVxuICAgICAgaWYgbG9ja1Rva2VuIHRoZW5cbiAgICAgICAgLS0gTG9jayBleGlzdHMgYnV0IHRva2VuIGRvZXMgbm90IG1hdGNoXG4gICAgICAgIHJldHVybiAtNlxuICAgICAgZWxzZVxuICAgICAgICAtLSBMb2NrIGlzIG1pc3NpbmcgY29tcGxldGVseVxuICAgICAgICByZXR1cm4gLTJcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIDBcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZGVib3VuY2Uga2V5IGlmIG5lZWRlZC5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVEZWJvdW5jZUtleUlmTmVlZGVkKHByZWZpeEtleSwgZGVib3VuY2VJZClcbiAgaWYgZGVib3VuY2VJZCB0aGVuXG4gICAgbG9jYWwgZGVib3VuY2VLZXkgPSBwcmVmaXhLZXkgLi4gXCJkZTpcIiAuLiBkZWJvdW5jZUlkXG4gICAgbG9jYWwgcHR0bCA9IHJjYWxsKFwiUFRUTFwiLCBkZWJvdW5jZUtleSlcbiAgICBpZiBwdHRsID09IDAgb3IgcHR0bCA9PSAtMSB0aGVuXG4gICAgICByY2FsbChcIkRFTFwiLCBkZWJvdW5jZUtleSlcbiAgICBlbmRcbiAgZW5kXG5lbmRcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbM10pID09IDEgdGhlbiAtLSAvLyBNYWtlIHN1cmUgam9iIGV4aXN0c1xuICAgIGxvY2FsIGVycm9yQ29kZSA9IHJlbW92ZUxvY2soS0VZU1szXSwgS0VZU1s4XSwgQVJHVls1XSwgQVJHVlsxXSlcbiAgICBpZiBlcnJvckNvZGUgPCAwIHRoZW5cbiAgICAgICAgcmV0dXJuIGVycm9yQ29kZVxuICAgIGVuZFxuICAgIC0tIFJlbW92ZSBmcm9tIGFjdGl2ZSBsaXN0IChpZiBub3QgYWN0aXZlIHdlIHNoYWxsIHJldHVybiBlcnJvcilcbiAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIkxSRU1cIiwgS0VZU1sxXSwgLTEsIEFSR1ZbMV0pXG4gICAgaWYgbnVtUmVtb3ZlZEVsZW1lbnRzIDwgMSB0aGVuIHJldHVybiAtMyBlbmRcbiAgICBsb2NhbCBkZWJvdW5jZUlkID0gcmNhbGwoXCJIR0VUXCIsIEtFWVNbM10sIFwiZGVpZFwiKVxuICAgIHJlbW92ZURlYm91bmNlS2V5SWZOZWVkZWQoQVJHVls5XSwgZGVib3VuY2VJZClcbiAgICAtLSBSZW1vdmUgam9iP1xuICAgIGxvY2FsIGtlZXBKb2JzID0gY21zZ3BhY2sudW5wYWNrKEFSR1ZbNl0pXG4gICAgbG9jYWwgbWF4Q291bnQgPSBrZWVwSm9ic1snY291bnQnXVxuICAgIGxvY2FsIG1heEFnZSA9IGtlZXBKb2JzWydhZ2UnXVxuICAgIGxvY2FsIHRhcmdldFNldCA9IEtFWVNbMl1cbiAgICBsb2NhbCB0aW1lc3RhbXAgPSBBUkdWWzJdXG4gICAgaWYgbWF4Q291bnQgfj0gMCB0aGVuXG4gICAgICAgIC0tIEFkZCB0byBjb21wbGV0ZS9mYWlsZWQgc2V0XG4gICAgICAgIHJjYWxsKFwiWkFERFwiLCB0YXJnZXRTZXQsIHRpbWVzdGFtcCwgQVJHVlsxXSlcbiAgICAgICAgcmNhbGwoXCJITVNFVFwiLCBLRVlTWzNdLCBBUkdWWzNdLCBBUkdWWzRdLCBcImZpbmlzaGVkT25cIiwgdGltZXN0YW1wKSAtLSBcInJldHVybnZhbHVlXCIgLyBcImZhaWxlZFJlYXNvblwiIGFuZCBcImZpbmlzaGVkT25cIlxuICAgICAgICBsb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JzKGpvYklkcylcbiAgICAgICAgICAgIGZvciBpLCBqb2JJZCBpbiBpcGFpcnMoam9iSWRzKSBkb1xuICAgICAgICAgICAgICAgIGxvY2FsIGpvYktleSA9IEFSR1ZbOV0gLi4gam9iSWRcbiAgICAgICAgICAgICAgICBsb2NhbCBqb2JMb2dLZXkgPSBqb2JLZXkgLi4gJzpsb2dzJ1xuICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iTG9nS2V5KVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICAtLSBSZW1vdmUgb2xkIGpvYnM/XG4gICAgICAgIGlmIG1heEFnZSB+PSBuaWwgdGhlblxuICAgICAgICAgICAgbG9jYWwgc3RhcnQgPSB0aW1lc3RhbXAgLSBtYXhBZ2UgKiAxMDAwXG4gICAgICAgICAgICBsb2NhbCBqb2JJZHMgPSByY2FsbChcIlpSRVZSQU5HRUJZU0NPUkVcIiwgdGFyZ2V0U2V0LCBzdGFydCwgXCItaW5mXCIpXG4gICAgICAgICAgICByZW1vdmVKb2JzKGpvYklkcylcbiAgICAgICAgICAgIHJjYWxsKFwiWlJFTVJBTkdFQllTQ09SRVwiLCB0YXJnZXRTZXQsIFwiLWluZlwiLCBzdGFydClcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIG1heENvdW50IH49IG5pbCBhbmQgbWF4Q291bnQgPiAwIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIHN0YXJ0ID0gbWF4Q291bnRcbiAgICAgICAgICAgIGxvY2FsIGpvYklkcyA9IHJjYWxsKFwiWlJFVlJBTkdFXCIsIHRhcmdldFNldCwgc3RhcnQsIC0xKVxuICAgICAgICAgICAgcmVtb3ZlSm9icyhqb2JJZHMpXG4gICAgICAgICAgICByY2FsbChcIlpSRU1SQU5HRUJZUkFOS1wiLCB0YXJnZXRTZXQsIDAsIC0obWF4Q291bnQgKyAxKSk7XG4gICAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgICAgbG9jYWwgam9iTG9nS2V5ID0gS0VZU1szXSAuLiAnOmxvZ3MnXG4gICAgICAgIHJjYWxsKFwiREVMXCIsIEtFWVNbM10sIGpvYkxvZ0tleSlcbiAgICBlbmRcbiAgICAtLSBDb2xsZWN0IG1ldHJpY3NcbiAgICBpZiBBUkdWWzEyXSB+PSBcIlwiIHRoZW5cbiAgICAgIGNvbGxlY3RNZXRyaWNzKEtFWVNbOV0sIEtFWVNbOV0uLic6ZGF0YScsIEFSR1ZbMTJdLCB0aW1lc3RhbXApXG4gICAgZW5kXG4gICAgcmNhbGwoXCJQVUJMSVNIXCIsIHRhcmdldFNldCwgQVJHVls3XSlcbiAgICAtLSBUcnkgdG8gZ2V0IG5leHQgam9iIHRvIGF2b2lkIGFuIGV4dHJhIHJvdW5kdHJpcCBpZiB0aGUgcXVldWUgaXMgbm90IGNsb3NpbmcsIFxuICAgIC0tIGFuZCBub3QgcmF0ZSBsaW1pdGVkLlxuICAgIGlmIChBUkdWWzhdID09IFwiMVwiKSB0aGVuXG4gICAgICAgIC0tIG1vdmUgZnJvbSB3YWl0IHRvIGFjdGl2ZSBcbiAgICAgICAgbG9jYWwgam9iSWQgPSByY2FsbChcIlJQT1BMUFVTSFwiLCBLRVlTWzRdLCBLRVlTWzFdKVxuICAgICAgICBpZiBqb2JJZCB0aGVuXG4gICAgICAgICAgICBsb2NhbCBqb2JLZXkgPSBBUkdWWzldIC4uIGpvYklkXG4gICAgICAgICAgICBsb2NhbCBsb2NrS2V5ID0gam9iS2V5IC4uICc6bG9jaydcbiAgICAgICAgICAgIC0tIGdldCBhIGxvY2tcbiAgICAgICAgICAgIHJjYWxsKFwiU0VUXCIsIGxvY2tLZXksIEFSR1ZbMTFdLCBcIlBYXCIsIEFSR1ZbMTBdKVxuICAgICAgICAgICAgcmNhbGwoXCJaUkVNXCIsIEtFWVNbNV0sIGpvYklkKSAtLSByZW1vdmUgZnJvbSBwcmlvcml0eVxuICAgICAgICAgICAgcmNhbGwoXCJQVUJMSVNIXCIsIEtFWVNbNl0sIGpvYklkKVxuICAgICAgICAgICAgcmNhbGwoXCJIU0VUXCIsIGpvYktleSwgXCJwcm9jZXNzZWRPblwiLCBBUkdWWzJdKVxuICAgICAgICAgICAgcmV0dXJuIHtyY2FsbChcIkhHRVRBTExcIiwgam9iS2V5KSwgam9iSWR9IC0tIGdldCBqb2IgZGF0YVxuICAgICAgICBlbmRcbiAgICBlbmRcbiAgICByZXR1cm4gMFxuZWxzZVxuICAgIHJldHVybiAtMVxuZW5kXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdtb3ZlVG9GaW5pc2hlZCcsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDksXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/moveToFinished-9.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/obliterate-2.js":
/*!***********************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/obliterate-2.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n    Completely obliterates a queue and all of its contents\n     Input:\n        KEYS[1] meta-paused\n        KEYS[2] base\n        ARGV[1]  count\n        ARGV[2]  force\n]] \n-- This command completely destroys a queue including all of its jobs, current or past \n-- leaving no trace of its existence. Since this script needs to iterate to find all the job\n-- keys, consider that this call may be slow for very large queues.\n-- The queue needs to be \"paused\" or it will return an error\n-- If the queue has currently active jobs then the script by default will return error,\n-- however this behaviour can be overrided using the 'force' option.\nlocal maxCount = tonumber(ARGV[1])\nlocal baseKey = KEYS[2]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to remove debounce key.\n]]\nlocal function removeDebounceKey(prefixKey, jobKey)\n  local debounceId = rcall(\"HGET\", jobKey, \"deid\")\n  if debounceId then\n    local debounceKey = prefixKey .. \"de:\" .. debounceId\n    rcall(\"DEL\", debounceKey)\n  end\nend\nlocal function getListItems(keyName, max)\n    return rcall('LRANGE', keyName, 0, max - 1)\nend\nlocal function getZSetItems(keyName, max)\n    return rcall('ZRANGE', keyName, 0, max - 1)\nend\nlocal function removeJobs(baseKey, keys)\n    for i, key in ipairs(keys) do\n        local jobKey = baseKey .. key\n        rcall(\"DEL\", jobKey, jobKey .. ':logs')\n        removeDebounceKey(baseKey, jobKey)\n    end\n    maxCount = maxCount - #keys\nend\nlocal function removeListJobs(keyName, max)\n    local jobs = getListItems(keyName, max)\n    removeJobs(baseKey, jobs)\n    rcall(\"LTRIM\", keyName, #jobs, -1)\nend\nlocal function removeZSetJobs(keyName, max)\n    local jobs = getZSetItems(keyName, max)\n    removeJobs(baseKey, jobs)\n    if (#jobs > 0) then rcall(\"ZREM\", keyName, unpack(jobs)) end\nend\nlocal function removeLockKeys(keys)\n    for i, key in ipairs(keys) do rcall(\"DEL\", baseKey .. key .. ':lock') end\nend\n-- 1) Check if paused, if not return with error.\nif rcall(\"EXISTS\", KEYS[1]) ~= 1 then\n    return -1 -- Error, NotPaused\nend\n-- 2) Check if there are active jobs, if there are and not \"force\" return error.\nlocal activeKey = baseKey .. 'active'\nlocal activeJobs = getListItems(activeKey, maxCount)\nif (#activeJobs > 0) then\n    if (ARGV[2] == \"\") then\n        return -2 -- Error, ExistsActiveJobs\n    end\nend\nremoveLockKeys(activeJobs)\nremoveJobs(baseKey, activeJobs)\nrcall(\"LTRIM\", activeKey, #activeJobs, -1)\nif (maxCount <= 0) then return 1 end\nlocal waitKey = baseKey .. 'paused'\nremoveListJobs(waitKey, maxCount)\nif (maxCount <= 0) then return 1 end\nlocal delayedKey = baseKey .. 'delayed'\nremoveZSetJobs(delayedKey, maxCount)\nif (maxCount <= 0) then return 1 end\nlocal completedKey = baseKey .. 'completed'\nremoveZSetJobs(completedKey, maxCount)\nif (maxCount <= 0) then return 1 end\nlocal failedKey = baseKey .. 'failed'\nremoveZSetJobs(failedKey, maxCount)\nif (maxCount <= 0) then return 1 end\nif (maxCount > 0) then\n    rcall(\"DEL\", baseKey .. 'priority')\n    rcall(\"DEL\", baseKey .. 'stalled-check')\n    rcall(\"DEL\", baseKey .. 'stalled')\n    rcall(\"DEL\", baseKey .. 'meta-paused')\n    rcall(\"DEL\", baseKey .. 'meta')\n    rcall(\"DEL\", baseKey .. 'id')\n    rcall(\"DEL\", baseKey .. 'repeat')\n    rcall(\"DEL\", baseKey .. 'metrics:completed')\n    rcall(\"DEL\", baseKey .. 'metrics:completed:data')\n    rcall(\"DEL\", baseKey .. 'metrics:failed')\n    rcall(\"DEL\", baseKey .. 'metrics:failed:data')\n    return 0\nelse\n    return 1\nend\n`;\nmodule.exports = {\n  name: 'obliterate',\n  content,\n  keys: 2,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9vYmxpdGVyYXRlLTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvb2JsaXRlcmF0ZS0yLmpzP2JmODIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgY29udGVudCA9IGAtLVtbXG4gICAgQ29tcGxldGVseSBvYmxpdGVyYXRlcyBhIHF1ZXVlIGFuZCBhbGwgb2YgaXRzIGNvbnRlbnRzXG4gICAgIElucHV0OlxuICAgICAgICBLRVlTWzFdIG1ldGEtcGF1c2VkXG4gICAgICAgIEtFWVNbMl0gYmFzZVxuICAgICAgICBBUkdWWzFdICBjb3VudFxuICAgICAgICBBUkdWWzJdICBmb3JjZVxuXV0gXG4tLSBUaGlzIGNvbW1hbmQgY29tcGxldGVseSBkZXN0cm95cyBhIHF1ZXVlIGluY2x1ZGluZyBhbGwgb2YgaXRzIGpvYnMsIGN1cnJlbnQgb3IgcGFzdCBcbi0tIGxlYXZpbmcgbm8gdHJhY2Ugb2YgaXRzIGV4aXN0ZW5jZS4gU2luY2UgdGhpcyBzY3JpcHQgbmVlZHMgdG8gaXRlcmF0ZSB0byBmaW5kIGFsbCB0aGUgam9iXG4tLSBrZXlzLCBjb25zaWRlciB0aGF0IHRoaXMgY2FsbCBtYXkgYmUgc2xvdyBmb3IgdmVyeSBsYXJnZSBxdWV1ZXMuXG4tLSBUaGUgcXVldWUgbmVlZHMgdG8gYmUgXCJwYXVzZWRcIiBvciBpdCB3aWxsIHJldHVybiBhbiBlcnJvclxuLS0gSWYgdGhlIHF1ZXVlIGhhcyBjdXJyZW50bHkgYWN0aXZlIGpvYnMgdGhlbiB0aGUgc2NyaXB0IGJ5IGRlZmF1bHQgd2lsbCByZXR1cm4gZXJyb3IsXG4tLSBob3dldmVyIHRoaXMgYmVoYXZpb3VyIGNhbiBiZSBvdmVycmlkZWQgdXNpbmcgdGhlICdmb3JjZScgb3B0aW9uLlxubG9jYWwgbWF4Q291bnQgPSB0b251bWJlcihBUkdWWzFdKVxubG9jYWwgYmFzZUtleSA9IEtFWVNbMl1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGRlYm91bmNlIGtleS5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVEZWJvdW5jZUtleShwcmVmaXhLZXksIGpvYktleSlcbiAgbG9jYWwgZGVib3VuY2VJZCA9IHJjYWxsKFwiSEdFVFwiLCBqb2JLZXksIFwiZGVpZFwiKVxuICBpZiBkZWJvdW5jZUlkIHRoZW5cbiAgICBsb2NhbCBkZWJvdW5jZUtleSA9IHByZWZpeEtleSAuLiBcImRlOlwiIC4uIGRlYm91bmNlSWRcbiAgICByY2FsbChcIkRFTFwiLCBkZWJvdW5jZUtleSlcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGdldExpc3RJdGVtcyhrZXlOYW1lLCBtYXgpXG4gICAgcmV0dXJuIHJjYWxsKCdMUkFOR0UnLCBrZXlOYW1lLCAwLCBtYXggLSAxKVxuZW5kXG5sb2NhbCBmdW5jdGlvbiBnZXRaU2V0SXRlbXMoa2V5TmFtZSwgbWF4KVxuICAgIHJldHVybiByY2FsbCgnWlJBTkdFJywga2V5TmFtZSwgMCwgbWF4IC0gMSlcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9icyhiYXNlS2V5LCBrZXlzKVxuICAgIGZvciBpLCBrZXkgaW4gaXBhaXJzKGtleXMpIGRvXG4gICAgICAgIGxvY2FsIGpvYktleSA9IGJhc2VLZXkgLi4ga2V5XG4gICAgICAgIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycpXG4gICAgICAgIHJlbW92ZURlYm91bmNlS2V5KGJhc2VLZXksIGpvYktleSlcbiAgICBlbmRcbiAgICBtYXhDb3VudCA9IG1heENvdW50IC0gI2tleXNcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlTGlzdEpvYnMoa2V5TmFtZSwgbWF4KVxuICAgIGxvY2FsIGpvYnMgPSBnZXRMaXN0SXRlbXMoa2V5TmFtZSwgbWF4KVxuICAgIHJlbW92ZUpvYnMoYmFzZUtleSwgam9icylcbiAgICByY2FsbChcIkxUUklNXCIsIGtleU5hbWUsICNqb2JzLCAtMSlcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlWlNldEpvYnMoa2V5TmFtZSwgbWF4KVxuICAgIGxvY2FsIGpvYnMgPSBnZXRaU2V0SXRlbXMoa2V5TmFtZSwgbWF4KVxuICAgIHJlbW92ZUpvYnMoYmFzZUtleSwgam9icylcbiAgICBpZiAoI2pvYnMgPiAwKSB0aGVuIHJjYWxsKFwiWlJFTVwiLCBrZXlOYW1lLCB1bnBhY2soam9icykpIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVMb2NrS2V5cyhrZXlzKVxuICAgIGZvciBpLCBrZXkgaW4gaXBhaXJzKGtleXMpIGRvIHJjYWxsKFwiREVMXCIsIGJhc2VLZXkgLi4ga2V5IC4uICc6bG9jaycpIGVuZFxuZW5kXG4tLSAxKSBDaGVjayBpZiBwYXVzZWQsIGlmIG5vdCByZXR1cm4gd2l0aCBlcnJvci5cbmlmIHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbMV0pIH49IDEgdGhlblxuICAgIHJldHVybiAtMSAtLSBFcnJvciwgTm90UGF1c2VkXG5lbmRcbi0tIDIpIENoZWNrIGlmIHRoZXJlIGFyZSBhY3RpdmUgam9icywgaWYgdGhlcmUgYXJlIGFuZCBub3QgXCJmb3JjZVwiIHJldHVybiBlcnJvci5cbmxvY2FsIGFjdGl2ZUtleSA9IGJhc2VLZXkgLi4gJ2FjdGl2ZSdcbmxvY2FsIGFjdGl2ZUpvYnMgPSBnZXRMaXN0SXRlbXMoYWN0aXZlS2V5LCBtYXhDb3VudClcbmlmICgjYWN0aXZlSm9icyA+IDApIHRoZW5cbiAgICBpZiAoQVJHVlsyXSA9PSBcIlwiKSB0aGVuXG4gICAgICAgIHJldHVybiAtMiAtLSBFcnJvciwgRXhpc3RzQWN0aXZlSm9ic1xuICAgIGVuZFxuZW5kXG5yZW1vdmVMb2NrS2V5cyhhY3RpdmVKb2JzKVxucmVtb3ZlSm9icyhiYXNlS2V5LCBhY3RpdmVKb2JzKVxucmNhbGwoXCJMVFJJTVwiLCBhY3RpdmVLZXksICNhY3RpdmVKb2JzLCAtMSlcbmlmIChtYXhDb3VudCA8PSAwKSB0aGVuIHJldHVybiAxIGVuZFxubG9jYWwgd2FpdEtleSA9IGJhc2VLZXkgLi4gJ3BhdXNlZCdcbnJlbW92ZUxpc3RKb2JzKHdhaXRLZXksIG1heENvdW50KVxuaWYgKG1heENvdW50IDw9IDApIHRoZW4gcmV0dXJuIDEgZW5kXG5sb2NhbCBkZWxheWVkS2V5ID0gYmFzZUtleSAuLiAnZGVsYXllZCdcbnJlbW92ZVpTZXRKb2JzKGRlbGF5ZWRLZXksIG1heENvdW50KVxuaWYgKG1heENvdW50IDw9IDApIHRoZW4gcmV0dXJuIDEgZW5kXG5sb2NhbCBjb21wbGV0ZWRLZXkgPSBiYXNlS2V5IC4uICdjb21wbGV0ZWQnXG5yZW1vdmVaU2V0Sm9icyhjb21wbGV0ZWRLZXksIG1heENvdW50KVxuaWYgKG1heENvdW50IDw9IDApIHRoZW4gcmV0dXJuIDEgZW5kXG5sb2NhbCBmYWlsZWRLZXkgPSBiYXNlS2V5IC4uICdmYWlsZWQnXG5yZW1vdmVaU2V0Sm9icyhmYWlsZWRLZXksIG1heENvdW50KVxuaWYgKG1heENvdW50IDw9IDApIHRoZW4gcmV0dXJuIDEgZW5kXG5pZiAobWF4Q291bnQgPiAwKSB0aGVuXG4gICAgcmNhbGwoXCJERUxcIiwgYmFzZUtleSAuLiAncHJpb3JpdHknKVxuICAgIHJjYWxsKFwiREVMXCIsIGJhc2VLZXkgLi4gJ3N0YWxsZWQtY2hlY2snKVxuICAgIHJjYWxsKFwiREVMXCIsIGJhc2VLZXkgLi4gJ3N0YWxsZWQnKVxuICAgIHJjYWxsKFwiREVMXCIsIGJhc2VLZXkgLi4gJ21ldGEtcGF1c2VkJylcbiAgICByY2FsbChcIkRFTFwiLCBiYXNlS2V5IC4uICdtZXRhJylcbiAgICByY2FsbChcIkRFTFwiLCBiYXNlS2V5IC4uICdpZCcpXG4gICAgcmNhbGwoXCJERUxcIiwgYmFzZUtleSAuLiAncmVwZWF0JylcbiAgICByY2FsbChcIkRFTFwiLCBiYXNlS2V5IC4uICdtZXRyaWNzOmNvbXBsZXRlZCcpXG4gICAgcmNhbGwoXCJERUxcIiwgYmFzZUtleSAuLiAnbWV0cmljczpjb21wbGV0ZWQ6ZGF0YScpXG4gICAgcmNhbGwoXCJERUxcIiwgYmFzZUtleSAuLiAnbWV0cmljczpmYWlsZWQnKVxuICAgIHJjYWxsKFwiREVMXCIsIGJhc2VLZXkgLi4gJ21ldHJpY3M6ZmFpbGVkOmRhdGEnKVxuICAgIHJldHVybiAwXG5lbHNlXG4gICAgcmV0dXJuIDFcbmVuZFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAnb2JsaXRlcmF0ZScsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDIsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/obliterate-2.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/pause-5.js":
/*!******************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/pause-5.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Pauses or resumes a queue globably.\n   Input:\n      KEYS[1] 'wait' or 'paused''\n      KEYS[2] 'paused' or 'wait'\n      KEYS[3] 'meta-paused'\n      KEYS[4] 'paused' o 'resumed' event.\n      KEYS[5] 'meta' this key is only used in BullMQ and above.\n      ARGV[1] 'paused' or 'resumed'\n    Event:\n      publish paused or resumed event.\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[1]) == 1 then\n  rcall(\"RENAME\", KEYS[1], KEYS[2])\nend\nif ARGV[1] == \"paused\" then\n  rcall(\"SET\", KEYS[3], 1)\n  -- for forwards compatibility\n  rcall(\"HSET\", KEYS[5], \"paused\", 1)\nelse\n  rcall(\"DEL\", KEYS[3])\n  -- for forwards compatibility\n  rcall(\"HDEL\", KEYS[5], \"paused\")\nend\nrcall(\"PUBLISH\", KEYS[4], ARGV[1])\n`;\nmodule.exports = {\n  name: 'pause',\n  content,\n  keys: 5,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9wYXVzZS01LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9wYXVzZS01LmpzP2Q5NmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgY29udGVudCA9IGAtLVtbXG4gIFBhdXNlcyBvciByZXN1bWVzIGEgcXVldWUgZ2xvYmFibHkuXG4gICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gJ3dhaXQnIG9yICdwYXVzZWQnJ1xuICAgICAgS0VZU1syXSAncGF1c2VkJyBvciAnd2FpdCdcbiAgICAgIEtFWVNbM10gJ21ldGEtcGF1c2VkJ1xuICAgICAgS0VZU1s0XSAncGF1c2VkJyBvICdyZXN1bWVkJyBldmVudC5cbiAgICAgIEtFWVNbNV0gJ21ldGEnIHRoaXMga2V5IGlzIG9ubHkgdXNlZCBpbiBCdWxsTVEgYW5kIGFib3ZlLlxuICAgICAgQVJHVlsxXSAncGF1c2VkJyBvciAncmVzdW1lZCdcbiAgICBFdmVudDpcbiAgICAgIHB1Ymxpc2ggcGF1c2VkIG9yIHJlc3VtZWQgZXZlbnQuXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5pZiByY2FsbChcIkVYSVNUU1wiLCBLRVlTWzFdKSA9PSAxIHRoZW5cbiAgcmNhbGwoXCJSRU5BTUVcIiwgS0VZU1sxXSwgS0VZU1syXSlcbmVuZFxuaWYgQVJHVlsxXSA9PSBcInBhdXNlZFwiIHRoZW5cbiAgcmNhbGwoXCJTRVRcIiwgS0VZU1szXSwgMSlcbiAgLS0gZm9yIGZvcndhcmRzIGNvbXBhdGliaWxpdHlcbiAgcmNhbGwoXCJIU0VUXCIsIEtFWVNbNV0sIFwicGF1c2VkXCIsIDEpXG5lbHNlXG4gIHJjYWxsKFwiREVMXCIsIEtFWVNbM10pXG4gIC0tIGZvciBmb3J3YXJkcyBjb21wYXRpYmlsaXR5XG4gIHJjYWxsKFwiSERFTFwiLCBLRVlTWzVdLCBcInBhdXNlZFwiKVxuZW5kXG5yY2FsbChcIlBVQkxJU0hcIiwgS0VZU1s0XSwgQVJHVlsxXSlcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3BhdXNlJyxcbiAgY29udGVudCxcbiAga2V5czogNSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/pause-5.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/promote-5.js":
/*!********************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/promote-5.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Promotes a job that is currently \"delayed\" to the \"waiting\" state\n     Input:\n      KEYS[1] 'delayed'\n      KEYS[2] 'wait'\n      KEYS[3] 'paused'\n      KEYS[4] 'meta-paused'\n      KEYS[5] 'priority'\n      ARGV[1]  queue.toKey('')\n      ARGV[2]  jobId\n      ARGV[3]  queue token\n     Events:\n      'waiting'\n]]\nlocal rcall = redis.call;\nlocal jobId = ARGV[2]\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\nlocal function addJobWithPriority(priorityKey, priority, jobId, targetKey)\n  rcall(\"ZADD\", priorityKey, priority, jobId)\n  local count = rcall(\"ZCOUNT\", priorityKey, 0, priority)\n  local len = rcall(\"LLEN\", targetKey)\n  local id = rcall(\"LINDEX\", targetKey, len - (count - 1))\n  if id then\n    rcall(\"LINSERT\", targetKey, \"BEFORE\", id, jobId)\n  else\n    rcall(\"RPUSH\", targetKey, jobId)\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nif rcall(\"ZREM\", KEYS[1], jobId) == 1 then\n  local priority = tonumber(rcall(\"HGET\", ARGV[1] .. jobId, \"priority\")) or 0\n  local target = getTargetQueueList(KEYS[4], KEYS[2], KEYS[3])\n  if priority == 0 then\n    -- LIFO or FIFO\n    rcall(\"LPUSH\", target, jobId)\n  else\n    addJobWithPriority(KEYS[5], priority, jobId, target)\n  end\n  -- Emit waiting event (wait..ing@token)\n  rcall(\"PUBLISH\", KEYS[2] .. \"ing@\" .. ARGV[3], jobId)\n  rcall(\"HSET\", ARGV[1] .. jobId, \"delay\", 0)\n  return 0\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'promote',\n  content,\n  keys: 5,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9wcm9tb3RlLTUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9wcm9tb3RlLTUuanM/ODE0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgUHJvbW90ZXMgYSBqb2IgdGhhdCBpcyBjdXJyZW50bHkgXCJkZWxheWVkXCIgdG8gdGhlIFwid2FpdGluZ1wiIHN0YXRlXG4gICAgIElucHV0OlxuICAgICAgS0VZU1sxXSAnZGVsYXllZCdcbiAgICAgIEtFWVNbMl0gJ3dhaXQnXG4gICAgICBLRVlTWzNdICdwYXVzZWQnXG4gICAgICBLRVlTWzRdICdtZXRhLXBhdXNlZCdcbiAgICAgIEtFWVNbNV0gJ3ByaW9yaXR5J1xuICAgICAgQVJHVlsxXSAgcXVldWUudG9LZXkoJycpXG4gICAgICBBUkdWWzJdICBqb2JJZFxuICAgICAgQVJHVlszXSAgcXVldWUgdG9rZW5cbiAgICAgRXZlbnRzOlxuICAgICAgJ3dhaXRpbmcnXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsO1xubG9jYWwgam9iSWQgPSBBUkdWWzJdXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5LlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYldpdGhQcmlvcml0eShwcmlvcml0eUtleSwgcHJpb3JpdHksIGpvYklkLCB0YXJnZXRLZXkpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0eUtleSwgcHJpb3JpdHksIGpvYklkKVxuICBsb2NhbCBjb3VudCA9IHJjYWxsKFwiWkNPVU5UXCIsIHByaW9yaXR5S2V5LCAwLCBwcmlvcml0eSlcbiAgbG9jYWwgbGVuID0gcmNhbGwoXCJMTEVOXCIsIHRhcmdldEtleSlcbiAgbG9jYWwgaWQgPSByY2FsbChcIkxJTkRFWFwiLCB0YXJnZXRLZXksIGxlbiAtIChjb3VudCAtIDEpKVxuICBpZiBpZCB0aGVuXG4gICAgcmNhbGwoXCJMSU5TRVJUXCIsIHRhcmdldEtleSwgXCJCRUZPUkVcIiwgaWQsIGpvYklkKVxuICBlbHNlXG4gICAgcmNhbGwoXCJSUFVTSFwiLCB0YXJnZXRLZXksIGpvYklkKVxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgaWYgcmNhbGwoXCJFWElTVFNcIiwgcXVldWVNZXRhS2V5KSB+PSAxIHRoZW5cbiAgICByZXR1cm4gd2FpdEtleSwgZmFsc2VcbiAgZWxzZVxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWVcbiAgZW5kXG5lbmRcbmlmIHJjYWxsKFwiWlJFTVwiLCBLRVlTWzFdLCBqb2JJZCkgPT0gMSB0aGVuXG4gIGxvY2FsIHByaW9yaXR5ID0gdG9udW1iZXIocmNhbGwoXCJIR0VUXCIsIEFSR1ZbMV0gLi4gam9iSWQsIFwicHJpb3JpdHlcIikpIG9yIDBcbiAgbG9jYWwgdGFyZ2V0ID0gZ2V0VGFyZ2V0UXVldWVMaXN0KEtFWVNbNF0sIEtFWVNbMl0sIEtFWVNbM10pXG4gIGlmIHByaW9yaXR5ID09IDAgdGhlblxuICAgIC0tIExJRk8gb3IgRklGT1xuICAgIHJjYWxsKFwiTFBVU0hcIiwgdGFyZ2V0LCBqb2JJZClcbiAgZWxzZVxuICAgIGFkZEpvYldpdGhQcmlvcml0eShLRVlTWzVdLCBwcmlvcml0eSwgam9iSWQsIHRhcmdldClcbiAgZW5kXG4gIC0tIEVtaXQgd2FpdGluZyBldmVudCAod2FpdC4uaW5nQHRva2VuKVxuICByY2FsbChcIlBVQkxJU0hcIiwgS0VZU1syXSAuLiBcImluZ0BcIiAuLiBBUkdWWzNdLCBqb2JJZClcbiAgcmNhbGwoXCJIU0VUXCIsIEFSR1ZbMV0gLi4gam9iSWQsIFwiZGVsYXlcIiwgMClcbiAgcmV0dXJuIDBcbmVsc2VcbiAgcmV0dXJuIC0xXG5lbmRcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3Byb21vdGUnLFxuICBjb250ZW50LFxuICBrZXlzOiA1LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/promote-5.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/releaseLock-1.js":
/*!************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/releaseLock-1.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Release lock\n     Input:\n        KEYS[1] 'lock',\n        ARGV[1]  token\n        ARGV[2]  lock duration in milliseconds\n      Output:\n        \"OK\" if lock extented succesfully.\n]]\nlocal rcall = redis.call\nif rcall(\"GET\", KEYS[1]) == ARGV[1] then\n  return rcall(\"DEL\", KEYS[1])\nelse\n  return 0\nend\n`;\nmodule.exports = {\n  name: 'releaseLock',\n  content,\n  keys: 1,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZWxlYXNlTG9jay0xLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL3JlbGVhc2VMb2NrLTEuanM/ZjNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgUmVsZWFzZSBsb2NrXG4gICAgIElucHV0OlxuICAgICAgICBLRVlTWzFdICdsb2NrJyxcbiAgICAgICAgQVJHVlsxXSAgdG9rZW5cbiAgICAgICAgQVJHVlsyXSAgbG9jayBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgIE91dHB1dDpcbiAgICAgICAgXCJPS1wiIGlmIGxvY2sgZXh0ZW50ZWQgc3VjY2VzZnVsbHkuXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5pZiByY2FsbChcIkdFVFwiLCBLRVlTWzFdKSA9PSBBUkdWWzFdIHRoZW5cbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIEtFWVNbMV0pXG5lbHNlXG4gIHJldHVybiAwXG5lbmRcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3JlbGVhc2VMb2NrJyxcbiAgY29udGVudCxcbiAga2V5czogMSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/releaseLock-1.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/removeJob-11.js":
/*!***********************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/removeJob-11.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n    Remove a job from all the queues it may be in as well as all its data.\n    In order to be able to remove a job, it must be unlocked.\n     Input:\n      KEYS[1]  'active',\n      KEYS[2]  'wait',\n      KEYS[3]  'delayed',\n      KEYS[4]  'paused',\n      KEYS[5]  'completed',\n      KEYS[6]  'failed',\n      KEYS[7]  'priority',\n      KEYS[8]  jobId key\n      KEYS[9]  job logs\n      KEYS[10] rate limiter index table\n      KEYS[11] prefix key\n      ARGV[1]  jobId\n      ARGV[2]  lock token\n     Events:\n      'removed'\n]]\n-- TODO PUBLISH global event 'removed'\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to remove debounce key.\n]]\nlocal function removeDebounceKey(prefixKey, jobKey)\n  local debounceId = rcall(\"HGET\", jobKey, \"deid\")\n  if debounceId then\n    local debounceKey = prefixKey .. \"de:\" .. debounceId\n    rcall(\"DEL\", debounceKey)\n  end\nend\nlocal lockKey = KEYS[8] .. ':lock'\nlocal lock = rcall(\"GET\", lockKey)\nif not lock then             -- or (lock == ARGV[2])) then\n  local jobId = ARGV[1]\n  rcall(\"LREM\", KEYS[1], 0, jobId)\n  rcall(\"LREM\", KEYS[2], 0, jobId)\n  rcall(\"ZREM\", KEYS[3], jobId)\n  rcall(\"LREM\", KEYS[4], 0, jobId)\n  rcall(\"ZREM\", KEYS[5], jobId)\n  rcall(\"ZREM\", KEYS[6], jobId)\n  rcall(\"ZREM\", KEYS[7], jobId)\n  removeDebounceKey(KEYS[11], KEYS[8])\n  rcall(\"DEL\", KEYS[8])\n  rcall(\"DEL\", KEYS[9])\n  -- delete keys related to rate limiter\n  local limiterIndexTable = KEYS[10] .. \":index\"\n  local limitedSetKey = rcall(\"HGET\", limiterIndexTable, jobId)\n  if limitedSetKey then\n    rcall(\"SREM\", limitedSetKey, jobId)\n    rcall(\"HDEL\", limiterIndexTable, jobId)\n  end\n  return 1\nelse\n  return 0\nend\n`;\nmodule.exports = {\n  name: 'removeJob',\n  content,\n  keys: 11,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZW1vdmVKb2ItMTEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZW1vdmVKb2ItMTEuanM/ODM1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgICBSZW1vdmUgYSBqb2IgZnJvbSBhbGwgdGhlIHF1ZXVlcyBpdCBtYXkgYmUgaW4gYXMgd2VsbCBhcyBhbGwgaXRzIGRhdGEuXG4gICAgSW4gb3JkZXIgdG8gYmUgYWJsZSB0byByZW1vdmUgYSBqb2IsIGl0IG11c3QgYmUgdW5sb2NrZWQuXG4gICAgIElucHV0OlxuICAgICAgS0VZU1sxXSAgJ2FjdGl2ZScsXG4gICAgICBLRVlTWzJdICAnd2FpdCcsXG4gICAgICBLRVlTWzNdICAnZGVsYXllZCcsXG4gICAgICBLRVlTWzRdICAncGF1c2VkJyxcbiAgICAgIEtFWVNbNV0gICdjb21wbGV0ZWQnLFxuICAgICAgS0VZU1s2XSAgJ2ZhaWxlZCcsXG4gICAgICBLRVlTWzddICAncHJpb3JpdHknLFxuICAgICAgS0VZU1s4XSAgam9iSWQga2V5XG4gICAgICBLRVlTWzldICBqb2IgbG9nc1xuICAgICAgS0VZU1sxMF0gcmF0ZSBsaW1pdGVyIGluZGV4IHRhYmxlXG4gICAgICBLRVlTWzExXSBwcmVmaXgga2V5XG4gICAgICBBUkdWWzFdICBqb2JJZFxuICAgICAgQVJHVlsyXSAgbG9jayB0b2tlblxuICAgICBFdmVudHM6XG4gICAgICAncmVtb3ZlZCdcbl1dXG4tLSBUT0RPIFBVQkxJU0ggZ2xvYmFsIGV2ZW50ICdyZW1vdmVkJ1xubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZGVib3VuY2Uga2V5LlxuXV1cbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZURlYm91bmNlS2V5KHByZWZpeEtleSwgam9iS2V5KVxuICBsb2NhbCBkZWJvdW5jZUlkID0gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJkZWlkXCIpXG4gIGlmIGRlYm91bmNlSWQgdGhlblxuICAgIGxvY2FsIGRlYm91bmNlS2V5ID0gcHJlZml4S2V5IC4uIFwiZGU6XCIgLi4gZGVib3VuY2VJZFxuICAgIHJjYWxsKFwiREVMXCIsIGRlYm91bmNlS2V5KVxuICBlbmRcbmVuZFxubG9jYWwgbG9ja0tleSA9IEtFWVNbOF0gLi4gJzpsb2NrJ1xubG9jYWwgbG9jayA9IHJjYWxsKFwiR0VUXCIsIGxvY2tLZXkpXG5pZiBub3QgbG9jayB0aGVuICAgICAgICAgICAgIC0tIG9yIChsb2NrID09IEFSR1ZbMl0pKSB0aGVuXG4gIGxvY2FsIGpvYklkID0gQVJHVlsxXVxuICByY2FsbChcIkxSRU1cIiwgS0VZU1sxXSwgMCwgam9iSWQpXG4gIHJjYWxsKFwiTFJFTVwiLCBLRVlTWzJdLCAwLCBqb2JJZClcbiAgcmNhbGwoXCJaUkVNXCIsIEtFWVNbM10sIGpvYklkKVxuICByY2FsbChcIkxSRU1cIiwgS0VZU1s0XSwgMCwgam9iSWQpXG4gIHJjYWxsKFwiWlJFTVwiLCBLRVlTWzVdLCBqb2JJZClcbiAgcmNhbGwoXCJaUkVNXCIsIEtFWVNbNl0sIGpvYklkKVxuICByY2FsbChcIlpSRU1cIiwgS0VZU1s3XSwgam9iSWQpXG4gIHJlbW92ZURlYm91bmNlS2V5KEtFWVNbMTFdLCBLRVlTWzhdKVxuICByY2FsbChcIkRFTFwiLCBLRVlTWzhdKVxuICByY2FsbChcIkRFTFwiLCBLRVlTWzldKVxuICAtLSBkZWxldGUga2V5cyByZWxhdGVkIHRvIHJhdGUgbGltaXRlclxuICBsb2NhbCBsaW1pdGVySW5kZXhUYWJsZSA9IEtFWVNbMTBdIC4uIFwiOmluZGV4XCJcbiAgbG9jYWwgbGltaXRlZFNldEtleSA9IHJjYWxsKFwiSEdFVFwiLCBsaW1pdGVySW5kZXhUYWJsZSwgam9iSWQpXG4gIGlmIGxpbWl0ZWRTZXRLZXkgdGhlblxuICAgIHJjYWxsKFwiU1JFTVwiLCBsaW1pdGVkU2V0S2V5LCBqb2JJZClcbiAgICByY2FsbChcIkhERUxcIiwgbGltaXRlckluZGV4VGFibGUsIGpvYklkKVxuICBlbmRcbiAgcmV0dXJuIDFcbmVsc2VcbiAgcmV0dXJuIDBcbmVuZFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAncmVtb3ZlSm9iJyxcbiAgY29udGVudCxcbiAga2V5czogMTEsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/removeJob-11.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/removeJobs-8.js":
/*!***********************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/removeJobs-8.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n    Remove all jobs matching a given pattern from all the queues they may be in as well as all its data.\n    In order to be able to remove any job, they must be unlocked.\n     Input:\n      KEYS[1] 'active',\n      KEYS[2] 'wait',\n      KEYS[3] 'delayed',\n      KEYS[4] 'paused',\n      KEYS[5] 'completed',\n      KEYS[6] 'failed',\n      KEYS[7] 'priority',\n      KEYS[8] 'rate-limiter'\n      ARGV[1]  prefix\n      ARGV[2]  pattern\n      ARGV[3]  cursor\n     Events:\n      'removed'\n]]\n-- TODO PUBLISH global events 'removed'\nlocal rcall = redis.call\nlocal result = rcall(\"SCAN\", ARGV[3], \"MATCH\", ARGV[1] .. ARGV[2])\nlocal cursor = result[1];\nlocal jobKeys = result[2];\nlocal removed = {}\nlocal prefixLen = string.len(ARGV[1]) + 1\nfor i, jobKey in ipairs(jobKeys) do\n    local keyTypeResp = rcall(\"TYPE\", jobKey)\n    if keyTypeResp[\"ok\"] == \"hash\" then\n        local jobId = string.sub(jobKey, prefixLen)\n        local lockKey = jobKey .. ':lock'\n        local lock = redis.call(\"GET\", lockKey)\n        if not lock then\n            rcall(\"LREM\", KEYS[1], 0, jobId)\n            rcall(\"LREM\", KEYS[2], 0, jobId)\n            rcall(\"ZREM\", KEYS[3], jobId)\n            rcall(\"LREM\", KEYS[4], 0, jobId)\n            rcall(\"ZREM\", KEYS[5], jobId)\n            rcall(\"ZREM\", KEYS[6], jobId)\n            rcall(\"ZREM\", KEYS[7], jobId)\n            rcall(\"DEL\", jobKey)\n            rcall(\"DEL\", jobKey .. ':logs')\n            -- delete keys related to rate limiter\n            local limiterIndexTable = KEYS[8] .. \":index\"\n            local limitedSetKey = rcall(\"HGET\", limiterIndexTable, jobId)\n            if limitedSetKey then\n                rcall(\"SREM\", limitedSetKey, jobId)\n                rcall(\"HDEL\", limiterIndexTable, jobId)\n            end\n            table.insert(removed, jobId)\n        end\n    end\nend\nreturn {cursor, removed}\n`;\nmodule.exports = {\n  name: 'removeJobs',\n  content,\n  keys: 8,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZW1vdmVKb2JzLTguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvcmVtb3ZlSm9icy04LmpzPzRkOGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgY29udGVudCA9IGAtLVtbXG4gICAgUmVtb3ZlIGFsbCBqb2JzIG1hdGNoaW5nIGEgZ2l2ZW4gcGF0dGVybiBmcm9tIGFsbCB0aGUgcXVldWVzIHRoZXkgbWF5IGJlIGluIGFzIHdlbGwgYXMgYWxsIGl0cyBkYXRhLlxuICAgIEluIG9yZGVyIHRvIGJlIGFibGUgdG8gcmVtb3ZlIGFueSBqb2IsIHRoZXkgbXVzdCBiZSB1bmxvY2tlZC5cbiAgICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICdhY3RpdmUnLFxuICAgICAgS0VZU1syXSAnd2FpdCcsXG4gICAgICBLRVlTWzNdICdkZWxheWVkJyxcbiAgICAgIEtFWVNbNF0gJ3BhdXNlZCcsXG4gICAgICBLRVlTWzVdICdjb21wbGV0ZWQnLFxuICAgICAgS0VZU1s2XSAnZmFpbGVkJyxcbiAgICAgIEtFWVNbN10gJ3ByaW9yaXR5JyxcbiAgICAgIEtFWVNbOF0gJ3JhdGUtbGltaXRlcidcbiAgICAgIEFSR1ZbMV0gIHByZWZpeFxuICAgICAgQVJHVlsyXSAgcGF0dGVyblxuICAgICAgQVJHVlszXSAgY3Vyc29yXG4gICAgIEV2ZW50czpcbiAgICAgICdyZW1vdmVkJ1xuXV1cbi0tIFRPRE8gUFVCTElTSCBnbG9iYWwgZXZlbnRzICdyZW1vdmVkJ1xubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5sb2NhbCByZXN1bHQgPSByY2FsbChcIlNDQU5cIiwgQVJHVlszXSwgXCJNQVRDSFwiLCBBUkdWWzFdIC4uIEFSR1ZbMl0pXG5sb2NhbCBjdXJzb3IgPSByZXN1bHRbMV07XG5sb2NhbCBqb2JLZXlzID0gcmVzdWx0WzJdO1xubG9jYWwgcmVtb3ZlZCA9IHt9XG5sb2NhbCBwcmVmaXhMZW4gPSBzdHJpbmcubGVuKEFSR1ZbMV0pICsgMVxuZm9yIGksIGpvYktleSBpbiBpcGFpcnMoam9iS2V5cykgZG9cbiAgICBsb2NhbCBrZXlUeXBlUmVzcCA9IHJjYWxsKFwiVFlQRVwiLCBqb2JLZXkpXG4gICAgaWYga2V5VHlwZVJlc3BbXCJva1wiXSA9PSBcImhhc2hcIiB0aGVuXG4gICAgICAgIGxvY2FsIGpvYklkID0gc3RyaW5nLnN1Yihqb2JLZXksIHByZWZpeExlbilcbiAgICAgICAgbG9jYWwgbG9ja0tleSA9IGpvYktleSAuLiAnOmxvY2snXG4gICAgICAgIGxvY2FsIGxvY2sgPSByZWRpcy5jYWxsKFwiR0VUXCIsIGxvY2tLZXkpXG4gICAgICAgIGlmIG5vdCBsb2NrIHRoZW5cbiAgICAgICAgICAgIHJjYWxsKFwiTFJFTVwiLCBLRVlTWzFdLCAwLCBqb2JJZClcbiAgICAgICAgICAgIHJjYWxsKFwiTFJFTVwiLCBLRVlTWzJdLCAwLCBqb2JJZClcbiAgICAgICAgICAgIHJjYWxsKFwiWlJFTVwiLCBLRVlTWzNdLCBqb2JJZClcbiAgICAgICAgICAgIHJjYWxsKFwiTFJFTVwiLCBLRVlTWzRdLCAwLCBqb2JJZClcbiAgICAgICAgICAgIHJjYWxsKFwiWlJFTVwiLCBLRVlTWzVdLCBqb2JJZClcbiAgICAgICAgICAgIHJjYWxsKFwiWlJFTVwiLCBLRVlTWzZdLCBqb2JJZClcbiAgICAgICAgICAgIHJjYWxsKFwiWlJFTVwiLCBLRVlTWzddLCBqb2JJZClcbiAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIGpvYktleSlcbiAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIGpvYktleSAuLiAnOmxvZ3MnKVxuICAgICAgICAgICAgLS0gZGVsZXRlIGtleXMgcmVsYXRlZCB0byByYXRlIGxpbWl0ZXJcbiAgICAgICAgICAgIGxvY2FsIGxpbWl0ZXJJbmRleFRhYmxlID0gS0VZU1s4XSAuLiBcIjppbmRleFwiXG4gICAgICAgICAgICBsb2NhbCBsaW1pdGVkU2V0S2V5ID0gcmNhbGwoXCJIR0VUXCIsIGxpbWl0ZXJJbmRleFRhYmxlLCBqb2JJZClcbiAgICAgICAgICAgIGlmIGxpbWl0ZWRTZXRLZXkgdGhlblxuICAgICAgICAgICAgICAgIHJjYWxsKFwiU1JFTVwiLCBsaW1pdGVkU2V0S2V5LCBqb2JJZClcbiAgICAgICAgICAgICAgICByY2FsbChcIkhERUxcIiwgbGltaXRlckluZGV4VGFibGUsIGpvYklkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICB0YWJsZS5pbnNlcnQocmVtb3ZlZCwgam9iSWQpXG4gICAgICAgIGVuZFxuICAgIGVuZFxuZW5kXG5yZXR1cm4ge2N1cnNvciwgcmVtb3ZlZH1cbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3JlbW92ZUpvYnMnLFxuICBjb250ZW50LFxuICBrZXlzOiA4LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/removeJobs-8.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/removeRepeatable-2.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/removeRepeatable-2.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Removes a repeatable job\n  Input:\n    KEYS[1] repeat jobs key\n    KEYS[2] delayed jobs key\n    ARGV[1] repeat job id\n    ARGV[2] repeat job key\n    ARGV[3] queue key\n]]\nlocal millis = redis.call(\"ZSCORE\", KEYS[1], ARGV[2])\nif(millis) then\n  -- Delete next programmed job.\n  local repeatJobId = ARGV[1] .. millis\n  if(redis.call(\"ZREM\", KEYS[2], repeatJobId) == 1) then\n    redis.call(\"DEL\", ARGV[3] .. repeatJobId)\n  end\nend\nredis.call(\"ZREM\", KEYS[1], ARGV[2]);\n`;\nmodule.exports = {\n  name: 'removeRepeatable',\n  content,\n  keys: 2,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZW1vdmVSZXBlYXRhYmxlLTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvcmVtb3ZlUmVwZWF0YWJsZS0yLmpzP2Q4ODQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgY29udGVudCA9IGAtLVtbXG4gIFJlbW92ZXMgYSByZXBlYXRhYmxlIGpvYlxuICBJbnB1dDpcbiAgICBLRVlTWzFdIHJlcGVhdCBqb2JzIGtleVxuICAgIEtFWVNbMl0gZGVsYXllZCBqb2JzIGtleVxuICAgIEFSR1ZbMV0gcmVwZWF0IGpvYiBpZFxuICAgIEFSR1ZbMl0gcmVwZWF0IGpvYiBrZXlcbiAgICBBUkdWWzNdIHF1ZXVlIGtleVxuXV1cbmxvY2FsIG1pbGxpcyA9IHJlZGlzLmNhbGwoXCJaU0NPUkVcIiwgS0VZU1sxXSwgQVJHVlsyXSlcbmlmKG1pbGxpcykgdGhlblxuICAtLSBEZWxldGUgbmV4dCBwcm9ncmFtbWVkIGpvYi5cbiAgbG9jYWwgcmVwZWF0Sm9iSWQgPSBBUkdWWzFdIC4uIG1pbGxpc1xuICBpZihyZWRpcy5jYWxsKFwiWlJFTVwiLCBLRVlTWzJdLCByZXBlYXRKb2JJZCkgPT0gMSkgdGhlblxuICAgIHJlZGlzLmNhbGwoXCJERUxcIiwgQVJHVlszXSAuLiByZXBlYXRKb2JJZClcbiAgZW5kXG5lbmRcbnJlZGlzLmNhbGwoXCJaUkVNXCIsIEtFWVNbMV0sIEFSR1ZbMl0pO1xuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAncmVtb3ZlUmVwZWF0YWJsZScsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDIsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/removeRepeatable-2.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/reprocessJob-6.js":
/*!*************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/reprocessJob-6.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Attempts to reprocess a job\n  Input:\n    KEYS[1] job key\n    KEYS[2] job lock key\n    KEYS[3] job state\n    KEYS[4] wait key\n    KEYS[5] meta-pause\n    KEYS[6] paused key\n    ARGV[1] job.id,\n    ARGV[2] (job.opts.lifo ? 'R' : 'L') + 'PUSH'\n    ARGV[3] token\n    ARGV[4] timestamp\n  Output:\n    1 means the operation was a success\n    0 means the job does not exist\n    -1 means the job is currently locked and can't be retried.\n    -2 means the job was not found in the expected set.\n]]\nlocal rcall = redis.call;\nif (rcall(\"EXISTS\", KEYS[1]) == 1) then\n    if (rcall(\"EXISTS\", KEYS[2]) == 0) then\n        rcall(\"HDEL\", KEYS[1], \"finishedOn\", \"processedOn\", \"failedReason\")\n        rcall(\"HSET\", KEYS[1], \"retriedOn\", ARGV[4])\n        if (rcall(\"ZREM\", KEYS[3], ARGV[1]) == 1) then\n            local target\n            if rcall(\"EXISTS\", KEYS[5]) ~= 1 then\n                target = KEYS[4]\n            else\n                target = KEYS[6]\n            end\n            rcall(ARGV[2], target, ARGV[1])\n            -- Emit waiting event (wait..ing@token)\n            rcall(\"PUBLISH\", KEYS[4] .. \"ing@\" .. ARGV[3], ARGV[1])\n            return 1\n        else\n            return -2\n        end\n    else\n        return -1\n    end\nelse\n    return 0\nend\n`;\nmodule.exports = {\n  name: 'reprocessJob',\n  content,\n  keys: 6,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZXByb2Nlc3NKb2ItNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvcmVwcm9jZXNzSm9iLTYuanM/Yjk4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgQXR0ZW1wdHMgdG8gcmVwcm9jZXNzIGEgam9iXG4gIElucHV0OlxuICAgIEtFWVNbMV0gam9iIGtleVxuICAgIEtFWVNbMl0gam9iIGxvY2sga2V5XG4gICAgS0VZU1szXSBqb2Igc3RhdGVcbiAgICBLRVlTWzRdIHdhaXQga2V5XG4gICAgS0VZU1s1XSBtZXRhLXBhdXNlXG4gICAgS0VZU1s2XSBwYXVzZWQga2V5XG4gICAgQVJHVlsxXSBqb2IuaWQsXG4gICAgQVJHVlsyXSAoam9iLm9wdHMubGlmbyA/ICdSJyA6ICdMJykgKyAnUFVTSCdcbiAgICBBUkdWWzNdIHRva2VuXG4gICAgQVJHVls0XSB0aW1lc3RhbXBcbiAgT3V0cHV0OlxuICAgIDEgbWVhbnMgdGhlIG9wZXJhdGlvbiB3YXMgYSBzdWNjZXNzXG4gICAgMCBtZWFucyB0aGUgam9iIGRvZXMgbm90IGV4aXN0XG4gICAgLTEgbWVhbnMgdGhlIGpvYiBpcyBjdXJyZW50bHkgbG9ja2VkIGFuZCBjYW4ndCBiZSByZXRyaWVkLlxuICAgIC0yIG1lYW5zIHRoZSBqb2Igd2FzIG5vdCBmb3VuZCBpbiB0aGUgZXhwZWN0ZWQgc2V0LlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbDtcbmlmIChyY2FsbChcIkVYSVNUU1wiLCBLRVlTWzFdKSA9PSAxKSB0aGVuXG4gICAgaWYgKHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbMl0pID09IDApIHRoZW5cbiAgICAgICAgcmNhbGwoXCJIREVMXCIsIEtFWVNbMV0sIFwiZmluaXNoZWRPblwiLCBcInByb2Nlc3NlZE9uXCIsIFwiZmFpbGVkUmVhc29uXCIpXG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBLRVlTWzFdLCBcInJldHJpZWRPblwiLCBBUkdWWzRdKVxuICAgICAgICBpZiAocmNhbGwoXCJaUkVNXCIsIEtFWVNbM10sIEFSR1ZbMV0pID09IDEpIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIHRhcmdldFxuICAgICAgICAgICAgaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1s1XSkgfj0gMSB0aGVuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gS0VZU1s0XVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhcmdldCA9IEtFWVNbNl1cbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgcmNhbGwoQVJHVlsyXSwgdGFyZ2V0LCBBUkdWWzFdKVxuICAgICAgICAgICAgLS0gRW1pdCB3YWl0aW5nIGV2ZW50ICh3YWl0Li5pbmdAdG9rZW4pXG4gICAgICAgICAgICByY2FsbChcIlBVQkxJU0hcIiwgS0VZU1s0XSAuLiBcImluZ0BcIiAuLiBBUkdWWzNdLCBBUkdWWzFdKVxuICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIC0yXG4gICAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgZW5kXG5lbHNlXG4gICAgcmV0dXJuIDBcbmVuZFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAncmVwcm9jZXNzSm9iJyxcbiAgY29udGVudCxcbiAga2V5czogNixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/reprocessJob-6.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/retryJob-7.js":
/*!*********************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/retryJob-7.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Retries a failed job by moving it back to the wait queue.\n    Input:\n      KEYS[1] 'active',\n      KEYS[2] 'wait'\n      KEYS[3] jobId key\n      KEYS[4] 'meta-paused'\n      KEYS[5] 'paused'\n      KEYS[6] stalled key\n      KEYS[7] 'priority'\n      ARGV[1]  pushCmd\n      ARGV[2]  jobId\n      ARGV[3]  token\n    Events:\n      'prefix:added'\n    Output:\n     0  - OK\n     -1 - Missing key\n     -2 - Job Not locked\n     -3 - Job not in active set\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\nlocal function addJobWithPriority(priorityKey, priority, jobId, targetKey)\n  rcall(\"ZADD\", priorityKey, priority, jobId)\n  local count = rcall(\"ZCOUNT\", priorityKey, 0, priority)\n  local len = rcall(\"LLEN\", targetKey)\n  local id = rcall(\"LINDEX\", targetKey, len - (count - 1))\n  if id then\n    rcall(\"LINSERT\", targetKey, \"BEFORE\", id, jobId)\n  else\n    rcall(\"RPUSH\", targetKey, jobId)\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    local lockToken = rcall(\"GET\", lockKey)\n    if lockToken == token then\n      rcall(\"DEL\", lockKey)\n      rcall(\"SREM\", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\nif rcall(\"EXISTS\", KEYS[3]) == 1 then\n  local errorCode = removeLock(KEYS[3], KEYS[6], ARGV[3], ARGV[2])\n  if errorCode < 0 then\n    return errorCode\n  end\n  local numRemovedElements = rcall(\"LREM\", KEYS[1], -1, ARGV[2])\n  if numRemovedElements < 1 then return -3 end\n  local target = getTargetQueueList(KEYS[4], KEYS[2], KEYS[5])\n  local priority = tonumber(rcall(\"HGET\", KEYS[3], \"priority\")) or 0\n  if priority == 0 then\n    -- LIFO or FIFO\n    rcall(ARGV[1], target, ARGV[2])\n  else\n    addJobWithPriority(KEYS[7], priority, ARGV[2], target)\n  end\n  return 0\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'retryJob',\n  content,\n  keys: 7,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZXRyeUpvYi03LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZXRyeUpvYi03LmpzPzNkNjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgY29udGVudCA9IGAtLVtbXG4gIFJldHJpZXMgYSBmYWlsZWQgam9iIGJ5IG1vdmluZyBpdCBiYWNrIHRvIHRoZSB3YWl0IHF1ZXVlLlxuICAgIElucHV0OlxuICAgICAgS0VZU1sxXSAnYWN0aXZlJyxcbiAgICAgIEtFWVNbMl0gJ3dhaXQnXG4gICAgICBLRVlTWzNdIGpvYklkIGtleVxuICAgICAgS0VZU1s0XSAnbWV0YS1wYXVzZWQnXG4gICAgICBLRVlTWzVdICdwYXVzZWQnXG4gICAgICBLRVlTWzZdIHN0YWxsZWQga2V5XG4gICAgICBLRVlTWzddICdwcmlvcml0eSdcbiAgICAgIEFSR1ZbMV0gIHB1c2hDbWRcbiAgICAgIEFSR1ZbMl0gIGpvYklkXG4gICAgICBBUkdWWzNdICB0b2tlblxuICAgIEV2ZW50czpcbiAgICAgICdwcmVmaXg6YWRkZWQnXG4gICAgT3V0cHV0OlxuICAgICAwICAtIE9LXG4gICAgIC0xIC0gTWlzc2luZyBrZXlcbiAgICAgLTIgLSBKb2IgTm90IGxvY2tlZFxuICAgICAtMyAtIEpvYiBub3QgaW4gYWN0aXZlIHNldFxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBjb25zaWRlcmluZyBwcmlvcml0eS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JXaXRoUHJpb3JpdHkocHJpb3JpdHlLZXksIHByaW9yaXR5LCBqb2JJZCwgdGFyZ2V0S2V5KVxuICByY2FsbChcIlpBRERcIiwgcHJpb3JpdHlLZXksIHByaW9yaXR5LCBqb2JJZClcbiAgbG9jYWwgY291bnQgPSByY2FsbChcIlpDT1VOVFwiLCBwcmlvcml0eUtleSwgMCwgcHJpb3JpdHkpXG4gIGxvY2FsIGxlbiA9IHJjYWxsKFwiTExFTlwiLCB0YXJnZXRLZXkpXG4gIGxvY2FsIGlkID0gcmNhbGwoXCJMSU5ERVhcIiwgdGFyZ2V0S2V5LCBsZW4gLSAoY291bnQgLSAxKSlcbiAgaWYgaWQgdGhlblxuICAgIHJjYWxsKFwiTElOU0VSVFwiLCB0YXJnZXRLZXksIFwiQkVGT1JFXCIsIGlkLCBqb2JJZClcbiAgZWxzZVxuICAgIHJjYWxsKFwiUlBVU0hcIiwgdGFyZ2V0S2V5LCBqb2JJZClcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGlmIHJjYWxsKFwiRVhJU1RTXCIsIHF1ZXVlTWV0YUtleSkgfj0gMSB0aGVuXG4gICAgcmV0dXJuIHdhaXRLZXksIGZhbHNlXG4gIGVsc2VcbiAgICByZXR1cm4gcGF1c2VkS2V5LCB0cnVlXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVMb2NrKGpvYktleSwgc3RhbGxlZEtleSwgdG9rZW4sIGpvYklkKVxuICBpZiB0b2tlbiB+PSBcIjBcIiB0aGVuXG4gICAgbG9jYWwgbG9ja0tleSA9IGpvYktleSAuLiAnOmxvY2snXG4gICAgbG9jYWwgbG9ja1Rva2VuID0gcmNhbGwoXCJHRVRcIiwgbG9ja0tleSlcbiAgICBpZiBsb2NrVG9rZW4gPT0gdG9rZW4gdGhlblxuICAgICAgcmNhbGwoXCJERUxcIiwgbG9ja0tleSlcbiAgICAgIHJjYWxsKFwiU1JFTVwiLCBzdGFsbGVkS2V5LCBqb2JJZClcbiAgICBlbHNlXG4gICAgICBpZiBsb2NrVG9rZW4gdGhlblxuICAgICAgICAtLSBMb2NrIGV4aXN0cyBidXQgdG9rZW4gZG9lcyBub3QgbWF0Y2hcbiAgICAgICAgcmV0dXJuIC02XG4gICAgICBlbHNlXG4gICAgICAgIC0tIExvY2sgaXMgbWlzc2luZyBjb21wbGV0ZWx5XG4gICAgICAgIHJldHVybiAtMlxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gMFxuZW5kXG5pZiByY2FsbChcIkVYSVNUU1wiLCBLRVlTWzNdKSA9PSAxIHRoZW5cbiAgbG9jYWwgZXJyb3JDb2RlID0gcmVtb3ZlTG9jayhLRVlTWzNdLCBLRVlTWzZdLCBBUkdWWzNdLCBBUkdWWzJdKVxuICBpZiBlcnJvckNvZGUgPCAwIHRoZW5cbiAgICByZXR1cm4gZXJyb3JDb2RlXG4gIGVuZFxuICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIkxSRU1cIiwgS0VZU1sxXSwgLTEsIEFSR1ZbMl0pXG4gIGlmIG51bVJlbW92ZWRFbGVtZW50cyA8IDEgdGhlbiByZXR1cm4gLTMgZW5kXG4gIGxvY2FsIHRhcmdldCA9IGdldFRhcmdldFF1ZXVlTGlzdChLRVlTWzRdLCBLRVlTWzJdLCBLRVlTWzVdKVxuICBsb2NhbCBwcmlvcml0eSA9IHRvbnVtYmVyKHJjYWxsKFwiSEdFVFwiLCBLRVlTWzNdLCBcInByaW9yaXR5XCIpKSBvciAwXG4gIGlmIHByaW9yaXR5ID09IDAgdGhlblxuICAgIC0tIExJRk8gb3IgRklGT1xuICAgIHJjYWxsKEFSR1ZbMV0sIHRhcmdldCwgQVJHVlsyXSlcbiAgZWxzZVxuICAgIGFkZEpvYldpdGhQcmlvcml0eShLRVlTWzddLCBwcmlvcml0eSwgQVJHVlsyXSwgdGFyZ2V0KVxuICBlbmRcbiAgcmV0dXJuIDBcbmVsc2VcbiAgcmV0dXJuIC0xXG5lbmRcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3JldHJ5Sm9iJyxcbiAgY29udGVudCxcbiAga2V5czogNyxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/retryJob-7.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/retryJobs-5.js":
/*!**********************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/retryJobs-5.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Attempts to retry all failed jobs\n  Input:\n    KEYS[1] base key\n    KEYS[2] failed state key\n    KEYS[3] wait state key\n    KEYS[4] 'meta-paused'\n    KEYS[5] 'paused'\n    ARGV[1]  count\n  Output:\n    1  means the operation is not completed\n    0  means the operation is completed\n]]\nlocal baseKey = KEYS[1]\nlocal maxCount = tonumber(ARGV[1])\nlocal rcall = redis.call;\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\nlocal function getZSetItems(keyName, max)\n    return rcall('ZRANGE', keyName, 0, max - 1)\nend\nlocal jobs = getZSetItems(KEYS[2], maxCount)\nif (#jobs > 0) then\n    for i, key in ipairs(jobs) do\n        local jobKey = baseKey .. key\n        rcall(\"HDEL\", jobKey, \"finishedOn\", \"processedOn\", \"failedReason\")\n    end\n    local target\n    if rcall(\"EXISTS\", KEYS[4]) ~= 1 then\n        target = KEYS[3]\n    else\n        target = KEYS[5]\n    end\n    for from, to in batches(#jobs, 7000) do\n        rcall(\"ZREM\", KEYS[2], unpack(jobs, from, to))\n        rcall(\"LPUSH\", target, unpack(jobs, from, to))\n    end\nend\nmaxCount = maxCount - #jobs\nif (maxCount <= 0) then return 1 end\nreturn 0\n`;\nmodule.exports = {\n  name: 'retryJobs',\n  content,\n  keys: 5,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZXRyeUpvYnMtNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvcmV0cnlKb2JzLTUuanM/NmQyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgQXR0ZW1wdHMgdG8gcmV0cnkgYWxsIGZhaWxlZCBqb2JzXG4gIElucHV0OlxuICAgIEtFWVNbMV0gYmFzZSBrZXlcbiAgICBLRVlTWzJdIGZhaWxlZCBzdGF0ZSBrZXlcbiAgICBLRVlTWzNdIHdhaXQgc3RhdGUga2V5XG4gICAgS0VZU1s0XSAnbWV0YS1wYXVzZWQnXG4gICAgS0VZU1s1XSAncGF1c2VkJ1xuICAgIEFSR1ZbMV0gIGNvdW50XG4gIE91dHB1dDpcbiAgICAxICBtZWFucyB0aGUgb3BlcmF0aW9uIGlzIG5vdCBjb21wbGV0ZWRcbiAgICAwICBtZWFucyB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlZFxuXV1cbmxvY2FsIGJhc2VLZXkgPSBLRVlTWzFdXG5sb2NhbCBtYXhDb3VudCA9IHRvbnVtYmVyKEFSR1ZbMV0pXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGw7XG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBsb29wIGluIGJhdGNoZXMuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgc29tZSBjb21tYW5kcyBhcyBaUkVNXG4gIGNvdWxkIHJlY2VpdmUgYSBtYXhpbXVtIG9mIDcwMDAgcGFyYW1ldGVycyBwZXIgY2FsbC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBiYXRjaGVzKG4sIGJhdGNoU2l6ZSlcbiAgbG9jYWwgaSA9IDBcbiAgcmV0dXJuIGZ1bmN0aW9uKClcbiAgICBsb2NhbCBmcm9tID0gaSAqIGJhdGNoU2l6ZSArIDFcbiAgICBpID0gaSArIDFcbiAgICBpZiAoZnJvbSA8PSBuKSB0aGVuXG4gICAgICBsb2NhbCB0byA9IG1hdGgubWluKGZyb20gKyBiYXRjaFNpemUgLSAxLCBuKVxuICAgICAgcmV0dXJuIGZyb20sIHRvXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBnZXRaU2V0SXRlbXMoa2V5TmFtZSwgbWF4KVxuICAgIHJldHVybiByY2FsbCgnWlJBTkdFJywga2V5TmFtZSwgMCwgbWF4IC0gMSlcbmVuZFxubG9jYWwgam9icyA9IGdldFpTZXRJdGVtcyhLRVlTWzJdLCBtYXhDb3VudClcbmlmICgjam9icyA+IDApIHRoZW5cbiAgICBmb3IgaSwga2V5IGluIGlwYWlycyhqb2JzKSBkb1xuICAgICAgICBsb2NhbCBqb2JLZXkgPSBiYXNlS2V5IC4uIGtleVxuICAgICAgICByY2FsbChcIkhERUxcIiwgam9iS2V5LCBcImZpbmlzaGVkT25cIiwgXCJwcm9jZXNzZWRPblwiLCBcImZhaWxlZFJlYXNvblwiKVxuICAgIGVuZFxuICAgIGxvY2FsIHRhcmdldFxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbNF0pIH49IDEgdGhlblxuICAgICAgICB0YXJnZXQgPSBLRVlTWzNdXG4gICAgZWxzZVxuICAgICAgICB0YXJnZXQgPSBLRVlTWzVdXG4gICAgZW5kXG4gICAgZm9yIGZyb20sIHRvIGluIGJhdGNoZXMoI2pvYnMsIDcwMDApIGRvXG4gICAgICAgIHJjYWxsKFwiWlJFTVwiLCBLRVlTWzJdLCB1bnBhY2soam9icywgZnJvbSwgdG8pKVxuICAgICAgICByY2FsbChcIkxQVVNIXCIsIHRhcmdldCwgdW5wYWNrKGpvYnMsIGZyb20sIHRvKSlcbiAgICBlbmRcbmVuZFxubWF4Q291bnQgPSBtYXhDb3VudCAtICNqb2JzXG5pZiAobWF4Q291bnQgPD0gMCkgdGhlbiByZXR1cm4gMSBlbmRcbnJldHVybiAwXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdyZXRyeUpvYnMnLFxuICBjb250ZW50LFxuICBrZXlzOiA1LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/retryJobs-5.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/saveStacktrace-1.js":
/*!***************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/saveStacktrace-1.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Save stacktrace and failedReason.\n  Input:\n    KEYS[1] job key\n    ARGV[1]  stacktrace\n    ARGV[2]  failedReason\n    ARGV[3]  attemptsMade\n  Output:\n     0 - OK\n    -1 - Missing key\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[1]) == 1 then\n  rcall(\"HMSET\", KEYS[1], \"stacktrace\", ARGV[1], \"failedReason\", ARGV[2],\n    \"attemptsMade\", ARGV[3])\n  return 0\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'saveStacktrace',\n  content,\n  keys: 1,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9zYXZlU3RhY2t0cmFjZS0xLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvc2F2ZVN0YWNrdHJhY2UtMS5qcz8zYTk1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBTYXZlIHN0YWNrdHJhY2UgYW5kIGZhaWxlZFJlYXNvbi5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBqb2Iga2V5XG4gICAgQVJHVlsxXSAgc3RhY2t0cmFjZVxuICAgIEFSR1ZbMl0gIGZhaWxlZFJlYXNvblxuICAgIEFSR1ZbM10gIGF0dGVtcHRzTWFkZVxuICBPdXRwdXQ6XG4gICAgIDAgLSBPS1xuICAgIC0xIC0gTWlzc2luZyBrZXlcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbMV0pID09IDEgdGhlblxuICByY2FsbChcIkhNU0VUXCIsIEtFWVNbMV0sIFwic3RhY2t0cmFjZVwiLCBBUkdWWzFdLCBcImZhaWxlZFJlYXNvblwiLCBBUkdWWzJdLFxuICAgIFwiYXR0ZW1wdHNNYWRlXCIsIEFSR1ZbM10pXG4gIHJldHVybiAwXG5lbHNlXG4gIHJldHVybiAtMVxuZW5kXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdzYXZlU3RhY2t0cmFjZScsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDEsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/saveStacktrace-1.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/takeLock-1.js":
/*!*********************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/takeLock-1.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Takes a lock\n     Input:\n        KEYS[1] 'lock',\n        ARGV[1]  token\n        ARGV[2]  lock duration in milliseconds\n      Output:\n        \"OK\" if lock taken successfully.\n]]\nif redis.call(\"SET\", KEYS[1], ARGV[1], \"NX\", \"PX\", ARGV[2]) then\n  return 1\nelse\n  return 0\nend\n`;\nmodule.exports = {\n  name: 'takeLock',\n  content,\n  keys: 1,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy90YWtlTG9jay0xLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy90YWtlTG9jay0xLmpzP2E1NDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgY29udGVudCA9IGAtLVtbXG4gIFRha2VzIGEgbG9ja1xuICAgICBJbnB1dDpcbiAgICAgICAgS0VZU1sxXSAnbG9jaycsXG4gICAgICAgIEFSR1ZbMV0gIHRva2VuXG4gICAgICAgIEFSR1ZbMl0gIGxvY2sgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgICBPdXRwdXQ6XG4gICAgICAgIFwiT0tcIiBpZiBsb2NrIHRha2VuIHN1Y2Nlc3NmdWxseS5cbl1dXG5pZiByZWRpcy5jYWxsKFwiU0VUXCIsIEtFWVNbMV0sIEFSR1ZbMV0sIFwiTlhcIiwgXCJQWFwiLCBBUkdWWzJdKSB0aGVuXG4gIHJldHVybiAxXG5lbHNlXG4gIHJldHVybiAwXG5lbmRcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3Rha2VMb2NrJyxcbiAgY29udGVudCxcbiAga2V5czogMSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/takeLock-1.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/updateData-1.js":
/*!***********************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/updateData-1.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Update job data\n  Input:\n    KEYS[1] Job id key\n    ARGV[1] data\n  Output:\n    0 - OK\n   -1 - Missing job.\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\",KEYS[1]) == 1 then -- // Make sure job exists\n  rcall(\"HSET\", KEYS[1], \"data\", ARGV[1])\n  return 0\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'updateData',\n  content,\n  keys: 1,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy91cGRhdGVEYXRhLTEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B1bmJ1aWx0L2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy91cGRhdGVEYXRhLTEuanM/ZTdmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgVXBkYXRlIGpvYiBkYXRhXG4gIElucHV0OlxuICAgIEtFWVNbMV0gSm9iIGlkIGtleVxuICAgIEFSR1ZbMV0gZGF0YVxuICBPdXRwdXQ6XG4gICAgMCAtIE9LXG4gICAtMSAtIE1pc3Npbmcgam9iLlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuaWYgcmNhbGwoXCJFWElTVFNcIixLRVlTWzFdKSA9PSAxIHRoZW4gLS0gLy8gTWFrZSBzdXJlIGpvYiBleGlzdHNcbiAgcmNhbGwoXCJIU0VUXCIsIEtFWVNbMV0sIFwiZGF0YVwiLCBBUkdWWzFdKVxuICByZXR1cm4gMFxuZWxzZVxuICByZXR1cm4gLTFcbmVuZFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAndXBkYXRlRGF0YScsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDEsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/updateData-1.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/updateDelaySet-6.js":
/*!***************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/updateDelaySet-6.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Updates the delay set, by picking a delayed job that should\n  be processed now.\n     Input:\n      KEYS[1] 'delayed'\n      KEYS[2] 'active'\n      KEYS[3] 'wait'\n      KEYS[4] 'priority'\n      KEYS[5] 'paused'\n      KEYS[6] 'meta-paused'\n      ARGV[1]  queue.toKey('')\n      ARGV[2]  delayed timestamp\n      ARGV[3]  queue token\n     Events:\n      'removed'\n]]\nlocal rcall = redis.call;\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\nlocal function addJobWithPriority(priorityKey, priority, jobId, targetKey)\n  rcall(\"ZADD\", priorityKey, priority, jobId)\n  local count = rcall(\"ZCOUNT\", priorityKey, 0, priority)\n  local len = rcall(\"LLEN\", targetKey)\n  local id = rcall(\"LINDEX\", targetKey, len - (count - 1))\n  if id then\n    rcall(\"LINSERT\", targetKey, \"BEFORE\", id, jobId)\n  else\n    rcall(\"RPUSH\", targetKey, jobId)\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\n-- Try to get as much as 1000 jobs at once\nlocal jobs = rcall(\"ZRANGEBYSCORE\", KEYS[1], 0, tonumber(ARGV[2]) * 0x1000, \"LIMIT\", 0, 1000)\nif(#jobs > 0) then\n  rcall(\"ZREM\", KEYS[1], unpack(jobs))\n  -- check if we need to use push in paused instead of waiting\n  local target = getTargetQueueList(KEYS[6], KEYS[3], KEYS[5])\n  for _, jobId in ipairs(jobs) do\n    -- Is this really needed?\n    rcall(\"LREM\", KEYS[2], 0, jobId)\n    local priority = tonumber(rcall(\"HGET\", ARGV[1] .. jobId, \"priority\")) or 0\n    if priority == 0 then\n      -- LIFO or FIFO\n      rcall(\"LPUSH\", target, jobId)\n    else\n      addJobWithPriority(KEYS[4], priority, jobId, target)\n    end\n    -- Emit waiting event (wait..ing@token)\n    rcall(\"PUBLISH\", KEYS[3] .. \"ing@\" .. ARGV[3], jobId)\n    rcall(\"HSET\", ARGV[1] .. jobId, \"delay\", 0)\n  end\nend\nlocal nextTimestamp = rcall(\"ZRANGE\", KEYS[1], 0, 0, \"WITHSCORES\")[2]\nif(nextTimestamp ~= nil) then\n  rcall(\"PUBLISH\", KEYS[1], nextTimestamp / 0x1000)\nend\nreturn nextTimestamp\n`;\nmodule.exports = {\n  name: 'updateDelaySet',\n  content,\n  keys: 6,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy91cGRhdGVEZWxheVNldC02LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL3VwZGF0ZURlbGF5U2V0LTYuanM/Njc0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgVXBkYXRlcyB0aGUgZGVsYXkgc2V0LCBieSBwaWNraW5nIGEgZGVsYXllZCBqb2IgdGhhdCBzaG91bGRcbiAgYmUgcHJvY2Vzc2VkIG5vdy5cbiAgICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICdkZWxheWVkJ1xuICAgICAgS0VZU1syXSAnYWN0aXZlJ1xuICAgICAgS0VZU1szXSAnd2FpdCdcbiAgICAgIEtFWVNbNF0gJ3ByaW9yaXR5J1xuICAgICAgS0VZU1s1XSAncGF1c2VkJ1xuICAgICAgS0VZU1s2XSAnbWV0YS1wYXVzZWQnXG4gICAgICBBUkdWWzFdICBxdWV1ZS50b0tleSgnJylcbiAgICAgIEFSR1ZbMl0gIGRlbGF5ZWQgdGltZXN0YW1wXG4gICAgICBBUkdWWzNdICBxdWV1ZSB0b2tlblxuICAgICBFdmVudHM6XG4gICAgICAncmVtb3ZlZCdcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGw7XG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5LlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYldpdGhQcmlvcml0eShwcmlvcml0eUtleSwgcHJpb3JpdHksIGpvYklkLCB0YXJnZXRLZXkpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0eUtleSwgcHJpb3JpdHksIGpvYklkKVxuICBsb2NhbCBjb3VudCA9IHJjYWxsKFwiWkNPVU5UXCIsIHByaW9yaXR5S2V5LCAwLCBwcmlvcml0eSlcbiAgbG9jYWwgbGVuID0gcmNhbGwoXCJMTEVOXCIsIHRhcmdldEtleSlcbiAgbG9jYWwgaWQgPSByY2FsbChcIkxJTkRFWFwiLCB0YXJnZXRLZXksIGxlbiAtIChjb3VudCAtIDEpKVxuICBpZiBpZCB0aGVuXG4gICAgcmNhbGwoXCJMSU5TRVJUXCIsIHRhcmdldEtleSwgXCJCRUZPUkVcIiwgaWQsIGpvYklkKVxuICBlbHNlXG4gICAgcmNhbGwoXCJSUFVTSFwiLCB0YXJnZXRLZXksIGpvYklkKVxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgaWYgcmNhbGwoXCJFWElTVFNcIiwgcXVldWVNZXRhS2V5KSB+PSAxIHRoZW5cbiAgICByZXR1cm4gd2FpdEtleSwgZmFsc2VcbiAgZWxzZVxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWVcbiAgZW5kXG5lbmRcbi0tIFRyeSB0byBnZXQgYXMgbXVjaCBhcyAxMDAwIGpvYnMgYXQgb25jZVxubG9jYWwgam9icyA9IHJjYWxsKFwiWlJBTkdFQllTQ09SRVwiLCBLRVlTWzFdLCAwLCB0b251bWJlcihBUkdWWzJdKSAqIDB4MTAwMCwgXCJMSU1JVFwiLCAwLCAxMDAwKVxuaWYoI2pvYnMgPiAwKSB0aGVuXG4gIHJjYWxsKFwiWlJFTVwiLCBLRVlTWzFdLCB1bnBhY2soam9icykpXG4gIC0tIGNoZWNrIGlmIHdlIG5lZWQgdG8gdXNlIHB1c2ggaW4gcGF1c2VkIGluc3RlYWQgb2Ygd2FpdGluZ1xuICBsb2NhbCB0YXJnZXQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QoS0VZU1s2XSwgS0VZU1szXSwgS0VZU1s1XSlcbiAgZm9yIF8sIGpvYklkIGluIGlwYWlycyhqb2JzKSBkb1xuICAgIC0tIElzIHRoaXMgcmVhbGx5IG5lZWRlZD9cbiAgICByY2FsbChcIkxSRU1cIiwgS0VZU1syXSwgMCwgam9iSWQpXG4gICAgbG9jYWwgcHJpb3JpdHkgPSB0b251bWJlcihyY2FsbChcIkhHRVRcIiwgQVJHVlsxXSAuLiBqb2JJZCwgXCJwcmlvcml0eVwiKSkgb3IgMFxuICAgIGlmIHByaW9yaXR5ID09IDAgdGhlblxuICAgICAgLS0gTElGTyBvciBGSUZPXG4gICAgICByY2FsbChcIkxQVVNIXCIsIHRhcmdldCwgam9iSWQpXG4gICAgZWxzZVxuICAgICAgYWRkSm9iV2l0aFByaW9yaXR5KEtFWVNbNF0sIHByaW9yaXR5LCBqb2JJZCwgdGFyZ2V0KVxuICAgIGVuZFxuICAgIC0tIEVtaXQgd2FpdGluZyBldmVudCAod2FpdC4uaW5nQHRva2VuKVxuICAgIHJjYWxsKFwiUFVCTElTSFwiLCBLRVlTWzNdIC4uIFwiaW5nQFwiIC4uIEFSR1ZbM10sIGpvYklkKVxuICAgIHJjYWxsKFwiSFNFVFwiLCBBUkdWWzFdIC4uIGpvYklkLCBcImRlbGF5XCIsIDApXG4gIGVuZFxuZW5kXG5sb2NhbCBuZXh0VGltZXN0YW1wID0gcmNhbGwoXCJaUkFOR0VcIiwgS0VZU1sxXSwgMCwgMCwgXCJXSVRIU0NPUkVTXCIpWzJdXG5pZihuZXh0VGltZXN0YW1wIH49IG5pbCkgdGhlblxuICByY2FsbChcIlBVQkxJU0hcIiwgS0VZU1sxXSwgbmV4dFRpbWVzdGFtcCAvIDB4MTAwMClcbmVuZFxucmV0dXJuIG5leHRUaW1lc3RhbXBcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3VwZGF0ZURlbGF5U2V0JyxcbiAgY29udGVudCxcbiAga2V5czogNixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/updateDelaySet-6.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/scripts/updateProgress-2.js":
/*!***************************************************************!*\
  !*** ../../node_modules/bull/lib/scripts/updateProgress-2.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Update job progress\n     Input:\n        KEYS[1] Job id key\n        KEYS[2] progress event key\n        ARGV[1] progress\n        ARGV[2] event data\n      Event:\n        progress(jobId, progress)\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[1]) == 1 then -- // Make sure job exists\n  rcall(\"HSET\", KEYS[1], \"progress\", ARGV[1])\n  rcall(\"PUBLISH\", KEYS[2], ARGV[2])\n  return 0\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'updateProgress',\n  content,\n  keys: 2,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy91cGRhdGVQcm9ncmVzcy0yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL3VwZGF0ZVByb2dyZXNzLTIuanM/MmRlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgVXBkYXRlIGpvYiBwcm9ncmVzc1xuICAgICBJbnB1dDpcbiAgICAgICAgS0VZU1sxXSBKb2IgaWQga2V5XG4gICAgICAgIEtFWVNbMl0gcHJvZ3Jlc3MgZXZlbnQga2V5XG4gICAgICAgIEFSR1ZbMV0gcHJvZ3Jlc3NcbiAgICAgICAgQVJHVlsyXSBldmVudCBkYXRhXG4gICAgICBFdmVudDpcbiAgICAgICAgcHJvZ3Jlc3Moam9iSWQsIHByb2dyZXNzKVxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1sxXSkgPT0gMSB0aGVuIC0tIC8vIE1ha2Ugc3VyZSBqb2IgZXhpc3RzXG4gIHJjYWxsKFwiSFNFVFwiLCBLRVlTWzFdLCBcInByb2dyZXNzXCIsIEFSR1ZbMV0pXG4gIHJjYWxsKFwiUFVCTElTSFwiLCBLRVlTWzJdLCBBUkdWWzJdKVxuICByZXR1cm4gMFxuZWxzZVxuICByZXR1cm4gLTFcbmVuZFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAndXBkYXRlUHJvZ3Jlc3MnLFxuICBjb250ZW50LFxuICBrZXlzOiAyLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/scripts/updateProgress-2.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/timer-manager.js":
/*!****************************************************!*\
  !*** ../../node_modules/bull/lib/timer-manager.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"(action-browser)/../../node_modules/lodash/lodash.js\");\nconst uuid = __webpack_require__(/*! uuid */ \"(action-browser)/../../node_modules/uuid/dist/esm-node/index.js\");\n\n/**\n  Timer Manager\n\n  Keep track of timers to ensure that disconnect() is\n  only called (via close()) at a time when it's safe\n  to do so.\n\n  Queues currently use two timers:\n\n    - The first one is used for delayed jobs and is\n    preemptible i.e. it is possible to close a queue\n    while delayed jobs are still pending (they will\n    be processed when the queue is resumed). This timer\n    is cleared by close() and is not managed here.\n\n    - The second one is used to lock Redis while\n    processing jobs. These timers are short-lived,\n    and there can be more than one active at a\n    time.\n\n  The lock timer executes Redis commands, which\n  means we can't close queues while it's active i.e.\n  this won't work:\n\n    queue.process(function (job, jobDone) {\n      handle(job);\n      queue.disconnect().then(jobDone);\n    })\n\n  The disconnect() call closes the Redis connections; then, when\n  a queue tries to perform the scheduled Redis commands,\n  they block until a Redis connection becomes available...\n\n  The solution is to close the Redis connections when there are no\n  active timers i.e. when the queue is idle. This helper class keeps\n  track of the active timers and executes any queued listeners\n  whenever that count goes to zero.\n\n  Since disconnect() simply can't work if there are active handles,\n  its close() wrapper postpones closing the Redis connections\n  until the next idle state. This means that close() can safely\n  be called from anywhere at any time, even from within a job\n  handler:\n\n    queue.process(function (job, jobDone) {\n      handle(job);\n      queue.close();\n      jobDone();\n    })\n*/\n\nfunction TimerManager() {\n  this.idle = true;\n  this.listeners = [];\n  this.timers = {};\n}\n\n/**\n  Create a new timer (setTimeout).\n\n  Expired timers are automatically cleared\n\n  @param {String} name - Name of a timer key. Used only for debugging.\n  @param {Number} delay - delay of timeout\n  @param {Function} fn - Function to execute after delay\n  @returns {Number} id - The timer id. Used to clear the timer\n*/\nTimerManager.prototype.set = function(name, delay, fn) {\n  const id = uuid.v4();\n  const timer = setTimeout(\n    (timerInstance, timeoutId) => {\n      timerInstance.clear(timeoutId);\n      try {\n        fn();\n      } catch (err) {\n        console.error(err);\n      }\n    },\n    delay,\n    this,\n    id\n  );\n\n  // XXX only the timer is used, but the\n  // other fields are useful for\n  // troubleshooting/debugging\n  this.timers[id] = {\n    name,\n    timer\n  };\n\n  this.idle = false;\n  return id;\n};\n\n/**\n  Clear a timer (clearTimeout).\n\n  Queued listeners are executed if there are no\n  remaining timers\n*/\nTimerManager.prototype.clear = function(id) {\n  const timers = this.timers;\n  const timer = timers[id];\n  if (!timer) {\n    return;\n  }\n  clearTimeout(timer.timer);\n  delete timers[id];\n  if (!this.idle && _.size(timers) === 0) {\n    while (this.listeners.length) {\n      this.listeners.pop()();\n    }\n    this.idle = true;\n  }\n};\n\nTimerManager.prototype.clearAll = function() {\n  _.each(this.timers, (timer, id) => {\n    this.clear(id);\n  });\n};\n\n/**\n * Returns a promise that resolves when there are no active timers.\n */\nTimerManager.prototype.whenIdle = function() {\n  return new Promise(resolve => {\n    if (this.idle) {\n      resolve();\n    } else {\n      this.listeners.unshift(resolve);\n    }\n  });\n};\n\nmodule.exports = TimerManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvdGltZXItbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLG1CQUFPLENBQUMsb0VBQVE7QUFDMUIsYUFBYSxtQkFBTyxDQUFDLDZFQUFNOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHVuYnVpbHQvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9idWxsL2xpYi90aW1lci1tYW5hZ2VyLmpzPzdjMjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xuXG4vKipcbiAgVGltZXIgTWFuYWdlclxuXG4gIEtlZXAgdHJhY2sgb2YgdGltZXJzIHRvIGVuc3VyZSB0aGF0IGRpc2Nvbm5lY3QoKSBpc1xuICBvbmx5IGNhbGxlZCAodmlhIGNsb3NlKCkpIGF0IGEgdGltZSB3aGVuIGl0J3Mgc2FmZVxuICB0byBkbyBzby5cblxuICBRdWV1ZXMgY3VycmVudGx5IHVzZSB0d28gdGltZXJzOlxuXG4gICAgLSBUaGUgZmlyc3Qgb25lIGlzIHVzZWQgZm9yIGRlbGF5ZWQgam9icyBhbmQgaXNcbiAgICBwcmVlbXB0aWJsZSBpLmUuIGl0IGlzIHBvc3NpYmxlIHRvIGNsb3NlIGEgcXVldWVcbiAgICB3aGlsZSBkZWxheWVkIGpvYnMgYXJlIHN0aWxsIHBlbmRpbmcgKHRoZXkgd2lsbFxuICAgIGJlIHByb2Nlc3NlZCB3aGVuIHRoZSBxdWV1ZSBpcyByZXN1bWVkKS4gVGhpcyB0aW1lclxuICAgIGlzIGNsZWFyZWQgYnkgY2xvc2UoKSBhbmQgaXMgbm90IG1hbmFnZWQgaGVyZS5cblxuICAgIC0gVGhlIHNlY29uZCBvbmUgaXMgdXNlZCB0byBsb2NrIFJlZGlzIHdoaWxlXG4gICAgcHJvY2Vzc2luZyBqb2JzLiBUaGVzZSB0aW1lcnMgYXJlIHNob3J0LWxpdmVkLFxuICAgIGFuZCB0aGVyZSBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhY3RpdmUgYXQgYVxuICAgIHRpbWUuXG5cbiAgVGhlIGxvY2sgdGltZXIgZXhlY3V0ZXMgUmVkaXMgY29tbWFuZHMsIHdoaWNoXG4gIG1lYW5zIHdlIGNhbid0IGNsb3NlIHF1ZXVlcyB3aGlsZSBpdCdzIGFjdGl2ZSBpLmUuXG4gIHRoaXMgd29uJ3Qgd29yazpcblxuICAgIHF1ZXVlLnByb2Nlc3MoZnVuY3Rpb24gKGpvYiwgam9iRG9uZSkge1xuICAgICAgaGFuZGxlKGpvYik7XG4gICAgICBxdWV1ZS5kaXNjb25uZWN0KCkudGhlbihqb2JEb25lKTtcbiAgICB9KVxuXG4gIFRoZSBkaXNjb25uZWN0KCkgY2FsbCBjbG9zZXMgdGhlIFJlZGlzIGNvbm5lY3Rpb25zOyB0aGVuLCB3aGVuXG4gIGEgcXVldWUgdHJpZXMgdG8gcGVyZm9ybSB0aGUgc2NoZWR1bGVkIFJlZGlzIGNvbW1hbmRzLFxuICB0aGV5IGJsb2NrIHVudGlsIGEgUmVkaXMgY29ubmVjdGlvbiBiZWNvbWVzIGF2YWlsYWJsZS4uLlxuXG4gIFRoZSBzb2x1dGlvbiBpcyB0byBjbG9zZSB0aGUgUmVkaXMgY29ubmVjdGlvbnMgd2hlbiB0aGVyZSBhcmUgbm9cbiAgYWN0aXZlIHRpbWVycyBpLmUuIHdoZW4gdGhlIHF1ZXVlIGlzIGlkbGUuIFRoaXMgaGVscGVyIGNsYXNzIGtlZXBzXG4gIHRyYWNrIG9mIHRoZSBhY3RpdmUgdGltZXJzIGFuZCBleGVjdXRlcyBhbnkgcXVldWVkIGxpc3RlbmVyc1xuICB3aGVuZXZlciB0aGF0IGNvdW50IGdvZXMgdG8gemVyby5cblxuICBTaW5jZSBkaXNjb25uZWN0KCkgc2ltcGx5IGNhbid0IHdvcmsgaWYgdGhlcmUgYXJlIGFjdGl2ZSBoYW5kbGVzLFxuICBpdHMgY2xvc2UoKSB3cmFwcGVyIHBvc3Rwb25lcyBjbG9zaW5nIHRoZSBSZWRpcyBjb25uZWN0aW9uc1xuICB1bnRpbCB0aGUgbmV4dCBpZGxlIHN0YXRlLiBUaGlzIG1lYW5zIHRoYXQgY2xvc2UoKSBjYW4gc2FmZWx5XG4gIGJlIGNhbGxlZCBmcm9tIGFueXdoZXJlIGF0IGFueSB0aW1lLCBldmVuIGZyb20gd2l0aGluIGEgam9iXG4gIGhhbmRsZXI6XG5cbiAgICBxdWV1ZS5wcm9jZXNzKGZ1bmN0aW9uIChqb2IsIGpvYkRvbmUpIHtcbiAgICAgIGhhbmRsZShqb2IpO1xuICAgICAgcXVldWUuY2xvc2UoKTtcbiAgICAgIGpvYkRvbmUoKTtcbiAgICB9KVxuKi9cblxuZnVuY3Rpb24gVGltZXJNYW5hZ2VyKCkge1xuICB0aGlzLmlkbGUgPSB0cnVlO1xuICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICB0aGlzLnRpbWVycyA9IHt9O1xufVxuXG4vKipcbiAgQ3JlYXRlIGEgbmV3IHRpbWVyIChzZXRUaW1lb3V0KS5cblxuICBFeHBpcmVkIHRpbWVycyBhcmUgYXV0b21hdGljYWxseSBjbGVhcmVkXG5cbiAgQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIGEgdGltZXIga2V5LiBVc2VkIG9ubHkgZm9yIGRlYnVnZ2luZy5cbiAgQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IC0gZGVsYXkgb2YgdGltZW91dFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgZGVsYXlcbiAgQHJldHVybnMge051bWJlcn0gaWQgLSBUaGUgdGltZXIgaWQuIFVzZWQgdG8gY2xlYXIgdGhlIHRpbWVyXG4qL1xuVGltZXJNYW5hZ2VyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCBkZWxheSwgZm4pIHtcbiAgY29uc3QgaWQgPSB1dWlkLnY0KCk7XG4gIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChcbiAgICAodGltZXJJbnN0YW5jZSwgdGltZW91dElkKSA9PiB7XG4gICAgICB0aW1lckluc3RhbmNlLmNsZWFyKHRpbWVvdXRJZCk7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbGF5LFxuICAgIHRoaXMsXG4gICAgaWRcbiAgKTtcblxuICAvLyBYWFggb25seSB0aGUgdGltZXIgaXMgdXNlZCwgYnV0IHRoZVxuICAvLyBvdGhlciBmaWVsZHMgYXJlIHVzZWZ1bCBmb3JcbiAgLy8gdHJvdWJsZXNob290aW5nL2RlYnVnZ2luZ1xuICB0aGlzLnRpbWVyc1tpZF0gPSB7XG4gICAgbmFtZSxcbiAgICB0aW1lclxuICB9O1xuXG4gIHRoaXMuaWRsZSA9IGZhbHNlO1xuICByZXR1cm4gaWQ7XG59O1xuXG4vKipcbiAgQ2xlYXIgYSB0aW1lciAoY2xlYXJUaW1lb3V0KS5cblxuICBRdWV1ZWQgbGlzdGVuZXJzIGFyZSBleGVjdXRlZCBpZiB0aGVyZSBhcmUgbm9cbiAgcmVtYWluaW5nIHRpbWVyc1xuKi9cblRpbWVyTWFuYWdlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihpZCkge1xuICBjb25zdCB0aW1lcnMgPSB0aGlzLnRpbWVycztcbiAgY29uc3QgdGltZXIgPSB0aW1lcnNbaWRdO1xuICBpZiAoIXRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNsZWFyVGltZW91dCh0aW1lci50aW1lcik7XG4gIGRlbGV0ZSB0aW1lcnNbaWRdO1xuICBpZiAoIXRoaXMuaWRsZSAmJiBfLnNpemUodGltZXJzKSA9PT0gMCkge1xuICAgIHdoaWxlICh0aGlzLmxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLnBvcCgpKCk7XG4gICAgfVxuICAgIHRoaXMuaWRsZSA9IHRydWU7XG4gIH1cbn07XG5cblRpbWVyTWFuYWdlci5wcm90b3R5cGUuY2xlYXJBbGwgPSBmdW5jdGlvbigpIHtcbiAgXy5lYWNoKHRoaXMudGltZXJzLCAodGltZXIsIGlkKSA9PiB7XG4gICAgdGhpcy5jbGVhcihpZCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlcmUgYXJlIG5vIGFjdGl2ZSB0aW1lcnMuXG4gKi9cblRpbWVyTWFuYWdlci5wcm90b3R5cGUud2hlbklkbGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGlmICh0aGlzLmlkbGUpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saXN0ZW5lcnMudW5zaGlmdChyZXNvbHZlKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lck1hbmFnZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/timer-manager.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/utils.js":
/*!********************************************!*\
  !*** ../../node_modules/bull/lib/utils.js ***!
  \********************************************/
/***/ ((module) => {

eval("\nconst errorObject = { value: null };\nfunction tryCatch(fn, ctx, args) {\n  try {\n    return fn.apply(ctx, args);\n  } catch (e) {\n    errorObject.value = e;\n    return errorObject;\n  }\n}\n\n/**\n * Waits for a redis client to be ready.\n * @param {Redis} redis client\n */\nfunction isRedisReady(client) {\n  return new Promise((resolve, reject) => {\n    if (client.status === 'ready') {\n      resolve();\n    } else {\n      function handleReady() {\n        client.removeListener('end', handleEnd);\n        client.removeListener('error', handleError);\n        resolve();\n      }\n\n      let lastError;\n      function handleError(err) {\n        lastError = err;\n      }\n\n      function handleEnd() {\n        client.removeListener('ready', handleReady);\n        client.removeListener('error', handleError);\n        reject(lastError);\n      }\n\n      client.once('ready', handleReady);\n      client.on('error', handleError);\n      client.once('end', handleEnd);\n    }\n  });\n}\n\nmodule.exports.errorObject = errorObject;\nmodule.exports.tryCatch = tryCatch;\nmodule.exports.isRedisReady = isRedisReady;\nmodule.exports.emitSafe = function(emitter, event, ...args) {\n  try {\n    return emitter.emit(event, ...args);\n  } catch (err) {\n    try {\n      return emitter.emit('error', err);\n    } catch (err) {\n      // We give up if the error event also throws an exception.\n      console.error(err);\n    }\n  }\n};\n\nmodule.exports.MetricsTime = {\n  ONE_MINUTE: 1,\n  FIVE_MINUTES: 5,\n  FIFTEEN_MINUTES: 15,\n  THIRTY_MINUTES: 30,\n  ONE_HOUR: 60,\n  ONE_WEEK: 60 * 24 * 7,\n  TWO_WEEKS: 60 * 24 * 7 * 2,\n  ONE_MONTH: 60 * 24 * 7 * 2 * 4\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3V0aWxzLmpzPzZkMzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZXJyb3JPYmplY3QgPSB7IHZhbHVlOiBudWxsIH07XG5mdW5jdGlvbiB0cnlDYXRjaChmbiwgY3R4LCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGN0eCwgYXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvck9iamVjdC52YWx1ZSA9IGU7XG4gICAgcmV0dXJuIGVycm9yT2JqZWN0O1xuICB9XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgcmVkaXMgY2xpZW50IHRvIGJlIHJlYWR5LlxuICogQHBhcmFtIHtSZWRpc30gcmVkaXMgY2xpZW50XG4gKi9cbmZ1bmN0aW9uIGlzUmVkaXNSZWFkeShjbGllbnQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoY2xpZW50LnN0YXR1cyA9PT0gJ3JlYWR5Jykge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdW5jdGlvbiBoYW5kbGVSZWFkeSgpIHtcbiAgICAgICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBoYW5kbGVFbmQpO1xuICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBsYXN0RXJyb3I7XG4gICAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIpIHtcbiAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVFbmQoKSB7XG4gICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcigncmVhZHknLCBoYW5kbGVSZWFkeSk7XG4gICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgIHJlamVjdChsYXN0RXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBjbGllbnQub25jZSgncmVhZHknLCBoYW5kbGVSZWFkeSk7XG4gICAgICBjbGllbnQub24oJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgY2xpZW50Lm9uY2UoJ2VuZCcsIGhhbmRsZUVuZCk7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZXJyb3JPYmplY3QgPSBlcnJvck9iamVjdDtcbm1vZHVsZS5leHBvcnRzLnRyeUNhdGNoID0gdHJ5Q2F0Y2g7XG5tb2R1bGUuZXhwb3J0cy5pc1JlZGlzUmVhZHkgPSBpc1JlZGlzUmVhZHk7XG5tb2R1bGUuZXhwb3J0cy5lbWl0U2FmZSA9IGZ1bmN0aW9uKGVtaXR0ZXIsIGV2ZW50LCAuLi5hcmdzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBXZSBnaXZlIHVwIGlmIHRoZSBlcnJvciBldmVudCBhbHNvIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5NZXRyaWNzVGltZSA9IHtcbiAgT05FX01JTlVURTogMSxcbiAgRklWRV9NSU5VVEVTOiA1LFxuICBGSUZURUVOX01JTlVURVM6IDE1LFxuICBUSElSVFlfTUlOVVRFUzogMzAsXG4gIE9ORV9IT1VSOiA2MCxcbiAgT05FX1dFRUs6IDYwICogMjQgKiA3LFxuICBUV09fV0VFS1M6IDYwICogMjQgKiA3ICogMixcbiAgT05FX01PTlRIOiA2MCAqIDI0ICogNyAqIDIgKiA0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/utils.js\n");

/***/ }),

/***/ "(action-browser)/../../node_modules/bull/lib/worker.js":
/*!*********************************************!*\
  !*** ../../node_modules/bull/lib/worker.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst utils = __webpack_require__(/*! ./utils */ \"(action-browser)/../../node_modules/bull/lib/utils.js\");\nconst clientCommandMessageReg = /ERR unknown command ['`]\\s*client\\s*['`]/;\n\nmodule.exports = function(Queue) {\n  // IDEA, How to store metadata associated to a worker.\n  // create a key from the worker ID associated to the given name.\n  // We keep a hash table bull:myqueue:workers where every worker is a hash key workername:workerId with json holding\n  // metadata of the worker. The worker key gets expired every 30 seconds or so, we renew the worker metadata.\n  //\n  Queue.prototype.setWorkerName = function() {\n    return utils\n      .isRedisReady(this.client)\n      .then(() => {\n        const connectionName = this.clientName();\n        this.bclient.options.connectionName = connectionName;\n        return this.bclient.client('setname', connectionName);\n      })\n      .catch(err => {\n        if (!clientCommandMessageReg.test(err.message)) throw err;\n      });\n  };\n\n  Queue.prototype.getWorkers = function() {\n    return utils\n      .isRedisReady(this.client)\n      .then(() => {\n        return this.client.client('list');\n      })\n      .then(clients => {\n        return this.parseClientList(clients);\n      })\n      .catch(err => {\n        if (!clientCommandMessageReg.test(err.message)) throw err;\n      });\n  };\n\n  Queue.prototype.base64Name = function() {\n    return Buffer.from(this.name).toString('base64');\n  };\n\n  Queue.prototype.clientName = function() {\n    return this.keyPrefix + ':' + this.base64Name();\n  };\n\n  Queue.prototype.parseClientList = function(list) {\n    const lines = list.split('\\n');\n    const clients = [];\n\n    lines.forEach(line => {\n      const client = {};\n      const keyValues = line.split(' ');\n      keyValues.forEach(keyValue => {\n        const index = keyValue.indexOf('=');\n        const key = keyValue.substring(0, index);\n        const value = keyValue.substring(index + 1);\n        client[key] = value;\n      });\n      const name = client['name'];\n      if (name && name.startsWith(this.clientName())) {\n        client['name'] = this.name;\n        clients.push(client);\n      }\n    });\n    return clients;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvd29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdW5idWlsdC9hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3dvcmtlci5qcz83OGNhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBjbGllbnRDb21tYW5kTWVzc2FnZVJlZyA9IC9FUlIgdW5rbm93biBjb21tYW5kIFsnYF1cXHMqY2xpZW50XFxzKlsnYF0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFF1ZXVlKSB7XG4gIC8vIElERUEsIEhvdyB0byBzdG9yZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHRvIGEgd29ya2VyLlxuICAvLyBjcmVhdGUgYSBrZXkgZnJvbSB0aGUgd29ya2VyIElEIGFzc29jaWF0ZWQgdG8gdGhlIGdpdmVuIG5hbWUuXG4gIC8vIFdlIGtlZXAgYSBoYXNoIHRhYmxlIGJ1bGw6bXlxdWV1ZTp3b3JrZXJzIHdoZXJlIGV2ZXJ5IHdvcmtlciBpcyBhIGhhc2gga2V5IHdvcmtlcm5hbWU6d29ya2VySWQgd2l0aCBqc29uIGhvbGRpbmdcbiAgLy8gbWV0YWRhdGEgb2YgdGhlIHdvcmtlci4gVGhlIHdvcmtlciBrZXkgZ2V0cyBleHBpcmVkIGV2ZXJ5IDMwIHNlY29uZHMgb3Igc28sIHdlIHJlbmV3IHRoZSB3b3JrZXIgbWV0YWRhdGEuXG4gIC8vXG4gIFF1ZXVlLnByb3RvdHlwZS5zZXRXb3JrZXJOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWxzXG4gICAgICAuaXNSZWRpc1JlYWR5KHRoaXMuY2xpZW50KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uTmFtZSA9IHRoaXMuY2xpZW50TmFtZSgpO1xuICAgICAgICB0aGlzLmJjbGllbnQub3B0aW9ucy5jb25uZWN0aW9uTmFtZSA9IGNvbm5lY3Rpb25OYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy5iY2xpZW50LmNsaWVudCgnc2V0bmFtZScsIGNvbm5lY3Rpb25OYW1lKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKCFjbGllbnRDb21tYW5kTWVzc2FnZVJlZy50ZXN0KGVyci5tZXNzYWdlKSkgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLmdldFdvcmtlcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdXRpbHNcbiAgICAgIC5pc1JlZGlzUmVhZHkodGhpcy5jbGllbnQpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jbGllbnQoJ2xpc3QnKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihjbGllbnRzID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGllbnRMaXN0KGNsaWVudHMpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZiAoIWNsaWVudENvbW1hbmRNZXNzYWdlUmVnLnRlc3QoZXJyLm1lc3NhZ2UpKSB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUuYmFzZTY0TmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLm5hbWUpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUuY2xpZW50TmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmtleVByZWZpeCArICc6JyArIHRoaXMuYmFzZTY0TmFtZSgpO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5wYXJzZUNsaWVudExpc3QgPSBmdW5jdGlvbihsaXN0KSB7XG4gICAgY29uc3QgbGluZXMgPSBsaXN0LnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBjbGllbnRzID0gW107XG5cbiAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgY29uc3QgY2xpZW50ID0ge307XG4gICAgICBjb25zdCBrZXlWYWx1ZXMgPSBsaW5lLnNwbGl0KCcgJyk7XG4gICAgICBrZXlWYWx1ZXMuZm9yRWFjaChrZXlWYWx1ZSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0ga2V5VmFsdWUuaW5kZXhPZignPScpO1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlWYWx1ZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGtleVZhbHVlLnN1YnN0cmluZyhpbmRleCArIDEpO1xuICAgICAgICBjbGllbnRba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBuYW1lID0gY2xpZW50WyduYW1lJ107XG4gICAgICBpZiAobmFtZSAmJiBuYW1lLnN0YXJ0c1dpdGgodGhpcy5jbGllbnROYW1lKCkpKSB7XG4gICAgICAgIGNsaWVudFsnbmFtZSddID0gdGhpcy5uYW1lO1xuICAgICAgICBjbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xpZW50cztcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../../node_modules/bull/lib/worker.js\n");

/***/ })

};
;